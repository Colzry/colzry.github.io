<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on Colzry's Blog</title><link>https://blog.colzry.tk/tags/rust/</link><description>Recent content in Rust on Colzry's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 16 Jun 2023 16:41:30 +0800</lastBuildDate><atom:link href="https://blog.colzry.tk/tags/rust/rss.xml" rel="self" type="application/rss+xml"/><item><title>Rust的下载和安装</title><link>https://blog.colzry.tk/posts/rust/rust%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85/</link><pubDate>Fri, 16 Jun 2023 16:41:30 +0800</pubDate><guid>https://blog.colzry.tk/posts/rust/rust%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85/</guid><description>下载 官网地址 下载地址 安装 windows 推荐使用WSL安装 Windows安装 安装器下载地址 https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-gnu/rustup-init.exe 工具链选择 x86_64-pc-windows-gnu 其它的默认就行 配置系统变量环境 CARGO_HOME C:\Users\Colzry.cargo RUSTUP_HOME C:\Users\Colzry.rustup 编辑PATH</description></item><item><title>Rust枚举实现链表</title><link>https://blog.colzry.tk/posts/rust/%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8/</link><pubDate>Fri, 16 Jun 2023 16:41:30 +0800</pubDate><guid>https://blog.colzry.tk/posts/rust/%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8/</guid><description>use crate::List::*; enum List { // Cons: 链表中包含有值的节点，节点是元组类型，第一个元素是节点的值，第二个元素是指向下一个节点的指针 Cons(u32, Box&amp;lt;List&amp;gt;), // Nil: 链表中的最后一个节点，用于</description></item><item><title>Rust排序算法</title><link>https://blog.colzry.tk/posts/rust/rust%E7%AE%97%E6%B3%95/</link><pubDate>Fri, 16 Jun 2023 16:41:30 +0800</pubDate><guid>https://blog.colzry.tk/posts/rust/rust%E7%AE%97%E6%B3%95/</guid><description>1. 归并算法 [dependencies] rand = &amp;#34;0.8.5&amp;#34; stopwatch = &amp;#34;0.0.7&amp;#34; use rand::prelude::*; use stopwatch::Stopwatch; fn merge_sort(arr: &amp;amp;mut [i32]) { if arr.len() &amp;gt; 1 { let mid = arr.len() / 2; merge_sort(&amp;amp;mut arr[..mid]); merge_sort(&amp;amp;mut arr[mid..]); merge(arr, mid); } } fn merge(arr: &amp;amp;mut [i32], mid: usize) { let left = arr[..mid].to_vec(); let right = arr[mid..].to_vec(); let mut l = 0; let mut r = 0; for data in arr {</description></item></channel></rss>