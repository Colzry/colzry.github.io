<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.116.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.png><link rel=icon type=image/x-icon href=/imgs/icons/favicon.png><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/favicon.png><meta itemprop=name content="Nginx 高级配置"><meta itemprop=description content="Nginx 高级配置"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://colzry.github.io/imgs/avatar.jpg"><meta itemprop=keywords content="Nginx"><meta property="og:type" content="article"><meta property="og:title" content="Nginx 高级配置"><meta property="og:description" content="Nginx 高级配置"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://colzry.github.io/posts/nginx/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/"><meta property="og:site_name" content="Colzry's Blog"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Colzry"><meta property="article:published_time" content="2023-06-16 16:41:30 +0800 +0800"><meta property="article:modified_time" content="2023-06-16 16:41:30 +0800 +0800"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.7efab351038eac56da41c92d9d6d38d8a9f1fc8fd6a9b17ea5982415a7b542a3.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE","permalink":"https://colzry.github.io/posts/nginx/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/","title":"Nginx 高级配置","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>Nginx 高级配置 - Colzry's Blog</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Colzry's Blog</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>Colzry的博客</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-flinks"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-thumbs-up hvr-icon"></i>站点示例</a></li><li class="menu-item menu-item-archives"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>112</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#1-nginx反向代理-负载均衡>1. Nginx反向代理-负载均衡</a><ul><li><a href=#11-nginx请求分发原理>1.1 Nginx请求分发原理</a></li></ul></li><li><a href=#2-nginx动静分离>2. Nginx动静分离</a></li><li><a href=#3-资源压缩>3. 资源压缩</a></li><li><a href=#4-nginx缓冲>4. Nginx缓冲</a><ul><li><a href=#41-nginx缓冲区>4.1 Nginx缓冲区</a></li><li><a href=#42-nginx缓冲机制>4.2 Nginx缓冲机制</a></li><li><a href=#43-缓存清理>4.3 缓存清理</a></li></ul></li><li><a href=#5-nginx实现ip黑白名单>5. Nginx实现IP黑白名单</a></li><li><a href=#6-nginx跨域配置>6. Nginx跨域配置</a><ul><li><a href=#跨域问题产生的原因>跨域问题产生的原因</a></li><li><a href=#nginx解决跨域问题>Nginx解决跨域问题</a></li></ul></li><li><a href=#7-nginx防盗链设计>7. Nginx防盗链设计</a></li><li><a href=#8-nginx大文件传输配置>8. Nginx大文件传输配置</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Colzry src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Colzry</p><div class=site-description itemprop=description>今早起来雾沉沉，我是一个抽卡人</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>112</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>18</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>57</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/Colzry title="Github → https://github.com/Colzry" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>Github</a></span>
<span class=links-of-social-item><a href=mailto:colzry@foxmail.com title="E-Mail → mailto:colzry@foxmail.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>E-Mail</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn title=https://lisenhui.cn target=_blank>凡梦星尘空间站</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2021-04-16T16:41:30+08:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=114635></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=296></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2023-06-16T16:41:30+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-gtranslate class=button title=多语言翻译><i class="fas fa-globe"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/Colzry rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script>
<script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://colzry.github.io/posts/nginx/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Colzry"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Colzry"><meta itemprop=description content="今早起来雾沉沉，我是一个抽卡人"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Nginx 高级配置"><meta itemprop=description content="Nginx 高级配置"></span><header class=post-header><h1 class=post-title itemprop="name headline">Nginx 高级配置</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2023-06-16 16:41:30 +0800 +0800" itemprop="dateCreated datePublished" datetime="2023-06-16 16:41:30 +0800 +0800">2023-06-16</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/nginx itemprop=url rel=index><span itemprop=name>Nginx</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>10675</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>22分钟</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv class=waline-pageview-count data-path=/posts/nginx/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h1 id=高级配置>高级配置</h1><blockquote><p>原文地址：https://juejin.cn/post/7112826654291918855</p></blockquote><h2 id=1-nginx反向代理-负载均衡>1. Nginx反向代理-负载均衡</h2><p>首先通过SpringBoot+Freemarker快速搭建一个WEB项目：springboot-web-nginx，然后在该项目中，创建一个IndexNginxController.java文件，逻辑如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Controller</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>IndexNginxController</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Value</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;${server.port}&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String port<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@RequestMapping</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> ModelAndView <span style=color:#a6e22e>index</span><span style=color:#f92672>(){</span>
</span></span><span style=display:flex><span>        ModelAndView model <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ModelAndView<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        model<span style=color:#f92672>.</span><span style=color:#a6e22e>addObject</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;port&#34;</span><span style=color:#f92672>,</span> port<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        model<span style=color:#f92672>.</span><span style=color:#a6e22e>setViewName</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;index&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> model<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>在该Controller类中，存在一个成员变量：port，它的值即是从application.properties配置文件中获取server.port值。当出现访问/资源的请求时，跳转前端index页面，并将该值携带返回。</p><p>前端的index.ftl文件代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>html</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>head</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>title</span>&gt;Nginx演示页面&lt;/<span style=color:#f92672>title</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>link</span> <span style=color:#a6e22e>href</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;nginx_style.css&#34;</span> <span style=color:#a6e22e>rel</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;stylesheet&#34;</span> <span style=color:#a6e22e>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;text/css&#34;</span>/&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>head</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>body</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>style</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;border: 2px solid red;margin: auto;width: 800px;text-align: center&#34;</span>&gt;
</span></span><span style=display:flex><span>            &lt;<span style=color:#f92672>div</span>  <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;nginx_title&#34;</span>&gt;
</span></span><span style=display:flex><span>                &lt;<span style=color:#f92672>h1</span>&gt;欢迎来到熊猫高级会所，我是竹子${port}号！&lt;/<span style=color:#f92672>h1</span>&gt;
</span></span><span style=display:flex><span>            &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>        &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>body</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>html</span>&gt;
</span></span></code></pre></div><p>从上可以看出其逻辑并不复杂，仅是从响应中获取了port输出。</p><p>OK~，前提工作准备就绪后，再简单修改一下nginx.conf的配置即可：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>upstream nginx_boot<span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e># 30s内检查心跳发送两次包，未回复就代表该机器宕机，请求分发权重比为1:2</span>
</span></span><span style=display:flex><span>   server 192.168.0.000:8080 weight<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span> max_fails<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> fail_timeout<span style=color:#f92672>=</span>30s; 
</span></span><span style=display:flex><span>   server 192.168.0.000:8090 weight<span style=color:#f92672>=</span><span style=color:#ae81ff>200</span> max_fails<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> fail_timeout<span style=color:#f92672>=</span>30s;
</span></span><span style=display:flex><span>   <span style=color:#75715e># 这里的IP请配置成你WEB服务所在的机器IP</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>server <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    location / <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        root   html;
</span></span><span style=display:flex><span>        <span style=color:#75715e># 配置一下index的地址，最后加上index.ftl。</span>
</span></span><span style=display:flex><span>        index  index.html index.htm index.jsp index.ftl;
</span></span><span style=display:flex><span>        proxy_set_header Host $host;
</span></span><span style=display:flex><span>        proxy_set_header X-Real-IP $remote_addr;
</span></span><span style=display:flex><span>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
</span></span><span style=display:flex><span>        <span style=color:#75715e># 请求交给名为nginx_boot的upstream上</span>
</span></span><span style=display:flex><span>        proxy_pass http://nginx_boot;
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>至此，所有的前提工作准备就绪，紧接着再启动Nginx，然后再启动两个web服务，第一个WEB服务启动时，在application.properties配置文件中，将端口号改为8080，第二个WEB服务启动时，将其端口号改为8090。</p><p>最终来看看效果：
<img src=/imgs/img-lazy-loading.gif data-src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39cb300f9f3c435e86c7d6d8044f86a6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp alt=负载均衡效果-动图演示>
因为配置了请求分发的权重，8080、8090的权重比为2:1，因此请求会根据权重比均摊到每台机器，也就是8080一次、8090两次、8080一次&mldr;&mldr;</p><h3 id=11-nginx请求分发原理>1.1 Nginx请求分发原理</h3><p>客户端发出的请求192.168.12.129最终会转变为：http://192.168.12.129:80/，然后再向目标IP发起请求，流程如下：
<img src=/imgs/img-lazy-loading.gif data-src=https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1578248f05e41d5932f832e959340d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp? alt=请求分发原理></p><p>由于Nginx监听了192.168.12.129的80端口，所以最终该请求会找到Nginx进程；
Nginx首先会根据配置的location规则进行匹配，根据客户端的请求路径/，会定位到location /{}规则；
然后根据该location中配置的proxy_pass会再找到名为nginx_boot的upstream；
最后根据upstream中的配置信息，将请求转发到运行WEB服务的机器处理，由于配置了多个WEB服务，且配置了权重值，因此Nginx会依次根据权重比分发请求。</p><h2 id=2-nginx动静分离>2. Nginx动静分离</h2><p>动静分离应该是听的次数较多的性能优化方案，那先思考一个问题：<strong>为什么需要做动静分离呢？它带来的好处是什么？</strong> 其实这个问题也并不难回答，当你搞懂了网站的本质后，自然就理解了动静分离的重要性。先来以淘宝为例分析看看：
<img src=/imgs/img-lazy-loading.gif data-src=https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e10220ddea954a1a952876103bdc8542~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp? alt=淘宝首页>
当浏览器输入<code>www.taobao.com</code>访问淘宝首页时，打开开发者调试工具可以很明显的看到，首页加载会出现<code>100+</code>的请求数，而正常项目开发时，静态资源一般会放入到<code>resources/static/</code>目录下：
<img src=/imgs/img-lazy-loading.gif data-src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1964e569cb8140e2aaf7a979a916cbf3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp? alt=IDEA工程结构>
在项目上线部署时，这些静态资源会一起打成包，那此时思考一个问题：<strong>假设淘宝也是这样干的，那么首页加载时的请求最终会去到哪儿被处理？</strong> 答案毋庸置疑，首页<code>100+</code>的所有请求都会来到部署<code>WEB</code>服务的机器处理，那则代表着一个客户端请求淘宝首页，就会对后端服务器造成<code>100+</code>的并发请求。毫无疑问，这对于后端服务器的压力是尤为巨大的。</p><blockquote><p>但此时不妨分析看看，首页<code>100+</code>的请求中，是不是至少有<code>60+</code>是属于<code>*.js、*.css、*.html、*.jpg.....</code>这类静态资源的请求呢？答案是<code>Yes</code>。</p></blockquote><p>既然有这么多请求属于静态的，这些资源大概率情况下，长时间也不会出现变动，那为何还要让这些请求到后端再处理呢？能不能在此之前就提前处理掉？当然<code>OK</code>，因此经过分析之后能够明确一点：<strong>做了动静分离之后，至少能够让后端服务减少一半以上的并发量。</strong> 到此时大家应该明白了动静分离能够带来的性能收益究竟有多大。</p><hr><p>OK~，搞清楚动静分离的必要性之后，如何实现动静分离呢？其实非常简单，实战看看。</p><p>①先在部署<code>Nginx</code>的机器，<code>Nginx</code>目录下创建一个目录<code>static_resources</code>：</p><blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>mkdir static_resources
</span></span></code></pre></div></blockquote><p>②将项目中所有的静态资源全部拷贝到该目录下，而后将项目中的静态资源移除重新打包。</p><p>③稍微修改一下<code>nginx.conf</code>的配置，增加一条<code>location</code>匹配规则：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>location ~ .*<span style=color:#ae81ff>\.</span><span style=color:#f92672>(</span>html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>    root   /soft/nginx/static_resources;
</span></span><span style=display:flex><span>    expires 7d;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>然后照常启动<code>nginx</code>和移除了静态资源的<code>WEB</code>服务，你会发现原本的样式、<code>js</code>效果、图片等依旧有效，如下：
<img src=/imgs/img-lazy-loading.gif data-src=https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf50b5604c1e4cd197cc758d0f5666f9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp? alt=移除静态资源>
其中<code>static</code>目录下的<code>nginx_style.css</code>文件已被移除，但效果依旧存在（绿色字体+蓝色大边框）：
<img src=/imgs/img-lazy-loading.gif data-src=https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2e14de0ca5045d6af91a0cabc9f653e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp alt=移除后效果动图></p><blockquote><p>最后解读一下那条<code>location</code>规则：
<code>location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css)</code>
<code>~</code>代表匹配时区分大小写
<code>.*</code>代表任意字符都可以出现零次或多次，即资源名不限制
<code>\.</code>代表匹配后缀分隔符<code>.</code>
<code>(html|...|css)</code>代表匹配括号里所有静态资源类型
综上所述，简单一句话概述：<strong>该配置表示匹配以<code>.html~.css</code>为后缀的所有资源请求。</strong></p></blockquote><p><em>最后提一嘴，也可以将静态资源上传到文件服务器中，然后<code>location</code>中配置一个新的<code>upstream</code>指向。</em></p><h2 id=3-资源压缩>3. 资源压缩</h2><p>建立在动静分离的基础之上，如果一个静态资源的<code>Size</code>越小，那么自然传输速度会更快，同时也会更节省带宽，因此我们在部署项目时，也可以通过<code>Nginx</code>对于静态资源实现压缩传输，一方面可以节省带宽资源，第二方面也可以加快响应速度并提升系统整体吞吐。</p><p>在<code>Nginx</code>也提供了三个支持资源压缩的模块<code>ngx_http_gzip_module、ngx_http_gzip_static_module、ngx_http_gunzip_module</code>，其中<code>ngx_http_gzip_module</code>属于内置模块，代表着可以直接使用该模块下的一些压缩指令，后续的资源压缩操作都基于该模块，先来看看压缩配置的一些参数/指令：</p><table><thead><tr><th>参数项</th><th>释义</th><th>参数值</th></tr></thead><tbody><tr><td><code>gzip</code></td><td>开启或关闭压缩机制</td><td><code>on/off;</code></td></tr><tr><td><code>gzip_types</code></td><td>根据文件类型选择性开启压缩机制</td><td><code>image/png、text/css...</code></td></tr><tr><td><code>gzip_comp_level</code></td><td>用于设置压缩级别，级别越高越耗时</td><td><code>1~9</code>（越高压缩效果越好）</td></tr><tr><td><code>gzip_vary</code></td><td>设置是否携带<code>Vary:Accept-Encoding</code>头域的响应头部</td><td><code>on/off;</code></td></tr><tr><td><code>gzip_buffers</code></td><td>设置处理压缩请求的缓冲区数量和大小</td><td>数量 大小，如<code>16 8k;</code></td></tr><tr><td><code>gzip_disable</code></td><td>针对不同客户端的请求来设置是否开启压缩</td><td>如 <code>.*Chrome.*;</code></td></tr><tr><td><code>gzip_http_version</code></td><td>指定压缩响应所需要的最低<code>HTTP</code>请求版本</td><td>如<code>1.1;</code></td></tr><tr><td><code>gzip_min_length</code></td><td>设置触发压缩的文件最低大小</td><td>如<code>512k;</code></td></tr><tr><td><code>gzip_proxied</code></td><td>对于后端服务器的响应结果是否开启压缩</td><td><code>off、expired、no-cache...</code></td></tr></tbody></table><p>了解了<code>Nginx</code>中的基本压缩配置后，接下来可以在<code>Nginx</code>中简单配置一下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>http<span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 开启压缩机制</span>
</span></span><span style=display:flex><span>    gzip on;
</span></span><span style=display:flex><span>    <span style=color:#75715e># 指定会被压缩的文件类型(也可自己配置其他类型)</span>
</span></span><span style=display:flex><span>    gzip_types text/plain application/javascript text/css application/xml text/javascript image/jpeg image/gif image/png;
</span></span><span style=display:flex><span>    <span style=color:#75715e># 设置压缩级别，越高资源消耗越大，但压缩效果越好</span>
</span></span><span style=display:flex><span>    gzip_comp_level 5;
</span></span><span style=display:flex><span>    <span style=color:#75715e># 在头部中添加Vary: Accept-Encoding（建议开启）</span>
</span></span><span style=display:flex><span>    gzip_vary on;
</span></span><span style=display:flex><span>    <span style=color:#75715e># 处理压缩请求的缓冲区数量和大小</span>
</span></span><span style=display:flex><span>    gzip_buffers <span style=color:#ae81ff>16</span> 8k;
</span></span><span style=display:flex><span>    <span style=color:#75715e># 对于不支持压缩功能的客户端请求不开启压缩机制</span>
</span></span><span style=display:flex><span>    gzip_disable <span style=color:#e6db74>&#34;MSIE [1-6]\.&#34;</span>; <span style=color:#75715e># 低版本的IE浏览器不支持压缩</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 设置压缩响应所支持的HTTP最低版本</span>
</span></span><span style=display:flex><span>    gzip_http_version 1.1;
</span></span><span style=display:flex><span>    <span style=color:#75715e># 设置触发压缩的最小阈值</span>
</span></span><span style=display:flex><span>    gzip_min_length 2k;
</span></span><span style=display:flex><span>    <span style=color:#75715e># 关闭对后端服务器的响应结果进行压缩</span>
</span></span><span style=display:flex><span>    gzip_proxied off;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>在上述的压缩配置中，最后一个<code>gzip_proxied</code>选项，可以根据系统的实际情况决定，总共存在多种选项：</p><ul><li><code>off</code>：关闭<code>Nginx</code>对后台服务器的响应结果进行压缩。</li><li><code>expired</code>：如果响应头中包含<code>Expires</code>信息，则开启压缩。</li><li><code>no-cache</code>：如果响应头中包含<code>Cache-Control:no-cache</code>信息，则开启压缩。</li><li><code>no-store</code>：如果响应头中包含<code>Cache-Control:no-store</code>信息，则开启压缩。</li><li><code>private</code>：如果响应头中包含<code>Cache-Control:private</code>信息，则开启压缩。</li><li><code>no_last_modified</code>：如果响应头中不包含<code>Last-Modified</code>信息，则开启压缩。</li><li><code>no_etag</code>：如果响应头中不包含<code>ETag</code>信息，则开启压缩。</li><li><code>auth</code>：如果响应头中包含<code>Authorization</code>信息，则开启压缩。</li><li><code>any</code>：无条件对后端的响应结果开启压缩机制。</li></ul><p>OK~，简单修改好了<code>Nginx</code>的压缩配置后，可以在原本的<code>index</code>页面中引入一个<code>jquery-3.6.0.js</code>文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>script</span> <span style=color:#a6e22e>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;text/javascript&#34;</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;jquery-3.6.0.js&#34;</span>&gt;&lt;/<span style=color:#f92672>script</span>&gt;
</span></span></code></pre></div><p>分别来对比下压缩前后的区别：
<img src=/imgs/img-lazy-loading.gif data-src=https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2116205a44c941efb06b8fc95c737a54~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp? alt=Nginx压缩前后区别>
从图中可以很明显看出，未开启压缩机制前访问时，<code>js</code>文件的原始大小为<code>230K</code>，当配置好压缩后再重启<code>Nginx</code>，会发现文件大小从<code>230KB→69KB</code>，效果立竿见影！</p><blockquote><p>注意点：
①对于图片、视频类型的数据，会默认开启压缩机制，因此一般无需再次开启压缩。
②对于<code>.js</code>文件而言，需要指定压缩类型为<code>application/javascript</code>，而并非<code>text/javascript、application/x-javascript</code>。</p></blockquote><h2 id=4-nginx缓冲>4. Nginx缓冲</h2><h3 id=41-nginx缓冲区>4.1 Nginx缓冲区</h3><p>先来思考一个问题，接入<code>Nginx</code>的项目一般请求流程为：“客户端→<code>Nginx</code>→服务端”，在这个过程中存在两个连接：“客户端→<code>Nginx</code>、<code>Nginx</code>→服务端”，那么两个不同的连接速度不一致，就会影响用户的体验（比如浏览器的加载速度跟不上服务端的响应速度）。
其实也就类似电脑的内存跟不上<code>CPU</code>速度，所以对于用户造成的体验感极差，因此在<code>CPU</code>设计时都会加入三级高速缓冲区，用于缓解<code>CPU</code>和内存速率不一致的矛盾。在<code>Nginx</code>也同样存在缓冲区的机制，主要目的就在于：<strong>用来解决两个连接之间速度不匹配造成的问题</strong>，有了缓冲后，<code>Nginx</code>代理可暂存后端的响应，然后按需供给数据给客户端。先来看看一些关于缓冲区的配置项：</p><ul><li><p><code>proxy_buffering</code>：是否启用缓冲机制，默认为<code>on</code>关闭状态。</p></li><li><p><code>client_body_buffer_size</code>：设置缓冲客户端请求数据的内存大小。</p></li><li><p><code>proxy_buffers</code>：为每个请求/连接设置缓冲区的数量和大小，默认<code>4 4k/8k</code>。</p></li><li><p><code>proxy_buffer_size</code>：设置用于存储响应头的缓冲区大小。</p></li><li><p><code>proxy_busy_buffers_size</code>：在后端数据没有完全接收完成时，<code>Nginx</code>可以将<code>busy</code>状态的缓冲返回给客户端，该参数用来设置<code>busy</code>状态的<code>buffer</code>具体有多大，默认为<code>proxy_buffer_size*2</code>。</p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_temp_path
</span></span></code></pre></div><p>：当内存缓冲区存满时，可以将数据临时存放到磁盘，该参数是设置存储缓冲数据的目录。</p><ul><li><p>语法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_temp_path path;
</span></span></code></pre></div><ul><li><code>path</code>是临时目录的路径。</li></ul></li></ul></li><li><p><code>proxy_temp_file_write_size</code>：设置每次写数据到临时文件的大小限制。</p></li><li><p><code>proxy_max_temp_file_size</code>：设置临时的缓冲目录中允许存储的最大容量。</p></li><li><p>非缓冲参数项：</p><ul><li><code>proxy_connect_timeout</code>：设置与后端服务器建立连接时的超时时间。</li><li><code>proxy_read_timeout</code>：设置从后端服务器读取响应数据的超时时间。</li><li><code>proxy_send_timeout</code>：设置向后端服务器传输请求数据的超时时间。</li></ul></li></ul><p>具体的<code>nginx.conf</code>配置如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>http<span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    proxy_connect_timeout 10;
</span></span><span style=display:flex><span>    proxy_read_timeout 120;
</span></span><span style=display:flex><span>    proxy_send_timeout 10;
</span></span><span style=display:flex><span>    proxy_buffering on;
</span></span><span style=display:flex><span>    client_body_buffer_size 512k;
</span></span><span style=display:flex><span>    proxy_buffers <span style=color:#ae81ff>4</span> 64k;
</span></span><span style=display:flex><span>    proxy_buffer_size 16k;
</span></span><span style=display:flex><span>    proxy_busy_buffers_size 128k;
</span></span><span style=display:flex><span>    proxy_temp_file_write_size 128k;
</span></span><span style=display:flex><span>    proxy_temp_path /soft/nginx/temp_buffer;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>上述的缓冲区参数，是基于每个请求分配的空间，而并不是所有请求的共享空间。当然，具体的参数值还需要根据业务去决定，要综合考虑机器的内存以及每个请求的平均数据大小。</p><blockquote><p>最后提一嘴：使用缓冲也可以减少即时传输带来的带宽消耗。</p></blockquote><h3 id=42-nginx缓冲机制>4.2 Nginx缓冲机制</h3><p>对于性能优化而言，缓存是一种能够大幅度提升性能的方案，因此几乎可以在各处都能看见缓存，如客户端缓存、代理缓存、服务器缓存等等，<code>Nginx</code>的缓存则属于代理缓存的一种。对于整个系统而言，加入缓存带来的优势额外明显：</p><ul><li>减少了再次向后端或文件服务器请求资源的带宽消耗。</li><li>降低了下游服务器的访问压力，提升系统整体吞吐。</li><li>缩短了响应时间，提升了加载速度，打开页面的速度更快。</li></ul><p>那么在<code>Nginx</code>中，又该如何配置代理缓存呢？先来看看缓存相关的配置项：</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_cache_path
</span></span></code></pre></div><p>：代理缓存的路径。</p><ul><li>语法：<code>proxy_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time];</code></li><li>是的，你没有看错，就是这么长&mldr;.，解释一下每个参数项的含义：<ul><li><code>path</code>：缓存的路径地址。</li><li><code>levels</code>：缓存存储的层次结构，最多允许三层目录。</li><li><code>use_temp_path</code>：是否使用临时目录。</li><li><code>keys_zone</code>：指定一个共享内存空间来存储热点<code>Key</code>(<code>1M</code>可存储<code>8000</code>个<code>Key</code>)。</li><li><code>inactive</code>：设置缓存多长时间未被访问后删除（默认是十分钟）。</li><li><code>max_size</code>：允许缓存的最大存储空间，超出后会基于<code>LRU</code>算法移除缓存，<code>Nginx</code>会创建一个<code>Cache manager</code>的进程移除数据，也可以通过<code>purge</code>方式。</li><li><code>manager_files</code>：<code>manager</code>进程每次移除缓存文件数量的上限。</li><li><code>manager_sleep</code>：<code>manager</code>进程每次移除缓存文件的时间上限。</li><li><code>manager_threshold</code>：<code>manager</code>进程每次移除缓存后的间隔时间。</li><li><code>loader_files</code>：重启<code>Nginx</code>载入缓存时，每次加载的个数，默认<code>100</code>。</li><li><code>loader_sleep</code>：每次载入时，允许的最大时间上限，默认<code>200ms</code>。</li><li><code>loader_threshold</code>：一次载入后，停顿的时间间隔，默认<code>50ms</code>。</li><li><code>purger</code>：是否开启<code>purge</code>方式移除数据。</li><li><code>purger_files</code>：每次移除缓存文件时的数量。</li><li><code>purger_sleep</code>：每次移除时，允许消耗的最大时间。</li><li><code>purger_threshold</code>：每次移除完成后，停顿的间隔时间。</li></ul></li></ul></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_cache
</span></span></code></pre></div><p>：开启或关闭代理缓存，开启时需要指定一个共享内存区域。</p><ul><li><p>语法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_cache zone | off;
</span></span></code></pre></div><ul><li><code>zone</code>为内存区域的名称，即上面中<code>keys_zone</code>设置的名称。</li></ul></li></ul></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_cache_key
</span></span></code></pre></div><p>：定义如何生成缓存的键。</p><ul><li><p>语法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_cache_key string;
</span></span></code></pre></div><ul><li><code>string</code>为生成<code>Key</code>的规则，如<code>$scheme$proxy_host$request_uri</code>。</li></ul></li></ul></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_cache_valid
</span></span></code></pre></div><p>：缓存生效的状态码与过期时间。</p><ul><li><p>语法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_cache_valid [code ...] time;
</span></span></code></pre></div><ul><li><code>code</code>为状态码，<code>time</code>为有效时间，可以根据状态码设置不同的缓存时间。</li><li>例如：<code>proxy_cache_valid 200 302 30m;</code></li></ul></li></ul></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_cache_min_uses
</span></span></code></pre></div><p>：设置资源被请求多少次后被缓存。</p><ul><li><p>语法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_cache_min_uses number;
</span></span></code></pre></div><ul><li><code>number</code>为次数，默认为<code>1</code>。</li></ul></li></ul></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_cache_use_stale
</span></span></code></pre></div><p>：当后端出现异常时，是否允许</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>Nginx
</span></span></code></pre></div><p>返回缓存作为响应。</p><ul><li><p>语法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_cache_use_stale error;
</span></span></code></pre></div><ul><li><code>error</code>为错误类型，可配置<code>timeout|invalid_header|updating|http_500...</code>。</li></ul></li></ul></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_cache_lock
</span></span></code></pre></div><p>：对于相同的请求，是否开启锁机制，只允许一个请求发往后端。</p><ul><li>语法：<code>proxy_cache_lock on | off;</code></li></ul></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_cache_lock_timeout
</span></span></code></pre></div><p>：配置锁超时机制，超出规定时间后会释放请求。</p><ul><li><code>proxy_cache_lock_timeout time;</code></li></ul></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_cache_methods
</span></span></code></pre></div><p>：设置对于那些</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>HTTP
</span></span></code></pre></div><p>方法开启缓存。</p><ul><li><p>语法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_cache_methods method;
</span></span></code></pre></div><ul><li><code>method</code>为请求方法类型，如<code>GET、HEAD</code>等。</li></ul></li></ul></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_no_cache
</span></span></code></pre></div><p>：定义不存储缓存的条件，符合时不会保存。</p><ul><li><p>语法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_no_cache string...;
</span></span></code></pre></div><ul><li><code>string</code>为条件，例如<code>$cookie_nocache $arg_nocache $arg_comment;</code></li></ul></li></ul></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_cache_bypass
</span></span></code></pre></div><p>：定义不读取缓存的条件，符合时不会从缓存中读取。</p><ul><li><p>语法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy_cache_bypass string...;
</span></span></code></pre></div><ul><li>和上面<code>proxy_no_cache</code>的配置方法类似。</li></ul></li></ul></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>add_header
</span></span></code></pre></div><p>：往响应头中添加字段信息。</p><ul><li>语法：<code>add_header fieldName fieldValue</code>;</li></ul></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>$upstream_cache_status
</span></span></code></pre></div><p>：记录了缓存是否命中的信息，存在多种情况：</p><ul><li><code>MISS</code>：请求未命中缓存。</li><li><code>HIT</code>：请求命中缓存。</li><li><code>EXPIRED</code>：请求命中缓存但缓存已过期。</li><li><code>STALE</code>：请求命中了陈旧缓存。</li><li><code>REVALIDDATED</code>：<code>Nginx</code>验证陈旧缓存依然有效。</li><li><code>UPDATING</code>：命中的缓存内容陈旧，但正在更新缓存。</li><li><code>BYPASS</code>：响应结果是从原始服务器获取的。</li><li>PS：这个和之前的不同，之前的都是参数项，这个是一个<code>Nginx</code>内置变量。</li></ul></li></ul><p>OK~，对于<code>Nginx</code>中的缓存配置项大概了解后，接着来配置一下<code>Nginx</code>代理缓存：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>http<span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 设置缓存的目录，并且内存中缓存区名为hot_cache，大小为128m，</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 三天未被访问过的缓存自动清楚，磁盘中缓存的最大容量为2GB。</span>
</span></span><span style=display:flex><span>    proxy_cache_path /soft/nginx/cache levels<span style=color:#f92672>=</span>1:2 keys_zone<span style=color:#f92672>=</span>hot_cache:128m inactive<span style=color:#f92672>=</span>3d max_size<span style=color:#f92672>=</span>2g;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    server<span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        location / <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># 使用名为nginx_cache的缓存空间</span>
</span></span><span style=display:flex><span>            proxy_cache hot_cache;
</span></span><span style=display:flex><span>            <span style=color:#75715e># 对于200、206、304、301、302状态码的数据缓存1天</span>
</span></span><span style=display:flex><span>            proxy_cache_valid <span style=color:#ae81ff>200</span> <span style=color:#ae81ff>206</span> <span style=color:#ae81ff>304</span> <span style=color:#ae81ff>301</span> <span style=color:#ae81ff>302</span> 1d;
</span></span><span style=display:flex><span>            <span style=color:#75715e># 对于其他状态的数据缓存30分钟</span>
</span></span><span style=display:flex><span>            proxy_cache_valid any 30m;
</span></span><span style=display:flex><span>            <span style=color:#75715e># 定义生成缓存键的规则（请求的url+参数作为key）</span>
</span></span><span style=display:flex><span>            proxy_cache_key $host$uri$is_args$args;
</span></span><span style=display:flex><span>            <span style=color:#75715e># 资源至少被重复访问三次后再加入缓存</span>
</span></span><span style=display:flex><span>            proxy_cache_min_uses 3;
</span></span><span style=display:flex><span>            <span style=color:#75715e># 出现重复请求时，只让一个去后端读数据，其他的从缓存中读取</span>
</span></span><span style=display:flex><span>            proxy_cache_lock on;
</span></span><span style=display:flex><span>            <span style=color:#75715e># 上面的锁超时时间为3s，超过3s未获取数据，其他请求直接去后端</span>
</span></span><span style=display:flex><span>            proxy_cache_lock_timeout 3s;
</span></span><span style=display:flex><span>            <span style=color:#75715e># 对于请求参数或cookie中声明了不缓存的数据，不再加入缓存</span>
</span></span><span style=display:flex><span>            proxy_no_cache $cookie_nocache $arg_nocache $arg_comment;
</span></span><span style=display:flex><span>            <span style=color:#75715e># 在响应头中添加一个缓存是否命中的状态（便于调试）</span>
</span></span><span style=display:flex><span>            add_header Cache-status $upstream_cache_status;
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>接着来看一下效果，如下：
<img src=/imgs/img-lazy-loading.gif data-src=https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f464660086884d6eb2939176f9b5275a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp? alt=代理缓存>
第一次访问时，因为还没有请求过资源，所以缓存中没有数据，因此没有命中缓存。第二、三次，依旧没有命中缓存，直至第四次时才显示命中，这是为什么呢？因为在前面的缓存配置中，我们配置了加入缓存的最低条件为：<strong>资源至少要被请求三次以上才会加入缓存。</strong> 这样可以避免很多无效缓存占用空间。</p><h3 id=43-缓存清理>4.3 缓存清理</h3><p>当缓存过多时，如果不及时清理会导致磁盘空间被“吃光”，因此我们需要一套完善的缓存清理机制去删除缓存，在之前的<code>proxy_cache_path</code>参数中有<code>purger</code>相关的选项，开启后可以帮我们自动清理缓存，但遗憾的是：<strong><code>purger</code>系列参数只有商业版的<code>NginxPlus</code>才能使用，因此需要付费才可使用。</strong></p><p>不过天无绝人之路，我们可以通过强大的第三方模块<code>ngx_cache_purge</code>来替代，先来安装一下该插件：
①首先去到<code>Nginx</code>的安装目录下，创建一个<code>cache_purge</code>目录：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@localhost<span style=color:#f92672>]</span><span style=color:#75715e># mkdir cache_purge &amp;&amp; cd cache_purge</span>
</span></span></code></pre></div><p>②通过<code>wget</code>指令从<code>github</code>上拉取安装包的压缩文件并解压：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@localhost<span style=color:#f92672>]</span><span style=color:#75715e># wget https://github.com/FRiCKLE/ngx_cache_purge/archive/2.3.tar.gz</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@localhost<span style=color:#f92672>]</span><span style=color:#75715e># tar -xvzf 2.3.tar.gz</span>
</span></span></code></pre></div><p>③再次去到之前<code>Nginx</code>的解压目录下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@localhost<span style=color:#f92672>]</span><span style=color:#75715e># cd /soft/nginx/nginx1.21.6</span>
</span></span></code></pre></div><p>④重新构建一次<code>Nginx</code>，通过<code>--add-module</code>的指令添加刚刚的第三方模块：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@localhost<span style=color:#f92672>]</span><span style=color:#75715e># ./configure --prefix=/soft/nginx/ --add-module=/soft/nginx/cache_purge/ngx_cache_purge-2.3/</span>
</span></span></code></pre></div><p>⑤重新根据刚刚构建的<code>Nginx</code>，再次编译一下，<strong>但切记不要<code>make install</code></strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@localhost<span style=color:#f92672>]</span><span style=color:#75715e># make</span>
</span></span></code></pre></div><p>⑥删除之前<code>Nginx</code>的启动文件，不放心的也可以移动到其他位置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@localhost<span style=color:#f92672>]</span><span style=color:#75715e># rm -rf /soft/nginx/sbin/nginx</span>
</span></span></code></pre></div><p>⑦从生成的<code>objs</code>目录中，重新复制一个<code>Nginx</code>的启动文件到原来的位置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@localhost<span style=color:#f92672>]</span><span style=color:#75715e># cp objs/nginx /soft/nginx/sbin/nginx</span>
</span></span></code></pre></div><p>至此，第三方缓存清除模块<code>ngx_cache_purge</code>就安装完成了，接下来稍微修改一下<code>nginx.conf</code>配置，再添加一条<code>location</code>规则：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>location ~ /purge<span style=color:#f92672>(</span>/.*<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 配置可以执行清除操作的IP（线上可以配置成内网机器）</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># allow 127.0.0.1; # 代表本机</span>
</span></span><span style=display:flex><span>  allow all; <span style=color:#75715e># 代表允许任意IP清除缓存</span>
</span></span><span style=display:flex><span>  proxy_cache_purge $host$1$is_args$args;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>然后再重启<code>Nginx</code>，接下来即可通过<code>http://xxx/purge/xx</code>的方式清除缓存。</p><h2 id=5-nginx实现ip黑白名单>5. Nginx实现IP黑白名单</h2><p>有时候往往有些需求，可能某些接口只能开放给对应的合作商，或者购买/接入<code>API</code>的合作伙伴，那么此时就需要实现类似于<code>IP</code>白名单的功能。而有时候有些恶意攻击者或爬虫程序，被识别后需要禁止其再次访问网站，因此也需要实现<code>IP</code>黑名单。那么这些功能无需交由后端实现，可直接在<code>Nginx</code>中处理。</p><p><code>Nginx</code>做黑白名单机制，主要是通过<code>allow、deny</code>配置项来实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>allow xxx.xxx.xxx.xxx; <span style=color:#75715e># 允许指定的IP访问，可以用于实现白名单。</span>
</span></span><span style=display:flex><span>deny xxx.xxx.xxx.xxx; <span style=color:#75715e># 禁止指定的IP访问，可以用于实现黑名单。</span>
</span></span></code></pre></div><p>要同时屏蔽/开放多个<code>IP</code>访问时，如果所有<code>IP</code>全部写在<code>nginx.conf</code>文件中定然是不显示的，这种方式比较冗余，那么可以新建两个文件<code>BlocksIP.conf、WhiteIP.conf</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># --------黑名单：BlocksIP.conf---------</span>
</span></span><span style=display:flex><span>deny 192.177.12.222; <span style=color:#75715e># 屏蔽192.177.12.222访问</span>
</span></span><span style=display:flex><span>deny 192.177.44.201; <span style=color:#75715e># 屏蔽192.177.44.201访问</span>
</span></span><span style=display:flex><span>deny 127.0.0.0/8; <span style=color:#75715e># 屏蔽127.0.0.1到127.255.255.254网段中的所有IP访问</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># --------白名单：WhiteIP.conf---------</span>
</span></span><span style=display:flex><span>allow 192.177.12.222; <span style=color:#75715e># 允许192.177.12.222访问</span>
</span></span><span style=display:flex><span>allow 192.177.44.201; <span style=color:#75715e># 允许192.177.44.201访问</span>
</span></span><span style=display:flex><span>allow 127.45.0.0/16; <span style=color:#75715e># 允许127.45.0.1到127.45.255.254网段中的所有IP访问</span>
</span></span><span style=display:flex><span>deny all; <span style=color:#75715e># 除开上述IP外，其他IP全部禁止访问</span>
</span></span></code></pre></div><p>分别将要禁止/开放的<code>IP</code>添加到对应的文件后，可以再将这两个文件在<code>nginx.conf</code>中导入：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>http<span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 屏蔽该文件中的所有IP</span>
</span></span><span style=display:flex><span>    include /soft/nginx/IP/BlocksIP.conf; 
</span></span><span style=display:flex><span> server<span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    location xxx <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 某一系列接口只开放给白名单中的IP</span>
</span></span><span style=display:flex><span>        include /soft/nginx/IP/blockip.conf; 
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>对于文件具体在哪儿导入，这个也并非随意的，如果要整站屏蔽/开放就在<code>http</code>中导入，如果只需要一个域名下屏蔽/开放就在<code>sever</code>中导入，如果只需要针对于某一系列接口屏蔽/开放<code>IP</code>，那么就在<code>location</code>中导入。</p><blockquote><p>当然，上述只是最简单的<code>IP</code>黑/白名单实现方式，同时也可以通过<code>ngx_http_geo_module、ngx_http_geo_module</code>第三方库去实现（这种方式可以按地区、国家进行屏蔽，并且提供了<code>IP</code>库）。</p></blockquote><h2 id=6-nginx跨域配置>6. Nginx跨域配置</h2><p>跨域问题在之前的单体架构开发中，其实是比较少见的问题，除非是需要接入第三方<code>SDK</code>时，才需要处理此问题。但随着现在前后端分离、分布式架构的流行，跨域问题也成为了每个Java开发必须要懂得解决的一个问题。</p><h3 id=跨域问题产生的原因>跨域问题产生的原因</h3><p>产生跨域问题的主要原因就在于<strong>同源策略</strong>，为了保证用户信息安全，防止恶意网站窃取数据，同源策略是必须的，否则<code>cookie</code>可以共享。由于<code>http</code>无状态协议通常会借助<code>cookie</code>来实现有状态的信息记录，例如用户的身份/密码等，因此一旦<code>cookie</code>被共享，那么会导致用户的身份信息被盗取。
同源策略主要是指三点相同，<strong>协议+域名+端口</strong> 相同的两个请求，则可以被看做是同源的，但如果其中任意一点存在不同，则代表是两个不同源的请求，同源策略会限制了不同源之间的资源交互。</p><h3 id=nginx解决跨域问题>Nginx解决跨域问题</h3><p>弄明白了跨域问题的产生原因，接下来看看<code>Nginx</code>中又该如何解决跨域呢？其实比较简单，在<code>nginx.conf</code>中稍微添加一点配置即可：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>location / <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 允许跨域的请求，可以自定义变量$http_origin，*表示所有</span>
</span></span><span style=display:flex><span>    add_header <span style=color:#e6db74>&#39;Access-Control-Allow-Origin&#39;</span> *;
</span></span><span style=display:flex><span>    <span style=color:#75715e># 允许携带cookie请求</span>
</span></span><span style=display:flex><span>    add_header <span style=color:#e6db74>&#39;Access-Control-Allow-Credentials&#39;</span> <span style=color:#e6db74>&#39;true&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e># 允许跨域请求的方法：GET,POST,OPTIONS,PUT</span>
</span></span><span style=display:flex><span>    add_header <span style=color:#e6db74>&#39;Access-Control-Allow-Methods&#39;</span> <span style=color:#e6db74>&#39;GET,POST,OPTIONS,PUT&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e># 允许请求时携带的头部信息，*表示所有</span>
</span></span><span style=display:flex><span>    add_header <span style=color:#e6db74>&#39;Access-Control-Allow-Headers&#39;</span> *;
</span></span><span style=display:flex><span>    <span style=color:#75715e># 允许发送按段获取资源的请求</span>
</span></span><span style=display:flex><span>    add_header <span style=color:#e6db74>&#39;Access-Control-Expose-Headers&#39;</span> <span style=color:#e6db74>&#39;Content-Length,Content-Range&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e># 一定要有！！！否则Post请求无法进行跨域！</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 在发送Post跨域请求前，会以Options方式发送预检请求，服务器接受时才会正式请求</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>$request_method <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;OPTIONS&#39;</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        add_header <span style=color:#e6db74>&#39;Access-Control-Max-Age&#39;</span> 1728000;
</span></span><span style=display:flex><span>        add_header <span style=color:#e6db74>&#39;Content-Type&#39;</span> <span style=color:#e6db74>&#39;text/plain; charset=utf-8&#39;</span>;
</span></span><span style=display:flex><span>        add_header <span style=color:#e6db74>&#39;Content-Length&#39;</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#75715e># 对于Options方式的请求返回204，表示接受跨域请求</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> 204;
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>在<code>nginx.conf</code>文件加上如上配置后，跨域请求即可生效了。</p><blockquote><p>但如果后端是采用分布式架构开发的，有时候RPC调用也需要解决跨域问题，不然也同样会出现无法跨域请求的异常，因此可以在你的后端项目中，通过继承<code>HandlerInterceptorAdapter</code>类、实现<code>WebMvcConfigurer</code>接口、添加<code>@CrossOrgin</code>注解的方式实现接口之间的跨域配置。</p></blockquote><h2 id=7-nginx防盗链设计>7. Nginx防盗链设计</h2><p>首先了解一下何谓盗链：<strong>盗链即是指外部网站引入当前网站的资源对外展示</strong>，来举个简单的例子理解：</p><blockquote><p>好比壁纸网站<code>X</code>站、<code>Y</code>站，<code>X</code>站是一点点去购买版权、签约作者的方式，从而积累了海量的壁纸素材，但<code>Y</code>站由于资金等各方面的原因，就直接通过<code>&lt;img src="X站/xxx.jpg" /></code>这种方式照搬了<code>X</code>站的所有壁纸资源，继而提供给用户下载。</p></blockquote><p>那么如果我们自己是这个<code>X</code>站的<code>Boss</code>，心中必然不爽，那么此时又该如何屏蔽这类问题呢？那么接下来要叙说的<strong>防盗链</strong> 登场了！</p><p><code>Nginx</code>的防盗链机制实现，跟上篇文章
<a href=https://juejin.cn/post/7109497228103778311 title=《HTTP/HTTPS》 rel="noopener external nofollow noreferrer" target=_blank class=exturl>《HTTP/HTTPS》
<i class="fa fa-external-link-alt"></i>
</a>中分析到的一个头部字段：<code>Referer</code>有关，该字段主要描述了当前请求是从哪儿发出的，那么在<code>Nginx</code>中就可获取该值，然后判断是否为本站的资源引用请求，如果不是则不允许访问。<code>Nginx</code>中存在一个配置项为<code>valid_referers</code>，正好可以满足前面的需求，语法如下：</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>valid_referers none | blocked | server_names | string ...;
</span></span></code></pre></div><ul><li><code>none</code>：表示接受没有<code>Referer</code>字段的<code>HTTP</code>请求访问。</li><li><code>blocked</code>：表示允许<code>http://</code>或<code>https//</code>以外的请求访问。</li><li><code>server_names</code>：资源的白名单，这里可以指定允许访问的域名。</li><li><code>string</code>：可自定义字符串，支配通配符、正则表达式写法。</li></ul></li></ul><p>简单了解语法后，接下来的实现如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 在动静分离的location中开启防盗链机制</span>
</span></span><span style=display:flex><span>location ~ .*<span style=color:#ae81ff>\.</span><span style=color:#f92672>(</span>html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 最后面的值在上线前可配置为允许的域名地址</span>
</span></span><span style=display:flex><span>    valid_referers blocked 192.168.12.129;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>$invalid_referer<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 可以配置成返回一张禁止盗取的图片</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># rewrite   ^/ http://xx.xx.com/NO.jpg;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 也可直接返回403</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>   403;
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    root   /soft/nginx/static_resources;
</span></span><span style=display:flex><span>    expires 7d;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>根据上述中的内容配置后，就已经通过<code>Nginx</code>实现了最基本的防盗链机制，最后只需要额外重启一下就好啦！当然，对于防盗链机制实现这块，也有专门的第三方模块<code>ngx_http_accesskey_module</code>实现了更为完善的设计，感兴趣的小伙伴可以自行去看看。</p><blockquote><p>PS：防盗链机制也无法解决爬虫伪造<code>referers</code>信息的这种方式抓取数据。</p></blockquote><h2 id=8-nginx大文件传输配置>8. Nginx大文件传输配置</h2><p>在某些业务场景中需要传输一些大文件，但大文件传输时往往都会会出现一些<code>Bug</code>，比如文件超出限制、文件传输过程中请求超时等，那么此时就可以在<code>Nginx</code>稍微做一些配置，先来了解一些关于大文件传输时可能会用的配置项：</p><table><thead><tr><th>配置项</th><th>释义</th></tr></thead><tbody><tr><td><code>client_max_body_size</code></td><td>设置请求体允许的最大体积</td></tr><tr><td><code>client_header_timeout</code></td><td>等待客户端发送一个请求头的超时时间</td></tr><tr><td><code>client_body_timeout</code></td><td>设置读取请求体的超时时间</td></tr><tr><td><code>proxy_read_timeout</code></td><td>设置请求被后端服务器读取时，<code>Nginx</code>等待的最长时间</td></tr><tr><td><code>proxy_send_timeout</code></td><td>设置后端向<code>Nginx</code>返回响应时的超时时间</td></tr></tbody></table><p>在传输大文件时，<code>client_max_body_size、client_header_timeout、proxy_read_timeout、proxy_send_timeout</code>这四个参数值都可以根据自己项目的实际情况来配置。</p><blockquote><p>上述配置仅是作为代理层需要配置的，因为最终客户端传输文件还是直接与后端进行交互，这里只是把作为网关层的<code>Nginx</code>配置调高一点，调到能够“容纳大文件”传输的程度。
当然，<code>Nginx</code>中也可以作为文件服务器使用，但需要用到一个专门的第三方模块<code>nginx-upload-module</code>，如果项目中文件上传的作用处不多，那么建议可以通过<code>Nginx</code>搭建，毕竟可以节省一台文件服务器资源。但如若文件上传/下载较为频繁，那么还是建议额外搭建文件服务器，并将上传/下载功能交由后端处理。</p></blockquote></div><footer class=post-footer><div class=post-tags><a href=/tags/nginx>Nginx</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=reward-container><div><i class="fa-solid fa-mug-hot"></i>请我喝杯咖啡吧 ヾ(^▽^*)))</div><button>赞赏</button><div class=post-reward><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/imgs/ali-pay.png alt="Colzry - 支付宝">
<span>支付宝</span></div><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/imgs/wechat-pay.png alt="Colzry - 微信">
<span>微信</span></div></div></div><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>文章标题：</strong>
Nginx 高级配置</li><li class=post-copyright-author><strong>本文作者：</strong>
Colzry</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://colzry.github.io/posts/nginx/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/ title="Nginx 高级配置">https://colzry.github.io/posts/nginx/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=/images/wechat_channel.jpg><span class=icon><i class="fab fa-weixin"></i></span>
<span class=label>WeChat</span></a></div><div class=social-item><a target=_blank class=social-link href=/atom.xml><span class=icon><i class="fa fa-rss"></i></span>
<span class=label>RSS</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/posts/nginx/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/ rel=next title="Nginx 常用命令"><i class="fa fa-chevron-left"></i> Nginx 常用命令</a></div><div class="post-nav-prev post-nav-item"><a href=/posts/nginx/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/ rel=prev title=Nginx常用配置>Nginx常用配置
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2019 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>Colzry</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.116.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.1 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>粤ICP备 18047355-1 号</a>
<img src=/imgs/gongan.png alt=沪公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=31011402009770" target=_blank>沪公网安备 31011402009770 号</a></div><div class=vendors-list><a target=_blank href=https://vercel.com title=Vercel><img src=/imgs/img-lazy-loading.gif data-src=/imgs/vendors/vercel.svg alt=Vercel></a>
<a target=_blank href=https://upyun.com title=又拍云><img src=/imgs/img-lazy-loading.gif data-src=/imgs/vendors/upyun.png alt=又拍云></a>
<a target=_blank href=https://webify.cloudbase.net title=Webify>Webify</a>
<span>提供CDN/云资源支持</span></div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"https://colzry.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"statis":{"enable":true,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.1","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":true,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.37028fbafbd97fd89808b4c7b5a3a81f01ed0ab24001d273d774f9546a0e9170.js defer></script></body></html>